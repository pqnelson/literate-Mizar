\input macros
\setchapno{-1}
\def\title{Mizar Parser}

@* [C] Introduction.
We are trying to understand Mizar. So I am transcribing the source
code into a literate program, following the order of
compilation. Perhaps this ``goes against the spirit'' of literate
programming, but it makes the most sense to understand what is going
on for programmers. 

We will begin with the ``Parser module'' (\texttt{base/parser.pas}), and all the
dependencies needed to compile it. For clarity (or at least ease of
reference) each ``chapter'' appearing in the table of contents
corresponds to a different file.

We are studying Mizar's source code as of Git commit \texttt{9e814a9568cfb44253d677e5209c360390fe6437}
(dated 2023 October 11).

@ \node{Files are chapters.}
We will organize the text by compiler dependencies. It makes sense to
treat each file as a separate ``chapter''. With the exception of this
introductory chapter (``chapter 0''), all future chapters are called
``File $n$''.

Just as Knuth's \emph{\TeX: The Program} (Addison--Wesley, 1986) was
organized into modules which are presented ``bottom-up'', each module
is discussed and programmed ``top-down'', we shall try to do
likewise. File $n+1$ can only depend on code appearing in Files $1$
through File $n$.

There are natural ways to ``cluster'' the discussion in each File,
which motivates the ``section'' and ``subsections''. Each section
(\emph{but not subsections!\/}) starts on a new page, written in sans
serif bold prefixed with explicit an ``Section''. Subsections are
written in sans serif bold prefixed with an explicit ``Subsection'',
with vertical whitespace separting it. This chapter has 
two sections (one discussing the flow of Mizar, and the other
enumerating observations and ``to do'' items).

@ Each chapter is written using numbered paragraphs, since we are
using Donald Knuth's \WEB/ to write a literate program. References
will be made to the paragraphs. Index entries give the paragraph
numbers associated with each entry. And even though I just used the
term ``paragraph number'', they really group several paragraphs into a
unit of writing.

Paragraphs are numbered \emph{independently} of chapter, section,
subsection. This is a quirk of \WEB/. This was how Mathematicians
wrote texts back in Euler's day. We will refer to a paragraph by
writing (\section$n$) to refer to paragraph $n$. Again, this was the
conventions used by Euler.

Each paragraph consists of three parts: the ``text part'' (informal
prose written in English), the ``macros part'' (which introduces
macros written in the \WEB/ language), and the ``code part'' (which
contains a pretty-printed snippet of \PASCAL/ code). A paragraph may
omit any of these parts but has at least one of them. Thus far, all
our numbered paragraphs have consisted of ``text parts'' only. The
``code part'' can optionally have a name in angled brackets. If the name is
missing, then it continues the previous chunk of code from the
previous numbered paragraph. 

@ The Mizar program is released under the GNU license. So let us place
this license in one place early on. (This is an example of a numbered
paragraph with a ``named code part''.)

@<GNU License@>=
{
   This file is part of the Mizar system.
   Copyright (c) Association of Mizar Users.
   License terms: GNU General Public License Version 3 or any later version.
}

@ \node{System dependent assumptions.}
We will note system dependent code when appropriate, but implicitly we
will assume we are working with users on a \UNIX/-like operating
system. Hardware should not matter (barring antiques from the 1960s or
earlier). We will cite the \POSIX/ standard when appropriate, but only
for the sake of discussion of things like ``How long can we expect a
filename to be?'' (\POSIX/ says the maximum length of a filename is
Operating System dependent, but must be at least 14 bytes long.)

@ \node{Asides and opinions.} Some paragraphs will be labeled as
``asides'' which are tangential remarks not directly relevant to
understanding the code, but will enrich the reader's life. \Ithink{The author
will offer opinions about the design and implementation of Mizar
in parenthetic sentences like this one, surrounded by double brackets.}
If the reader is unsatisfied by the arbitrary opinions of a random
programmer, then they can disable the asides by redefining
the \texttt{\BS Ithink} macro to have an empty body.

@ \node{Aside: Typography of ``Modern'' Pascal.}%
We will be following the typographical style as found in Niklaus
Wirth's@^Wirth, Niklaus@> \textit{Algorithms + Data Structures = Programs}
(Prentice--Hall, 1975) and Donald Knuth's@^Knuth, Donald E.@> \textit{\TeX: The Program}
(Addison--Wesley, 1986). But there are a few typographical situations
which requires thinking hard about, since ``classical'' \PASCAL/ does
not have \emph{object} or inheritence (or \emph{unit} modules).

First, we need to know that ``modern \PASCAL/'' differs from
the \PASCAL/ Knuth worked with, in several ways. Mizar uses ``units''
which are a module system introduced by UCSD \PASCAL/
(\textit{c{.}}~1977). We will need to format them for \WEAVE/.

Documentation and tutorials frequently compare \textbf{unit} to |program|, so
we should probably typeset it as such. The big question is whether the
\texttt{interface}, \texttt{implementation}, and \texttt{uses}
keywords are |var|-like or |const|-like. I ultimately decided for the
latter (since \&{var}-like typography would have them appear in the
index underlined).

We will treat |implementation| typographically \emph{as if} it were a
|const| because the |end| will not be indented properly otherwise.

@f unit==program
@f interface==const
@f implementation==const
@f uses==const

@ Objects appear in Free \PASCAL/, and they behave like records.
There are also |constructor| and |destructor| functions.

@f object==record
@f constructor==function
@f destructor==function

@ \node{Primitive functions.}
We have several primitive functions which should be formatted
especially. For example, |shr| is an infix operator like |mod| or
|div|. It corresponds to bitwise shifting right.

@f shr==div

@ \node{Cases.}
Following Knuth's ``\TeX: The Program'' (\section4), we will use |endcases| to
pair with |case|. The ``default case'' will be |othercases| (because
|else| gets too confusing).

@d othercases == others: {default for cases not listed explicitly}
@d endcases == @+end {follows the default case in an extended |case| statement}
@f othercases == else
@f endcases == end

@ \node{Debugging.} There are conditional compiler directives for
debugging purposes. Importantly, these \emph{must} be printed to the
source code when we invoke \TANGLE/.

@d mdebug == @{@&$IFDEF MDEBUG@}
@d end_mdebug == @{@&$ENDIF@}
@f mdebug == begin
@f end_mdebug == end

@ Actually, it may be useful just to have helper macros.

@d if_def(#) == @{@&$IFDEF #@}
@d if_not_def(#) == @{@&$IFNDEF #@}
@d else_if_def(#) == @{@&$ELSEIF DEFINED(#)@}
@d else_def == @{@&$ELSE@}
@d endif == @{@&$ENDIF@}
@d end_if == @+ endif
@f if_def == if
@f if_not_def == if
@f else_if_def == else
@f else_def == else
@f endif == end
@f end_if == end

@ \node{Toggling IO Checking.} Another compiler directive enables and
disables IO checking

@d disable_io_checking == @{@&$I-@}
@d enable_io_checking == @{@&$I+@}
@d without_io_checking(#) == disable_io_checking; #; enable_io_checking

@ \node{Logging.}
There appears to be a \\{CHReport} logger introduced in \texttt{kernel/prephan.pas},
but its type is defined in \texttt{kernel/req\_info.pas}.

@^\\{CHReport}@>

@ \node{References.}
I have inline citations to the literature, but there's some references
worth explicitly drawing the reader's attention to (which may or may
not make it to an inline citation):
\enumerate
\item Andrzej Trybulec, ``Some Features of the Mizar Language'', ESPRIT Workshop, Torino, 1993.\hfill\break
  Eprint: \href{https://mizar.uwb.edu.pl/project/trybulec93.pdf}{{\tt mizar.uwb.edu.pl/project/trybulec93.pdf}} --- \section4 discusses grammatical aspects of Mizar
\item Freek Wiedijk, ``Mizar's Soft Type System''. In K.\ Schneider and J.\
Brandt, eds., \emph{Theorem Proving in Higher Order Logics. TPHOLs 2007},
Springer, \doi{10.1007/978-3-540-74591-4_28}
(\href{https://www.cs.ru.nl/F.Wiedijk/mizar/miztype.pdf}{Eprint pdf}).
\item Adam Grabowski,
  Artur Korni\l{}owicz, and
  Adam Naumowicz's ``Mizar in a Nutshell''\hfill\break
  (\doi{10.6092/issn.1972-5787/1980})
\item  Christoph Schwarzweller,
  ``Mizar attributes: A technique to encode mathematical knowledge into type systems''.
   \emph{Studies in Logic, Grammar and Rhetoric} \textbf{10} no.23 (2007) 387--400.
\item Adam Naumowicz,
  ``Enhanced Processing of Adjectives in Mizar''.
  \emph{Studies in Grammar, Logic, and Rhetoric} \textbf{18} no.31
  (2009) 89--91 --- for details about the Analyzer handling attributes
\item Artur Korni\l{}owicz's
  ``Registrations vs Redefinitions in Mizar''
  (in A.\ Kohlhase, P.\ Libbrecht, BR.\ Miller, A.\ Naumowicz, W.\ Neuper, P.\ Quaresma, F.\ Wm.\ Tompa, M.\ Suda
  (eds) \emph{Joint Proc.\ FM4M, MathUI, and ThEdu}, 2016, pp.17--20,
  \href{https://ceur-ws.org/Vol-1785/F5.pdf}{{\tt ceur-ws.org/Vol-1785/F5.pdf}})
\item Artur Korni\l{}owicz's
  ``On rewriting rules in Mizar''
  (\emph{J.\ Autom.\ Reason.} \textbf{50} no.2 (2013) 203--210,
  \doi{10.1007/s10817-012-9261-6})
\item Mario Carneiro, ``Reimplementing Mizar in Rust''.
Eprint \arXiv{2304.08391}, see
especially the first two sections for an overview of Mizar's
workflow. (The code is available
at \href{https://github.com/digama0/mizar-rs}{{\tt github.com/digama0/mizar-rs}}.)
\endenumerate

\medbreak\noindent%
I should also credit Wayne Sewell's \emph{Weaving a Program: Literate Programming in Web}
(Van Nostrand Reinhold Computer, 1989) for discussing how to take a
pre-existing \PASCAL/ program and turn it into a \WEB/. Or, depending
on the quality of writing in this literate program, it's all his fault.

@^Grabowski, Adam@>
@:Kornilowicz, Artur}{Korni\l{}owicz, Artur@>
@^Naumowicz, Adam@>
@^Trybulec, Andrzej@>
@^Wiedijk, Freek@>

@* [S] Mizar's workflow.
This section will give a brief overview of what Mizar
``does'' when we run it. The analogy to bear in mind is with a batch
compiler: there's parsing, some intermediate steps, then emits some
output.

Just to give some rough estimates of where Mizar spends most of its
time, there are four phases Mizar reports when checking an article:
\enumerate
\item Parser (transforms input into an abstract syntax tree, writes it
to an \XML/ file);
\item MSM (transforms the abstract syntax tree into an explicitly
  typed intermediate representation) --- \texttt{base/first\_identification.pas},
  the \\{MSMAnalyzer} procedure; this will require
  transcribing \texttt{kernel/limits.pas} (which is mostly just a
  bunch of constant parameters);
\item Analyzer (performs type checking, tracks the goals, and other
  miscellaneous jobs) --- the \\{Analyze} procedure in \texttt{kernel/analyzer.pas};
  this requires transcribing kernel code
  (\texttt{lexicon.pas}, \texttt{inout.pas}, \texttt{iocorrel.pas}, \texttt{correl.pas}, \texttt{generato.pas}, \texttt{builtin.pas}, \texttt{justhan.pas}, \texttt{enums.pas}, \texttt{formats.pas},
  \texttt{identify.pas})
  and base code (\texttt{xmldict.pas}), approximately 19590 lines
  (16764 lines of code, the rest is whitespace and comments)
\item Checker (performs the proof checking for validity) ---
the \\{InferenceChecker} procedure
in \texttt{kernel/checker.pas}. This requires transcribing kernel
files (\texttt{checker.pas prechecker.pas equalizer.pas unifier.pas justhan.pas}),
approximately 8191 lines of code.
\endenumerate

Using numbers Mario Carneiro reported in his github repository,
roughly $14/15$ of Mizar's runtime (as measured in CPU time)
is spent on the Analyzer and Checker phases (among which, Mizar
spends about 5 times longer in the Checker phase than the Analyzer
phase). Parsing and MSM transforms the input into an intermediate
representation used in the latter two phases. Mizar spends about
$1/15$ of its time here.

@ \node{Accommodator.}
This will produce, among other outputs, the ``\texttt{.dct}'' file
(and its \XML/ counterpart, the ``\texttt{.dcx}'' file). The
``\texttt{.dct}'' file contains all the identifiers imported from
other articles and reserved keywords for Mizar. The Tokeniser needs it
to properly tokenise an article.

@ \node{Parsing phase.}
We can look at \texttt{kernel/verfinit.pas} to find the parsing phase
of the Mizar program is handled by the following lines of code:
\medbreak
\setbox0=\vbox{
\Y\P$\\{InitPass}(\.{\'Parser\ \ \'})$;\5
$\\{FileExam}(\\{EnvFileName}+\.{\'.dct\'})$;\5
$\\{InitScanning}(\\{MizFileName}+\\{ArticleExt},\39\\{EnvFileName})$;\5
\\{InitWSMizarArticle};\5
\\{Parse};\5
$\\{gFormatsColl}.\\{StoreFormats}(\\{EnvFileName}+\.{\'.frx\'})$;\5
\\{gFormatsColl}.\\{Done};\5
\\{FinishScanning};\5
$\\{Write\_WSMizArticle}(\\{gWSTextProper},\39\\{EnvFileName}+\.{\'.wsx\'})$;%
\par}
\boxblock{\box0}
\medbreak\noindent%
Our goal is to examine these functions, and understand what is going on.
We know \\{Parse} is defined in \texttt{base/parse.pas}, it
populates the \\{gWSTextProper} global variable using \texttt{base/parseraddition.pas},
and \\{Write\_WSMizArticle} is defined in \texttt{base/wsmarticle.pas}.
The \\{Parse} function continuously invokes \\{ReadToken}
(\section\xref{ReadToken}). 

This phase will be responsible for generating a ``\texttt{.frx}''
(formats \XML/) and a ``\texttt{.wsx}'' (weakly strict Mizar \XML/) file.


@* [s] Map of Mizar.
It will be useful to provide a summary of the files, to give the
reader an idea where to find various things. We offer the following
grouping of files. We will enumerate them by the chapter wherein the file is
discussed.

@ \node{System-dependent code.}
\enumerate
\item \texttt{base/mizenv.pas} provides functions for manipulating
  strings and file I/O
\item \texttt{base/pcmizver.pas} contains the major and minor version
  for Mizar, and data about the build
\item \texttt{base/mconsole.pas} provides common functions for
  printing messages to the console and parsing command line optional
  arguments % needs pcmizver
\item \texttt{base/errhan.pas} contains the \\{Position} type,
  functions for reporting errors, writing them in particular files % used by mstate.pas
\item \texttt{base/info.pas} for debugging purposes, logging to
  a \texttt{.inf} file % used by monitor.pas
\item \texttt{base/monitor.pas} code for signal processing, reports errors,
  and when calamity strikes exit Mizar  % used by mstate.pas
\item \texttt{base/mtime.pas} uniform framework for timing things% used by mstate.pas
\item \texttt{base/mstate.pas} code for reset the current position in
  an article and marking the time \edef\resumecounting{\the\enumi}
\endenumerate

@ \node{Infrastructure for the rest of Mizar's object-oriented code.}
\enumerate\enumi=\resumecounting
\item \texttt{base/numbers.pas} contains code for arbitrary-precision
  integers, rational numbers, and rational complex numbers
\item \texttt{base/mobjects.pas} contains the common data structures
  used in Mizar, things like dynamic arrays and the \\{MObject} base class;
\edef\resumecounting{\the\enumi}
\endenumerate

@ \node{XML infrastructure.}
\enumerate\enumi=\resumecounting
\item \texttt{base/xml\_dict.pas} contains only constant parameters
  and enumerated types
\item \texttt{base/librenv.pas} code for accessing the \texttt{prel/}
  subdirectories of the current article and of \texttt{\$MIZFILES/}
  --- this is only here because it defines the \\{MizFiles} global
  variable which stores the full path of the \texttt{\$MIZFILES/}
  environmental variable, and \\{MizFiles} is needed in \texttt{xml\_inout.pas};
  \Ithink{This \\{MizFiles} global variable should be refactored out to an earlier
  unit, because \texttt{librenv.pas} seems out of place here;}
\item \texttt{base/xml\_parser.pas} provides an abstract syntax tree
  for \XML/ and parses \XML/  
\item \texttt{base/xml\_inout.pas} handles reading from and writing to \XML/
  files, plus escaping strings, etc.
\edef\resumecounting{\the\enumi}
\endenumerate

@ \node{Tokenisation and other ``intermediate file management''.}
\enumerate\enumi=\resumecounting
\item \texttt{base/dicthan.pas} loading ``\texttt{.voc}'' files,
  and transform them into ``\texttt{.vct}'' and \XML/
  ``\texttt{.vcx}'' files
\item \texttt{base/scanner.pas} the Tokeniser and Scanner are implemented here
  (the naming is a little confusing, the \\{Scanner} class \textbf{is}
  the Tokeniser, and the \\{Tokeniser} class is an ``abstract
  Tokeniser'' operating on an arbitrary input stream accessed by an
  abstract \\{GetPhrase} method); also note, if we want to extend
  Mizar to support \UTF8 character encoding instead of \ASCII/, then
  this is the file we would modify;
\item \texttt{base/\_formats.pas} contains the data structures for ``formats''
  (basically a $\langle$Identifier, Number of arguments to left, Number of arguments to right$\rangle$ triple)
  used for parsing expressions;
\edef\resumecounting{\the\enumi}
\endenumerate

%\par\hang\textindent\item
@ \node{Abstract syntax tree class hierarchies.}
\enumerate\enumi=\resumecounting
\item \texttt{base/syntax.pas} provides ``abstract'' classes \\{Subexpression} and \\{Expression}
  for expressions, \\{Item} and \\{Block} for statements; the actual
  subclasses used by the parser are in
  the \texttt{parseraddition.pas} file;
\item \texttt{base/mscanner.pas} provides a number of important global
  variables for the parser, ``\texttt{.prf}'' file management, as well
  as the \\{gScanner} global variable for the parser;
\item \texttt{base/abstract\_syntax.pas} provides the abstract syntax
  tree for terms, types, attributes, formulas, and ``within expressions'';
\item \texttt{base/wsmarticle.pas} ``weakly strict Mizar'' is the name
  for the initial internal representation of Mizar, which has its own
  class hierarchy here, as well as writing a ``weakly strict Mizar'' article
  to an \XML/ file and reading back from an \XML/ file into a ``weakly strict
  Mizar'' abstract syntax tree;
\edef\resumecounting{\the\enumi}
\endenumerate

@ \node{Parser ``proper''.}
\enumerate\enumi=\resumecounting
\item \texttt{base/pragmas.pas} for parsing pragmas like ``\texttt{::\$P-}'',
  and global variables related to them;
\item \texttt{base/parseraddition.pas} for subclasses of the syntax
  tree class hierarchy from \texttt{syntax.pas}, used for constructing a
  ``weakly strict Mizar'' AST when parsing
\item \texttt{base/parser.pas} for parsing a token stream into an
  abstract syntax tree
\endenumerate

@* [S] Log of todos, bugs, improvements.
I have a number of observations from transcribing Mizar
into \WEB/. They're the last thing I have included in the introductory chapter.

@ \node{Possible improvements.}
\enumerate
\item In quicksort, picking the pivot is done by |P := (Low + High)/2|,
but it should be done by |P := Low + ((High - Low)/2)| to avoid
overflow.
\item Actually, quicksort should delegate work to a different sorting
algorithm when there is less than 10 items in the list. Sedgewick
pointed this out in his PhD thesis. (If quicksort \emph{were} a
culprit for slowness, we could even hardcode sort networks for small lists.)
\item We should also determine the pivot by looking at the median
value of |P = (3*Low + High)/4|, |P2 := (Low + High)/2|,
|P3 := (Low + 3*High)/4|. This will improve the performance of quicksort.
\item In \section\xref{numbers:gcd}, |GCD| could be optimized to avoid
calculating |Mul(i,i)| in every loop iteration.
\item In \section\xref{MStringList.ObjectOf}, |MStringList.ObjectOf|
has duplicate code.
\item It seems that parsing Mizar text, emitting \XML/, and
parsing \XML/ seem to contain a lot of code which could be
autogenerated from a grammar (a hypothetical ``\texttt{.ebnf}''
file). This would avoid duplicate work.
\endenumerate 

@ \node{Possible bugs.} I have been working through the source code
with the mindset of, ``How can I possibly break this?'' This has led
me to identify a number of situations where things can ``go
badly''. But they are not all bugs (some are impossible to occur).

\startbugs%\par\advance\leftskip\parindent%
\bug In \section\xref{MSortedCollection.IndexOf},
\\{MSortedCollection.IndexOf} returns $-1$ when duplicate entries are allowed.
Since Mizar does not seem to enable duplicate entries, this bug would
never have been experienced or caught.
\bug In \section\xref{TXTStreamObj.Done}, I think |TXTStreamObj.Done|
needs to close the associated file.
\bug In \section\xref{TSymbol.Init}, |TSymbol.Init| expects an
|fInfinitive| argument, but does not use it --- shouldn't it
 initialize |Infinite := fInfinitive|?
\bug In \section\xref{XMLScannObj.GetAttrValue}, escaped quotation
marks are not properly handled.
\bug For StreamObj (\section\xref{StreamObj}), the constructors and
destructors are not virtual which would impact XMLOutStreamObj
(\section\xref{XmlOutStreamObj}) --- well, we just do duplicate work
in XMLOutStreamObj's constructors and destructors.
\bug Shouldn't \\{TokensCollection.InitTokens} (\section\xref{TokensCollection.InitTokens})
invoke the inherited constructor?
\bug Shouldn't \\{MTokenObj.Init} (\section\xref{MTokenObj.Init})
invoke inherited constructors? At least to insulate itself from
changes to any of its parent (or grandparent) classes?
\bug The constructor \\{OutWSMizFileObj.OpenFileWithXSL} (\section\xref{OutWSMizFileObj.OpenFileWithXSL})
expects the \XML/-stylesheet located at \texttt{"file://'+\$MIZFILES+'/wsmiz.xml"},
but that file is not present in Mizar.
\bug In \\{extItemObj.FinishFunctorPattern} (\section\xref{extItemObj.FinishFunctorPattern}),
the default case does not add a new format to the \\{gFormatsColl} dictionary.
\bug In \\{CreateArgs} (\section\xref{CreateArgs}) in \texttt{parseraddition.pas}, when |aBase <= 0|, this
will set |TermNbr| to a negative number.
\bug In the Subexpression class, there is duplicate code
(\section\xref{extSubexpObj.CompleteAttributeArguments}) ---
the \\{CompleteAttributeArguments} and \\{FinishAttributeArguments}
are identical, but only the latter is consistent with the naming
conventions for the Parser. Or (probably more likely) I am misunderstanding the naming conventions?
\bug In \\{CompleteArgument}
(\section\xref{CompleteArgument:parser.pas}), we should also test
that \\{fParenthCnt} is positive, shouldn't we?
\bug The \\{CreateSubexpression} method (\section\xref{extExpressionObj.CreateSubexpression}),
for extended expression objects, may result in a memory leak
when |gSubexpPtr <> nil| --- that is to say, if \\{KillSubexpression}
has not been invoked prior to \\{CreateSubexpression}.
\bug Misnamed variable: \\{gIdenifyEqLociList} should be \\{gIdentifyEqLociList}
(i.e., ``idenify'' should be ``identify'' --- with a `t'). (This typo
has been corrected in the literate presentation of the code.)
\bug As discussed in (\section\xref{extItemObj.StartFixedVariables}),
there is a mismatch between the documentation and the Parser when it
comes to parsing loci declarations in a definition
block. The \texttt{syntax.txt} file is more restrictive than the
Parser, and should be updated to reflect the Parser.
\bug The \\{gSuchThat} global variable is never used anywhere (\section\xref{extItemObj.FinishFixedVariables})
\bug In \\{ATTSubexpression} (\section\xref{ATTSubexpression}), in the
|else| block when the conditional
|if lAttrExp or (aExpKind = exAdjectiveCluster)| is executed,
|aExpKind = exAdjectiveCluster| is never true (so there's no need for it).
\endbugs


@ \node{To do list.} There are some things I should revisit, revise,
and edit --- specifically about this running commentary (\emph{not} the Mizar
source code).
\enumerate
\item [Missing transcription] I skipped over transcribing
the \\{ItemName} and other constants from \texttt{wsmarticle.pas},
which I should probably include.
\item [Revise] The \XML/ schema should use the \texttt{doc/mizar/xml/Mizar.rnc}
  schema snippets.
\item [Revise] Make an introduction to dynamic arrays as a data structure, just
to standardize the terminology used. (Make sure I stick to the
standardized terminology!) Including pictures may help\dots
\item [Revise] Review quicksort. I should prove that it works, too. (Has this
been done in Mizar? \texttt{exchsort} seems to be the closest match.)
\item [Improve] Give a ``big picture'' summary of the architecture. For example,
the most interesting routine in parsing Mizar, well, it's all handled
in \\{MTokeniser.SliceIt} (\section\xref{MTokeniser.SliceIt}).
\item [Linting] Standardize the names of basic data types. \PASCAL/
accepts \\{integer} as synonymous with \\{Integer}, but they give
different index entries.
\item [Cosmetics] Check the typography is correct for the code
\item [Cosmetics] Create more \WEB/ macros for conditional compilation
\item [Cosmetics] Would it help to include more UML class diagrams?
\item [Improve] It may be useful to use UML State diagrams to explain
the parser --- or it may be a huge distraction?
\endenumerate

@ \node{Formatting types.}%
This is still a finicky aspect of \WEB/.
Strings are a type in Free \PASCAL/, like \emph{Boolean}.

Looking at Wirth's book, he typesets a type in \emph{italics} and
lowercase --- so we have \\{boolean} and not \&{boolean}
or \\{Boolean} (or \&{Boolean} or \texttt{boolean} or\dots). Knuth's
``\TeX: the program'' follows this convention
(using \\{integer}, \\{boolean}, \\{char}, etc.).

@ \node{Using Twill (or not).}%
Knuth invented Twill as a ``hack'' atop \WEAVE/ to include
``mini-indices'' every couple pages. The problem I have with Twill is
that it does not adequately index local variables (in the sense that:
Knuth's \TeX\ is a giant monolithic program, and any |var| appearing
in it is almost certainly a global variable --- hence it makes sense
to index \emph{all} variables, since they are almost certainly
global).

I \emph{want} to use Twill, but it is designed specifically \emph{for} Knuth.
Consequently it is not terribly useful for our purposes. We would have
to tailor it quite heavily, and I don't have the energy or patience to
do so.

@ \node{Caution:} Knuth takes advantage of \WEB/ to
use \texttt{snake\_case} when naming things instead
of Pascal's idiomatic \texttt{PascalCase}. This probably greatly
improves the readability of the code. We should probably think hard
about using it.

When \WEAVE/ extracts the \PASCAL/ code, it will remove all
underscores from the identifiers and capitalize all letters. So
instead of ``|screaming_run_on_case|'' (which appears in the PDF), we
will instead obtain ``\texttt{SCREAMINGRUNONCASE}'', which\dots yeah, that's a hot mess.

@* [S] Review of Pascal.
Following Wirth's \textit{Systematic Programming: An Introduction}
(Prentice-Hall, 1973; viz., Chapter~7), we can
offer the following axiomatic semantics for most of \PASCAL/'s statements.
@^Wirth, Niklaus@>

Assignment statements: $${{}\over\LB\,P[w/v]\,\RB\ v\K w\ \LB\,P\,\RB}$$
Compound statements: 
$${\displaystyle{\LB\,P\,\RB\ S_{1}\ \LB\,Q\,\RB\atop
\LB\,Q\,\RB\ S_{2}\ \LB\,R\,\RB}\over\LB\,P\,\RB\ S_{1};\ S_{2}\ \LB\,R\,\RB}$$
Conditional statements:
$${\displaystyle{\LB\,P\W B\,\RB\ S_{1}\ \LB\,Q\,\RB\atop
\LB\,P\W\R B\,\RB\ S_{2}\ \LB\,Q\,\RB}\over\LB\,P\,\RB\ \&{if}\ B\ \&{then}\ S_{1}\ \&{else}\ S_{2}\ \LB\,Q\,\RB}$$
Simpler conditional statements:
$${\displaystyle{\LB\,P\W B\,\RB\ S\ \LB\,Q\,\RB\atop
\LB\,P\W\R B\,\RB\implies\LB\,Q\,\RB}\over\LB\,P\,\RB\ \&{if}\ B\ \&{then}\ S\ \LB\,Q\,\RB}$$
While statements: $${{\LB\,P\W B\,\RB\ S\ \LB\,P\,\RB}\over\LB\,P\,\RB\ \&{while}\ B\ \&{do}\ S\ \LB\,P\W\R B\,\RB}$$
Repeat statements:
$${\displaystyle{{\LB\,P\,\RB\ S\ \LB\,Q\,\RB}\atop\LB\,Q\W\R B\,\RB\ S\ \LB\,Q\,\RB}\over\LB\,P\,\RB\ \&{repeat}\ \37S\ \&{until}\ B\ \LB\,Q\W B\,\RB}$$
Selective statement (and $i=L_{k}$ for some $k$):
$$\vbox{\halign{\hfil#\hfil\cr
${\LB\, P\W (i = L_{k})\,\RB\ S_{k}\ \LB\,Q\,\RB\hbox{ for all }k=1,\dots,n}$\cr
\noalign{\vskip2pt\hrule\vskip2pt}\cr
%\noalign{\hrule}\cr
\vbox{\halign{#\hfil\cr
$\LB\,P\,\RB\ \&{case}\ i\ \&{of}$\cr
\quad$L_{1}{:}\ S_{1};$\cr
\quad$L_{2}{:}\ S_{2};$\cr
\quad$\ \vdots\quad\;\,\vdots$\cr
\quad$L_{n}{:}\ S_{n};$\cr
$\&{end};\quad\LB\,Q\,\RB$\cr}}\cr}}$$
When there is no $k$ such that $i=L_{k}$, the \&{case} statement is
the same as evaluating $i$.

We can weaken the precondition:
$${{P_{1}\implies P_{2},\qquad \LB\,P_{2}\,\RB\ S\ \LB\,Q\,\RB}\over\LB\,P_{1}\,\RB\ S\ \LB\,Q\,\RB}$$
We can strengthen the postcondition (Equation (11.16), page 85, of
Wirth's book):
$${{Q_{2}\implies Q_{1},\qquad \LB\,P\,\RB\ S\ \LB\,Q_{2}\,\RB}\over\LB\,P\,\RB\ S\ \LB\,Q_{1}\,\RB}$$
These rules are justified as \emph{a priori} valid in Chapter~5 of
Wirth.

For-loops may be derived as:
$${\displaystyle{\LB\,(V=a)\W P\,\RB\ S\ \LB\,Q(a)\,\RB\atop
\LB\,Q(\\{pred}(x))\,\RB\ S\ \LB\,Q(x)\,\RB\hbox{ for all }a<x\leq b}\over
\displaystyle{\LB\,(a\leq b)\W P\,\RB\ \&{for}\ V\K a\ \&{to}\ b\ \&{do}\ S\ \LB\,Q(b)\,\RB\atop
\LB\,(a>b)\W P\,\RB\ \&{for}\ V\K a\ \&{to}\ b\ \&{do}\ S\ \LB\,P\,\RB}}$$

@ The \\{exit} procedure may be invoked in a procedure or function, and
it terminates the function or procedure. It roughly corresponds
to \CEE/'s \&{return} statement.