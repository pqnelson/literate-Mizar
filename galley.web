\input{labels2}
\input macros
\def\title{Galley Proof}

\setchapno{22}
%\secno=11
%\chapno=22

@ The Mizar program is released under the GNU license. So let us place
this license in one place.

@f unit==program
@f interface==const
@f implementation==const
@f uses==const
@f object==record
@f constructor==function
@f destructor==function
@f shr==div
@d othercases == others: {default for cases not listed explicitly}
@d endcases == @+end {follows the default case in an extended |case| statement}
@f othercases == else
@f endcases == end
@f private == else
@d disable_io_checking == @{@&$I-@}
@d enable_io_checking == @{@&$I+@}
@d without_io_checking(#) == disable_io_checking; #; enable_io_checking
@d mdebug == @{@&$IFDEF MDEBUG@}
@d end_mdebug == @{@&$ENDIF@}
@f mdebug == begin
@f end_mdebug == end

@

@<GNU License@>=
{
   This file is part of the Mizar system.
   Copyright (c) Association of Mizar Users.
   License terms: GNU General Public License Version 3 or any later version.
}

@ Bugs.

\bug In \\{extItemObj.FinishFunctorPattern} (\section\xref{extItemObj.FinishFunctorPattern}),
the default case does not add a new format to the \\{gFormatsColl} dictionary.
\bug In \\{CreateArgs} (\section\xref{CreateArgs}) in \texttt{parseraddition.pas}, when |aBase <= 0|, this
will set |TermNbr| to a negative number.
\bug In the Subexpression class, there is duplicate code
(\section\xref{extSubexpObj.CompleteAttributeArguments}) ---
the \\{CompleteAttributeArguments} and \\{FinishAttributeArguments}
are identical, but only the latter is consistent with the naming
conventions for the parser. Or (probably more likely) I am misunderstanding the naming conventions?
\bug In \\{CompleteArgument}
(\section\xref{CompleteArgument:parser.pas}), we should also test
that \\{fParenthCnt} is positive, shouldn't we?
\bug The \\{CreateSubexpression} method (\section\xref{extExpressionObj.CreateSubexpression}),
for extended expression objects, may result in a memory leak
when |gSubexpPtr <> nil| --- that is to say, if \\{KillSubexpression}
has not been invoked prior to \\{CreateSubexpression}.
\bug Misnamed variable: \\{gIdenifyEqLociList} should be \\{gIdentifyEqLociList}
(i.e., ``idenify'' should be ``identify'' --- with a `t'). (This typo
has been corrected in the literate presentation of the code.)
\bug As discussed in (\section\xref{extItemObj.StartFixedVariables}),
there is a mismatch between the documentation and the parser when it
comes to parsing loci declarations in a definition
block. The \texttt{syntax.txt} file is more restrictive than the
parser, and should be updated to reflect the parser.
\bug The \\{gSuchThat} global variable is never used anywhere (\section\xref{extItemObj.FinishFixedVariables})
\bug In \\{ATTSubexpression} (\section\xref{ATTSubexpression}), in the
|else| block when the conditional
|if lAttrExp or (aExpKind = exAdjectiveCluster)| is executed,
|aExpKind = exAdjectiveCluster| is never true (so there's no need for it).

@* [F] Detour: Pragmas.
This chapter is a ``detour'' because it is out of order for the
compiler, but it is a dependency for the next file
(\texttt{parseradditions.pas}). 

The \texttt{base/pragmas.pas} contains the global variables
which are toggled by pragmas like ``\texttt{::\$P+}''. This will
toggle the \\{ProofPragma}. In particular, when \\{ProofPragma} is
true, then Mizar will double check the proofs. When \\{ProofPragma} is
false, Mizar will skip the proofs.

@<pragmas.pas@>=
@<GNU License@>
unit pragmas;

interface

uses mobjects;

var
  @! VerifyPragmaOn,@!VerifyPragmaOff : NatSet;
  @! VerifyPragmaIntervals: NatFunc;
  @! SchemePragmaOn,@!SchemePragmaOff: NatSet;
  @! SchemePragmaIntervals : NatFunc;
  @! ProofPragma: Boolean = true; {check the proofs?} @#

procedure @? SetParserPragma(aPrg: string); @t\2@>
procedure @? InsertPragma(aLine: integer; aPrg: string); @t\2@>
procedure @? CompletePragmas(aLine: integer); @t\2@> @#

procedure @? CanceledPragma(@+const aPrg:string;@+ var aKind: char;@+ var aNbr: integer); @t\2@>

implementation @|@#

uses mizenv; @#


@ Cancelling a definition or theorem is handled with the
``\texttt{::\$C}'' pragma, which is administered only by the editors
of the MML.

@p
procedure CanceledPragma(@+const aPrg:string;@+ var aKind: char;@+ var aNbr: integer);
 var lStr: string;
     k,lCod: integer;
begin
 aKind:=' ';
 if (Copy(aPrg,1,2) = '$C') then
  begin
   if (length(aPrg) >= 3) and (aPrg[3] in ['D','S','T']) then
    begin
     aKind:=aPrg[3];
     lStr:=TrimString(Copy(aPrg,4,length(aPrg)-3));
     aNbr:=1;
     if length(lStr) > 0 then
      begin
       k:=1;
       while (k <= length(lStr)) and (lStr[k] in ['0'..'9']) do inc(k);
       delete(lStr,k,length(lStr));
       if length(lStr) > 0 then
        Val(lStr,aNbr,lCod);
      end;
    end;
  end;
end;

@ The ``\texttt{::\$P+}'' pragma instructs Mizar to start checking the
proofs for correctness. The ``\texttt{::\$P-}'' pragma instructs Mizar
to skip checking proofs.

\label{SetParserPragma}

@p
procedure SetParserPragma(aPrg: string);
begin
   if copy(aPrg,1,3)='$P+' then 
   begin
      ProofPragma:=true;
   end;
   if copy(aPrg,1,3)='$P-' then
   begin
      ProofPragma:=false;
   end;
end;

@ The ``\texttt{::\$S+}'' pragma will tell Mizar to check the scheme references,
whereas ``\texttt{::\$S-}'' pragma tells Mizar to stop verifying
scheme references.

The ``\texttt{::\$V+}'' pragma enables the verifier, and the
``\texttt{::\$V-}'' pragma disables the verifier (skipping all
verification until it is re-enabled). 

@p
procedure InsertPragma(aLine: integer; aPrg: string);
begin
   if copy(aPrg,1,3)='$V+' then
   begin
      VerifyPragmaOn.InsertElem(aLine); @+
   end;
   if copy(aPrg,1,3)='$V-' then
   begin
      VerifyPragmaOff.InsertElem(aLine); @+
   end;

   if copy(aPrg,1,3)='$S+' then
   begin
      SchemePragmaOn.InsertElem(aLine); @+
   end;
   if copy(aPrg,1,3)='$S-' then
   begin
      SchemePragmaOff.InsertElem(aLine); @+
   end;
end;

@ The \\{CompletePragmas} function will compute the intervals for
which the pragmas are ``active'', then check whether the given line
number falls within the ``active range''.

@p
procedure CompletePragmas(aLine: integer);
var i,j,a,b : integer; f:boolean;
begin
  for i:=0 to VerifyPragmaOff.Count-1 do
   begin
     f:=false;
     a:=VerifyPragmaOff.Items^[i].X;
     for j:=0 to VerifyPragmaOn.Count-1 do
      begin
       b:=VerifyPragmaOn.Items^[j].X;
       if b >= a then
        begin
         VerifyPragmaIntervals.Assign(a,b);
         f:=true;
         break; @+
        end;
      end;
     if not f then VerifyPragmaIntervals.Assign(a,aLine);
   end;
  for i:=0 to SchemePragmaOff.Count-1 do
   begin
     f:=false;
     a:=SchemePragmaOff.Items^[i].X;
     for j:=0 to SchemePragmaOn.Count-1 do
      begin
       b:=SchemePragmaOn.Items^[j].X;
       if b >= a then
        begin
         SchemePragmaIntervals.Assign(a,b);
         f:=true;
         break; @+
        end;
      end;
     if not f then SchemePragmaIntervals.Assign(a,aLine);
   end;
end;

@ Now we initialize the global variables declared in this module.

@p
begin

   VerifyPragmaOn.Init(10,10);
   VerifyPragmaOff.Init(10,10);
   VerifyPragmaIntervals.InitNatFunc(10,10);
   SchemePragmaOn.Init(10,10);
   SchemePragmaOff.Init(10,10);
   SchemePragmaIntervals.InitNatFunc(10,10);

end.


@* [F] Detour: Parser additions.
This chapter is a ``detour'' because we are ``going out of [compiler] order'' to
discuss \texttt{parseradditions.pas}. Why? Well, because the file provides
subclasses to those introduced in the abstract syntax unit, and are
necessary for understanding the \texttt{parser.pas} unit.

One of the difficulties with this file is that there are 37 global
variables declared here, and 46 module-wide variables, declared
here. It's hard to juggle that knowledge! These ``global'' variables
really describe the state of the parser, and do not seem to be used
anywhere else.

\Ithink{It would probably be wise to refactor the design to isolate
these variables inside a \texttt{Parser} class, so they are not
randomly distributed throughout this part of the program.}

C{\sc ONVENTIONS}:
The classes have methods prefixed by \\{Start}, \\{Process},
and \\{Finish}.
\bul The \\{Start} methods reset the state variables needed
to parse the syntactic entity.

\bul The \\{Process} methods usually update the state variables,
either allocating new objects or transferring the current contents of a
state variable in a different state variable.

\bul The \\{Finish} methods construct
a \WSM/ abstract syntax tree for the parsed entity.

@<parseraddition.pas@>=
@<GNU License@>
unit parseraddition; @#

interface @|@#


uses syntax, errhan, mobjects, mscanner, abstract_syntax, wsmarticle, xml_inout; @#

procedure InitWsMizarArticle; @t\2@> @#

type @|@/
@<Extended block class declaration@>@;
@<Extended item class declaration@>@;
@<Extended subexpression class declaration@>@;
@<Extended expression class declaration@>@; @#

   function @? GetIdentifier:integer; @t\2@>
   function @? CreateArgs(aBase:integer): PList; @t\2@> @#

var
@<Global variables introduced in \texttt{parseraddition.pas}@>@; @#

implementation @|@#
uses mizenv, mconsole, parser, _formats, pragmas
mdebug ,info @+ end_mdebug; @#

const
   MaxSubTermNbr   =   64;

var
   @<Local variables for parser additions@>@; @#

   @<Implementation of parser additions@> @t\2@>@;
end.

@ @<Implementation of parser additions@>=
@<Get the identifier number for current word@>@;

@<Initialize WS Mizar article@>;

@<Extended block implementation@>@;

@<Extended item implementation@>@;

@<Extended subexpression implementation@>@;

@<Extended expression implementation@>@;

@ When the current token is an identifier, we should obtain its
number. If the current token is not an identifier, we should return 0.

\label{GetIdentifier}

@<Get the identifier number for current word@>=
function GetIdentifier:integer;
begin
   result:=0;
   if CurWord.Kind = Identifier then result:=CurWord.Nr
end;

@ Initializing a weakly-strict Mizar article requires setting the
values for some of the global variables. Importantly, this will
initialize the \\{gBlockPtr} in the Parser to be an \\{extBlockObj}
instance. Note that this will create ``the'' |blMain| block object.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gWSTextProper: wsTextProperPtr;
  @! gLastWSBlock: WSBlockPtr;
  @! gLastWSItem: WSItemPtr;

@ @<Initialize WS Mizar article@>=
procedure InitWsMizarArticle;
begin {inintialize global variables which were declared
   in \texttt{parseraddition}}
   gWSTextProper:=new(wsTextProperPtr,Init(ArticleID,ArticleExt,CurPos));
   gLastWSBlock:=gWSTextProper;
   gLastWSItem:=nil; @/
   gBlockPtr:=new(extBlockPtr, Init(blMain)); {initialize other global variables}
end;

@* [S] Extended block class.
We extend the \\{Block} class (\section\xref{BlockObj:syntax.pas})
introduced in the \texttt{syntax.pas} unit. Also recall
the \\{wsBlock} class (\section\xref{wsTextProper:ast}) and
the \\{wsItem} class (\section\xref{TextItem:ast}).
\medbreak
\figure
\centerline{\graphics{img/classdiagram-4}}
\caption{Class hierarchy for \\{extBlockObj}, methods omitted.}
\endfigure
\medbreak\noindent%

@ @<Extended block class declaration@>=
   extBlockPtr = ^extBlockObj; @/
   extBlockObj = object(BlockObj) @t\1@> @/
      nLastWSItem: WSItemPtr;
      nLastWSBlock: WSBlockPtr; @#
      
      nLinked: Boolean; {is block prefixed by ``\texttt{then}''?}
      nLinkAllowed: Boolean; {isn't this a duplicate of next field?}
      nLinkProhibited: Boolean; {can statement kind be prefixed by ``\texttt{then}''?}
      nLinkPos:Position; @#
      
      nInDiffuse:boolean;
      nLastSentence: FormulaPtr; @#
      
      nHasAssumptions: Boolean; @#
      
      constructor Init(fBlockKind:BlockKind); @t\2@>
      procedure @? Pop; virtual; @t\2@>
      procedure @? StartProperText; virtual; @t\2@>
      procedure @? ProcessRedefine; virtual; @t\2@>
      procedure @? ProcessLink; virtual; @t\2@>
      procedure @? ProcessBegin; virtual; @t\2@>
      procedure @? ProcessPragma; virtual; @t\2@>
      procedure @? StartSchemeDemonstration; virtual; @t\2@>
      procedure @? FinishSchemeDemonstration; virtual; @t\2@>
      procedure @? CreateItem(fItemKind:ItemKind); virtual; @t\2@>
      procedure @? CreateBlock(fBlockKind:BlockKind); virtual; @t\2\2\2@>
   end;

@ \node{Constructor.}
The constructor for an extended block object invokes the parent
class's constructor (\section\xref{BlockObj.Init}), initializes the
instance variables, then its behaviour depends on whether we are
constructing a ``main'' block or not.

@<Extended block implementation@>=
constructor @? extBlockObj.Init(fBlockKind:BlockKind);
begin
   inherited Init(fBlockKind); @/
   @<Initialize default values for \\{extBlock} instance@>;
   if nBlockKind = blMain then
   @<Initialize \texttt{main} \\{extBlock} instance@>
   else
   @<Initialize ``proper text'' \\{extBlock} instance@>;
end;

@ We have the default values suppose links are prohibited for the
block, and there are no assumptions for the block. The last |wsItem|
and |wsBlock| pointers are set to the global |gLastWSItem| and
|gLastWSBlock| variables, respectively.

@<Initialize default values for \\{extBlock} instance@>=
   nLinked:=false;
   nLinkPos:=CurPos;
   nLinkAllowed:=false;
   nLinkProhibited:=true;
   nHasAssumptions:=false;
   gRedefinitions:=false; @#

   nLastWSItem:=gLastWSItem;
   nLastWSBlock:=gLastWSBlock;

@ The ``main'' block of text needs to load the formats file, and
populate the \\{gFormatsColl} (\section\xref{gFormatsColl}) and
the \\{gFormatsBase} (\emph{ibid}.) global
variables. The \texttt{parseraddition.pas} unit's \\{gProofCnt} global
variable is initialized to zero here.

@<Initialize \texttt{main} \\{extBlock} instance@>=
   begin
      nInDiffuse:=true;
      gProofCnt:=0; @/
      FileExam(EnvFileName+'.frm');
      gFormatsColl.LoadFormats(EnvFileName+'.frm');
      gFormatsBase:=gFormatsColl.Count;
      setlength(Term,MaxSubTermNbr);
   end

@ @<Local variables for parser additions@>=
  @! Term: array of TermPtr; {(\section\xref{uml-class-diagram-for-term-ast})}

@ @<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gProofCnt: integer;

@ The ``proper text'' branch updates the \\{gLastWSBlock} global
variable. For most of the kinds of blocks, we will have to
toggle \\{nInDiffuse} to be true or false. For proof blocks, we will
need to increment the ``depth'' counter tracking the proof block
``nestedness''.

Only the ``\texttt{case}'' and ``\texttt{suppose}'' blocks, when
determining if they are in ``diffuse mode'' or not, need to
confer with the previous block. (Recall (\section\xref{StackedObj}),
\\{StackedObj} classes has a \\{Previous} pointer.)

@<Initialize ``proper text'' \\{extBlock} instance@>=
   begin
      gLastWSBlock:=gWsTextProper^.NewBlock(nBlockKind,CurPos);
      mizassert(2341,gLastWSItem<>nil);
      if gLastWSItem^.nItemKind in [itDefinition,itRegularStatement,itSchemeBlock,
                                    itTheorem,itConclusion,itCaseBlock,itCorrCond,
                                    itCorrectness,itProperty,itPropertyRegistration] then
         wsItemPtr(gLastWSItem).nBlock:=gLastWSBlock;
      case nBlockKind of
         blDefinition: nInDiffuse:=false;
         blNotation: nInDiffuse:=false;
         blDiffuse: nInDiffuse:=true;
         blHereby: nInDiffuse:=true;
         blProof:
            begin
               nLastSentence:=gLastFormula;
               inc(gProofCnt); @+
            end;
         blCase: nInDiffuse:=extBlockPtr(Previous)^.nInDiffuse;
         blSuppose: nInDiffuse:=extBlockPtr(Previous)^.nInDiffuse;
         blRegistration: nInDiffuse:=false;
         blPublicScheme: nInDiffuse:=false;
      endcases;
   end

@ \node{Popping a block.} When we ``pop'' a proof block, we need to
track the formula that was just proven and store it in the global
variable \\{gLastFormula}.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gLastFormula: FormulaPtr;
   
@ This actually implements the \\{Pop} method for blocks. When a block
``closes'' (i.e., the corresponding ``\texttt{end}'' statement has
been encountered), we restore the global
state's \\{gLastWSItem} and \\{gLastWSBlock} pointers. When a proof
block closes, we also restore the \\{gLastFormula} state.

Also note: the parent class's method (\section\xref{BlockObj.Pop})
does nothing. This will be invoked in the \\{KillBlock}
(\section\xref{KillBlock}). 

@<Extended block implementation@>=
procedure @? extBlockObj.Pop;
begin
   gLastWSBlock^.nBlockEndPos:=CurPos;
   case nBlockKind of
      blProof:
         begin
            gLastFormula:=nLastSentence;
            dec(gProofCnt); @+
         end;
   endcases; @/
   gLastWSItem:=nLastWSItem;
   gLastWSBlock:=nLastWSBlock; {restore the ``last'' pointers}
   inherited Pop;
end;

@ \node{Process ``begin''.}
Mizar uses ``\texttt{begin}'' to start a new ``section'' at the
top-level of an article. Recall the grammar for this bit of Mizar:

\medbreak
{\obeylines\tt
Text-Proper = Section \LB\ Section \RB\ .

Section = "begin" \LB\ Text-Item \RB\ .
\par}
\medbreak\noindent%
There are zero or more Text-Items in a section.

We should note that the main text is not organized as a linked list of
``main'' blocks. Instead, we have a single ``main'' block, and we just
push an \\{itSection} item to its contents.

@! @:extBlockObj.ProcessBegin}{\\{extBlockObj.ProcessBegin}@>

\label{extBlockObj.ProcessBegin}
@<Extended block implementation@>=
procedure @? extBlockObj.@!ProcessBegin;
begin
   nLinkAllowed:=false;
   nLinkProhibited:=true;
   gLastWSItem:=gWsTextProper^.NewItem(itSection,CurPos);
   nLastWSItem:=gLastWSItem;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
end;

@ This will add a pragma item to the current block.
The parser's \\{ProcessPragmas} (\section\xref{ProcessPragmas:parser})
invokes this method.

\label{extBlockObj.ProcessPragma}

@<Extended block implementation@>=
procedure @? extBlockObj.@!ProcessPragma;
begin
   nLinkAllowed:=false;
   nLinkProhibited:=true; @/
   {Create a new item}
   gLastWSItem:=gWsTextProper^.NewItem(itPragma,CurPos);
   gLastWSItem^.nContent:=new(PragmaPtr,Init(CurWord.Spelling)); @/
   {Insert the pragma, update last item in block}
   nLastWSItem:=gLastWSItem;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
end;

@ Starting the proper text will just update the \\{nBlockPos} field to
whatever the current position is.
\label{extBlockObj.StartProperText}

@<Extended block implementation@>=
procedure @? extBlockObj.StartProperText;
begin
   gWSTextProper^.nBlockPos:=CurPos; @+
end;

@ Processing redefinitions sets the global variable \\{gRedefinitions}
to the result of comparing the current word to the
``\texttt{redefine}'' keyword.

@<Extended block implementation@>=
procedure @? extBlockObj.@!ProcessRedefine;
begin
   gRedefinitions:=CurWord.Kind = sy_Redefine; @+
end;

@ When a block statement is linked, but it should not, then we raise
a \texttt{164} error. Otherwise, be sure to mark the block as linked
(i.e., toggle \\{nLinked} to be true) and assign the \\{nLinkPos} to
be the current position.

@<Extended block implementation@>=
procedure @? extBlockObj.@!ProcessLink;
begin
   if CurWord.Kind in [sy_Then,sy_Hence] then
   begin
      if nLinkProhibited then ErrImm(164);
      nLinked:=true;
      nLinkPos:=CurPos;
   end;
end;

@ \node{Proof of a scheme.} We should increment the proof depth global
variable. 

Recall that \\{ProofPragma} means ``check the proof is valid?'' In
other words, when \\{ProofPragma} is false, we are skipping the
proofs.

\section{thesis-formula:macro-def}

@d thesis_formula == new(ThesisFormulaPtr,Init(CurPos))
@d thesis_prop == new(PropositionPtr,
                      Init(new(LabelPtr,Init(0,CurPos)),
                           thesis_formula,CurPos))
@d skipped_proof_justification ==  new(JustificationPtr,Init(infSkippedProof,CurPos))

@<Extended block implementation@>=
procedure @? extBlockObj.@!StartSchemeDemonstration;
begin
   inc(gProofCnt);
   if not ProofPragma then
   @<Mark schema proof as ``skipped''@>;
end;

@ When we skip the proof (due to pragmas being set), we just add the
scheme as a compact statement whose justification is the ``skipped
proof justification''.

First, we create a new text item for the proper text global variable. Then
we set its content to the compact statement with the ``skipped''
justification. Finally we add this item to the ``last''
(latest) \\{wsBlock} global variable.

@<Mark schema proof as ``skipped''@>=
   begin
      gLastWSItem:=gWsTextProper^.NewItem(itConclusion,CurPos);
      gLastWSItem^.nContent:=
         new(CompactStatementPtr,
             Init(thesis_prop,
                  skipped_proof_justification));@/
      gLastWSBlock^.nItems.Insert(gLastWSItem);
   end

@ Finishing the proof for a scheme should decrement the global ``proof depth''
counter.

@<Extended block implementation@>=
procedure @? extBlockObj.@!FinishSchemeDemonstration;
begin
   dec(gProofCnt); @+
end;

@ The factory method for \\{extBlock} creating an item will update the
global \\{gItemPtr} variable (\section\xref{gSubexpPtr}).

@<Extended block implementation@>=
procedure @? extBlockObj.@!CreateItem(fItemKind:ItemKind);
begin
   gItemPtr:=new(extItemPtr, Init(fItemKind)); @+
end;

@ The factory method for \\{extBlock} creating a new block will update
the \\{gBlockPtr} global variable (\section\xref{gSubexpPtr}).

@<Extended block implementation@>=
procedure @? extBlockObj.@!CreateBlock(fBlockKind:BlockKind);
begin
   gBlockPtr:=new(extBlockPtr,Init(fBlockKind)) @+
end;

@* [S] Extended item class.
The class diagram for extended items looks like:
\medbreak
\figure
\centerline{\graphics{img/classdiagram-5}}
\caption{Class hierarchy for \\{extItemObj}. The base \\{MObject} class omitted from the hierarchy.}
\endfigure
\medbreak\noindent%
Recall (\section\xref{RegularStatementKind}) the regular statement
kind is one of three possibilities: diffuse statement, compact
statement, iterative equality.

The ``Finish'' methods updates the contents of the \\{extItem} class
with a \WSM/ abstract syntax tree for the statement.

Since this is a ``stub'', I will just leave the placeholder chunk for
the methods overriden by the extended Item class here (remove later).

@<Methods overriden by extended Item class@>=

@ @<Extended item class declaration@>=
  @! extItemPtr = ^extItemObj; @/
  @! extItemObj = object(ItemObj) @t\1@> @/

     @! nItemPos:Position;
     @! nLastWSItem: WSItemPtr; @#

     @! nLabelIdNr: integer;
     @! nLabelIdPos:Position;
     @! nLabel: LabelPtr; @#

     @! nPropPos: Position; @#

     @! nInference: JustificationPtr; @/
     @! nLinkable: boolean; @#

     @! nRegularStatementKind: RegularStatementKind; @#

     @! nItAllowed: boolean; @#

      constructor @? Init(fKind:ItemKind); @t\2@>
      procedure @? Pop; virtual; @t\2@> @#

@t\4@>  @<Methods overriden by extended Item class@> @t\2\2@> @;

   end;

@* [s] Constructor.
There are a number of comments in Polish which I haphazardly
translated into English (``Przygotowanie definiensow:'' translates as
``Preparation of definiens:''; ``Ew.\ zakaz przy obiektach ekspandowanych''
translates as ``Possible ban on expanded facilities'')

@<Extended item implementation@>=
constructor @? extItemObj.Init(fKind:ItemKind);
begin
   inherited Init(fKind); @/
   @<Initialize the fields for newly allocated \\{extItem} object@>@;
   mizassert(2343,gLastWSBlock<>nil);
   if not (nItemKind in [itReservation,itConstantDefinition,itExemplification,
                         itGeneralization,itLociDeclaration]) then
   begin
      gLastWSItem:=gWsTextProper^.NewItem(fKind,CurPos);
      nLastWSItem:=gLastWSItem;
   end;
   case nItemKind of
      @<Initialize extended item by \\{ItemKind}@>@;
   endcases;
   if not (nItemKind in [itReservation,itConstantDefinition,itExemplification,
                         itGeneralization,itLociDeclaration]) then
      gLastWSBlock^.nItems.Insert(gLastWSItem);
end;

@ \node{Initializing the fields.}
The |it_Allowed| global variable is toggled on and off when the
parser encounters ``guards'' in conditional definitions, whereas the
|nItAllowed| fields reflects whether the sort of definition allows
``\texttt{it}'' in the definiens.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! dol_Allowed: Boolean;
  @! it_Allowed: Boolean;
  @! in_AggrPattern: Boolean; @#

  @! gLastType: TypePtr;
  @! gLastTerm: TermPtr;
  @! gDefiningWay: HowToDefine;

@ @<Local variables for parser additions@>=
  @! gClusterSort: ClusterRegistrationKind;
  @! gDefiniens: DefiniensPtr;
  @! gPartialDefs: PList;
  @! nDefiniensProhibited: boolean;
  @! gSpecification: TypePtr;

@ @<Initialize the fields for newly allocated \\{extItem} object@>=
   nItemPos:=CurPos;
   gClusterSort:=ExistentialRegistration;
   nItAllowed:=false;
   it_Allowed:=false; {global variable!}
   in_AggrPattern:=false;
   dol_Allowed:=false;
   gSpecification:=nil;
   gLastType:=nil;
   gLastFormula:=nil;
   gLastTerm:=nil; @/
   { Preparation of definiens: }
   nDefiniensProhibited:=false; @/
   { Possible ban on expanded facilities }
   gDefiningWay:=dfEmpty;
   gDefiniens:=nil;
   gPartialDefs:=nil;
   nLinkable:=false;

@ \node{Kind-specific initialization.} Each kind of item may need some
specific initialization. We work through all the cases. The first two
cases considered are generalization (``\texttt{let} $\langle$\textit{Qualified Variables}$\,\rangle$
\texttt{be} [\texttt{such} $\langle$\textit{Conditions}$\,\rangle$]'')
and existential assumptions (``\texttt{given}
$\langle$\textit{Qualified Variables}$\,\rangle$
\texttt{such}
$\langle\,$\textit{Conditions}$\,\rangle$''). Existential assumptions
need to toggle the ``has assumptions'' field to true for the global
block pointer.

@<Initialize extended item by \\{ItemKind}@>=
      itGeneralization: ; {\texttt{let} statements}
      itExistentialAssumption: ExtBlockPtr(gBlockPtr)^.nHasAssumptions:=true;

@ \node{Property initialization.}
Initializing a property statement \\{Item} should raise an error
when the property does not appear in the correct block.

\bul Defining a predicate can support the following properties:
symmetry, reflectivity, irreflexivity, transitivity, conectedness, asymmetry.
\bul Functors can support: associativity, commutativity, idempotence,
involutiveness, and projectivity properties. 
\bul Modes can support the sethood property.

\medbreak
In all other situations, an error should be flagged (the user is
trying to assert an invalid property).

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gDefKind: ItemKind;

@ @<Local variables for parser additions@>=
  @! gExpandable:boolean;
  @! gPropertySort: PropertyKind;
  
@ @<Initialize extended item by \\{ItemKind}@>=
      itProperty:
         begin
            gPropertySort:=PropertyKind(CurWord.Nr);
            case PropertyKind(CurWord.Nr) of
               sySymmetry,syReflexivity,syIrreflexivity,syTransitivity,syConnectedness,syAsymmetry:@|@/
                  if gDefKind<>itDefPred then begin ErrImm(81); gPropertySort:=sErrProperty;@+ end;
               syAssociativity,syCommutativity,syIdempotence:
                  if gDefKind<>itDefFunc then begin ErrImm(82); gPropertySort:=sErrProperty;@+ end;
               syInvolutiveness,syProjectivity:
                  if gDefKind<>itDefFunc then begin ErrImm(83); gPropertySort:=sErrProperty;@+ end;
               sySethood:
                  if (gDefKind<>itDefMode) or gExpandable then begin ErrImm(86); gPropertySort:=sErrProperty;@+ end;
            endcases;
         end;

@ \node{Reconsider initialization.} We need to allocate a new (empty)
list for the list of terms being reconsidered.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gReconsiderList: PList;

@ @<Initialize extended item by \\{ItemKind}@>=
      itReconsider:
         gReconsiderList:=new(PList,Init(0));

@ We can have in Mizar ``\texttt{suppose that}
$\langle\textit{statement\/}\rangle$'' (as well as ``\texttt{case that}\dots'').
But in those cases, the statement cannot be linked to the next
statement (i.e., the next statement cannot begin with ``\texttt{then}\dots'').
Assumptions without ``\texttt{that}'' are always linkable.r

Theorems, ``regular statements'', and conclusions are always linkable.

@ @<Initialize extended item by \\{ItemKind}@>=
      itRegularStatement: nLinkable:=true;
      itConclusion:
         nLinkable:=true;
      itPerCases: ;
      itCaseHead:
         if AheadWord.Kind <> sy_That then nLinkable:=true;
      itSupposeHead:
         if AheadWord.Kind <> sy_That then nLinkable:=true;
      itTheorem:
         nLinkable:=true;
      itAxiom:
         if not AxiomsAllowed then ErrImm(66);
      itChoice: ;

@ \node{Initializing an assumption.} Collective assumptions
(``\texttt{assume that} $\langle$\textit{formula}$\rangle$'') are not
linkable, but
single assumptions (``\texttt{assume} $\langle$\textit{Proposition}$\rangle$'')
are linkable. The statement will introduce a list of premises, which
will be tracked in the \\{gPremises} local variable for the module.

@<Local variables for parser additions@>=
  @! gPremises: PList;

@ @<Initialize extended item by \\{ItemKind}@>=
      itAssumption:
         begin
            if AheadWord.Kind <> sy_That then nLinkable:=true;
            gPremises:=nil;
         end;


@ \node{Definition items.}
Definition items need to be initialized with some nuance. Some
definitions permit ``\texttt{it}'' to be used in the definiens, but
others do not. Mizar toggles the global variables tracking this
here. There is a common set of things toggled which we have isolated
as the \WEB/ macro |initialize_definition_item| common to initializing
all definition items.

The correctness conditions are determined at this point, as well.

@d initialize_definition_item == 
            gCorrectnessConditions:=[];
            gDefPos:=CurPos;
            gDefKind:=nItemKind

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gCorrectnessConditions : CorrectnessConditionsSet;

@ @<Local variables for parser additions@>=
  @! gDefPos: Position;
  @! gStructPrefixes: PList;

@ @<Initialize extended item by \\{ItemKind}@>=
      itLociDeclaration: ;
      itDefMode:
         begin
            nItAllowed:=true;
            gExpandable:=false;
            initialize_definition_item @+
         end;
      itDefAttr:
         begin
            initialize_definition_item @+
         end;
      itAttrSynonym:
         begin
            initialize_definition_item @+
         end;
      itAttrAntonym:
         begin
            initialize_definition_item @+
         end;
      itModeNotation:
         begin
            initialize_definition_item @+
         end;
      itDefFunc:
         begin
            nItAllowed:=true;
            initialize_definition_item @+
         end;
      itFuncNotation:
         begin
             initialize_definition_item; @+
         end;
      itDefPred,
      itPredSynonym,
      itCluster,
      itIdentify,
      itReduction: @|@/
         begin  initialize_definition_item; @+
         end;
      itPropertyRegistration:
         begin
            initialize_definition_item;
            gPropertySort:=PropertyKind(CurWord.Nr);
         end;
      itDefStruct:
         begin
            initialize_definition_item;
            gStructPrefixes:=new(PList,Init(0)); @+
         end;
      itCanceled:
         begin
            ErrImm(88); @+
         end;

@ \node{Correctness conditions.} Registrations and definitions need
correctness conditions to ensure the well-definedness of adjective
clusters and terms. The correctness conditions needed for a definition
(or registration) are inserted into
the \\{gCorrectnessConditions} variable. When the correctness
condition is found, we remove it from the \\{gCorrectnessConditions} set.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gRedefinitions: boolean;

@ @<Local variables for parser additions@>=
  @! gCorrCondSort: CorrectnessKind;

@<Initialize extended item by \\{ItemKind}@>=
      itCorrCond:
         if CorrectnessKind(CurWord.Nr) in gCorrectnessConditions then
         begin
            exclude(gCorrectnessConditions,CorrectnessKind(CurWord.Nr));
            gCorrCondSort:=CorrectnessKind(CurWord.Nr);
            if (gRedefinitions and (gCorrCondSort=syCoherence) and ExtBlockPtr(gBlockPtr)^.nHasAssumptions) then ErrImm(243);
         end
         else
         begin
            ErrImm(72);
            gCorrCondSort:=CorrectnessKind(0); @+
         end;
      itCorrectness: if (gRedefinitions and ExtBlockPtr(gBlockPtr)^.nHasAssumptions) then ErrImm(243);

@ The last statement needing attention will be the \texttt{scheme}
block. Note that \\{gLocalScheme} is not used anywhere.

@<Local variables for parser additions@>=
  @! gLocalScheme: boolean;
  @! gSchemePos: Position;

@ @<Initialize extended item by \\{ItemKind}@>=
      itDefinition, itSchemeHead, itReservation,
      itPrivFuncDefinition, itPrivPredDefinition,
      itConstantDefinition, itExemplification:;
      itCaseBlock:;
      itSchemeBlock:
         begin
            gLocalScheme:=CurWord.Kind <> sy_Scheme;
            gSchemePos:=CurPos; @+
         end;


@ \node{Popping an extended item.}

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gSchemeParams: PList;

@ @<Local variables for parser additions@>=
  @! gPatternPos: Position;
  @! gPattern: PatternPtr;
  @! gNewPatternPos: Position;
  @! gNewPattern: PatternPtr;

  @! gSchemeIdNr: integer;
  @! gSchemeIdPos: Position;
  @! gSchemeConclusion: FormulaPtr;
  @! gSchemePremises: PList;

@* [s] Popping.
Popping an item is invoked as part of \\{KillItem}, which occurs
whenever (1) a semicolon is encountered, 
or (2) when starting a proof environment.

The contract for popping an item ensures the \\{nContent} field shall
be populated for valid items.

N{\sc OTE}: \PASCAL/ has a set operation $\\{include} (\\{set},\\{element})$
which adjoins an \\{element} to a \\{set}.

@<Extended item implementation@>=
procedure @? extItemObj.Pop;
var k:integer;
begin
   gLastWSItem^.nItemEndPos:=PrevPos; 
   @<Check for errors with definition items@>@;
   @<Update content of |nLastWSItem| based on type of item popped@>; @/
   @<Check the popped item's linkages are valid@>;
   if gDefiningWay <> dfEmpty then
   begin
      if gDefiniens^.nDefSort = ConditionalDefiniens then
         include(gCorrectnessConditions,syConsistency);
      if gRedefinitions then
         include(gCorrectnessConditions,syCompatibility);
   end;
   inherited Pop; {(\section\xref{ItemObj.Pop})}
end;

@ We will update the caller's \\{nLastWSItem}'s contents in most cases.

@<Update content of |nLastWSItem| based on type of item popped@>=
   case nItemKind of
      itTheorem:
         nLastWSItem^.nContent:=
         new(CompactStatementPtr,
             Init(new(PropositionPtr,Init(nLabel,
                                          gLastFormula,nPropPos)),
                  nInference)); @#
@t\4@>      @<Pop a proof step@>@; @#
      itConclusion,
      itRegularStatement:
      @<Pop a conclusion or regular statement@>@;
      itGeneralization,
      itLociDeclaration:
      @<Pop a ``\texttt{let}'' statement@>@; @#
@t\4@>      @<Pop a definition item@>@;@#
      itPredSynonym, itPredAntonym, itFuncNotation, itModeNotation,
      itAttrSynonym, itAttrAntonym:
         nLastWSItem^.nContent:=
                        new(NotationDeclarationPtr,
                            Init(gNewPatternPos,nItemKind,gNewPattern,gPattern));@#
@t\4@>      @<Pop a registration item@>@;@#
      itCorrCond:
         nLastWSItem^.nContent:=new(CorrectnessConditionPtr,
                                    Init(nItemPos,gCorrCondSort,nInference));
      itCorrectness:
         nLastWSItem^.nContent:=new(CorrectnessConditionsPtr,
                                    Init(nItemPos,gCorrectnessConditions,nInference));
      itProperty:
         nLastWSItem^.nContent:=new(PropertyPtr,Init(nItemPos,gPropertySort,nInference));
      itSchemeHead:
         nLastWSItem^.nContent:=
         new(SchemePtr,Init(gSchemeIdNr,gSchemeIdPos,gSchemeParams,gSchemePremises,gSchemeConclusion));@#
@t\4@>      @<Pop \&{skip}s remaining cases@>@;
   endcases

@ @<Pop \&{skip}s remaining cases@>=
      itPrivFuncDefinition,
      itPrivPredDefinition,
      itPragma,
      itDefinition,
      itSchemeBlock,
      itReservation,
      itExemplification,
      itCaseBlock:;

@ \node{Check for errors.} We need to flag a 253 or 254 error when the user
tries to introduce an axiom (which shouldn't occur much anymore, since
axioms are not even documented anywhere).

@<Local variables for parser additions@>=
  @! gMeansPos: Position;

@ @<Check for errors with definition items@>=
   case nItemKind of
      itDefPred, itDefFunc, itDefMode, itDefAttr:
         begin
            if gDefiningWay <> dfEmpty then
            begin
               if nDefiniensProhibited and not AxiomsAllowed then
               begin
                  Error(gMeansPos,254);
                  gDefiningWay:=dfEmpty; @+
               end;
            end
            else if not gRedefinitions and not nDefiniensProhibited and not AxiomsAllowed then
               SemErr(253);
         end;
   endcases;

@ \node{Pop a proof step.} Popping a proof step should assign to the
contents of the caller's \\{nLastWsItem} some kind of inference justification,
usually in the form of a statement in the \WSM/ syntax tree.

@<Pop a proof step@>=
      itPerCases:
         nLastWSItem^.nContent:=nInference;

@ \node{Popping a reconsideration.} We should assign
a \\{TypeChangingStatement} to the content of the caller's last item, using
the \\{nInference} field of the caller as the justification.

@<Pop a proof step@>=
      itReconsider:
         nLastWSItem^.nContent:=
         new(TypeChangingStatementPtr,
             Init(gReconsiderList,gLastType,SimpleJustificationPtr(nInference)));

@ \node{Popping existential elimination and introduction.} We assign
a \texttt{consider} (or \texttt{given}) \WSM/ statement to the
caller's previous \\{WSItem}'s contents when popping a
choice (resp., existential assumption) item.

We should remind the reader of the grammar here:

\smallbreak
{\advance\leftskip3pc\parindent=0pt
$\langle$\textit{Qualified-Segment\/}$\rangle$ $::=$ $\langle$\textit{Variables\/}$\rangle$ $\langle$\textit{Qualification\/}$\rangle$

$\langle$\textit{Variables\/}$\rangle$ $::=$ $\langle$\textit{Variable\/}$\rangle$ $\LB$ \texttt{","} $\langle$\textit{Variable\/}$\rangle$ $\RB$

$\langle$\textit{Qualification\/}$\rangle$ $::=$
(\texttt{"being"} \pipe\ \texttt{"be"}) $\langle$\textit{Type-Expression\/}$\rangle$
\par}
\smallbreak\noindent%
And, of course, a qualified-segment list is just a comma-separated
list of qualified-segments.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gQualifiedSegmentList: PList;

@ @<Pop a proof step@>=
      itChoice:
         begin
            nLastWSItem^.nContent:=
               new(ChoiceStatementPtr,
                   Init(gQualifiedSegmentList,gPremises,SimpleJustificationPtr(nInference)));
            gPremises:=nil;
         end;
      itExistentialAssumption:
         begin
            nLastWSItem^.nContent:=
               new(ExistentialAssumptionPtr,
                   Init(nItemPos,gQualifiedSegmentList,gPremises));
            gPremises:=nil;
         end;

@ \node{Popping a stipulation.} When we pop
a \texttt{case}, \texttt{suppose}, or \texttt{assume} --- some kind of
``assumption''-like statement --- we are assigning
either a \\{CollectiveAssumption} object or a \\{SingleAssumption}
object to the content of the \emph{current} \\{WSItem} \textbf{global}
variable.

@<Local variables for parser additions@>=
  @! gThatPos: Position;

@ @<Pop a proof step@>=
      itSupposeHead,itCaseHead,
      itAssumption:
         if gPremises <> nil then
         begin
            gLastWSItem^.nContent:=new(CollectiveAssumptionPtr,Init(gThatPos,gPremises));
            gPremises:=nil;
         end
         else
            gLastWSItem^.nContent:=
               new(SingleAssumptionPtr,Init(nItemPos,
                                            new(PropositionPtr,Init(nLabel,
                                                                    gLastFormula,nPropPos))));

@ \node{Pop a conclusion or regular statement.} We assign an
appropriate \WSM/ statement node to the previous item's contents.

@<Local variables for parser additions@>=
  @! gIterativeSteps: PList;
  @! gIterativeLastFormula: FormulaPtr;
  @! gInference: JustificationPtr;

@ @<Pop a conclusion or regular statement@>=
         case nRegularStatementKind of
            stDiffuseStatement:
               nLastWSItem^.nContent:=
               new(DiffuseStatementPtr,Init(nLabel,
                                            stDiffuseStatement));
            stCompactStatement:
               nLastWSItem^.nContent:=
               new(CompactStatementPtr,
                   Init(new(PropositionPtr,Init(nLabel,
                                                gLastFormula,nPropPos)),
                        nInference));
            stIterativeEquality:
               nLastWSItem^.nContent:=
               new(IterativeEqualityPtr,
                   Init(new(PropositionPtr,Init(nLabel,
                                                gIterativeLastFormula,nPropPos)),
                        gInference,gIterativeSteps));
         endcases;

@ \node{Pop a `let' statement.} For generic let statements of the form
$$\texttt{let}~\vec{x}_{1}~\texttt{be}~T_{1},\dots,\vec{x}_{n}~\texttt{be}~T_{n}$$
we transform it to $n$ statements of the form ``\texttt{let}
$\vec{x}$ \texttt{be} $T$'', then add these to the \\{gLastWSBlock}'s
items. When we have
$$\texttt{let}~\vec{x}~\texttt{be}~T~\hbox{\texttt{such that}}~\Phi$$
we need to  add a \\{CollectiveAssumption} node to
the \textbf{global} \\{gLastWSBlock}'s items.

\label{pop-let-statement}

@<Local variables for parser additions@>=
  @! gSuchPos: Position;
  
@ @<Pop a ``\texttt{let}'' statement@>=
         begin
            for k := 0 to gQualifiedSegmentList^.Count-1 do
            begin
               gLastWSItem:=gWsTextProper^.NewItem(nItemKind,
                                                   QualifiedSegmentPtr(gQualifiedSegmentList^.Items^[k])^.nSegmPos);
               nLastWSItem:=gLastWSItem;
               gLastWSItem^.nContent:=gQualifiedSegmentList^.Items^[k];
               if k = gQualifiedSegmentList^.Count-1 then
                  gLastWSItem^.nItemEndPos:=PrevPos
               else
                  gLastWSItem^.nItemEndPos:=QualifiedSegmentPtr(gQualifiedSegmentList^.Items^[k+1])^.nSegmPos;
               gQualifiedSegmentList^.Items^[k]:=nil;
               gLastWSBlock^.nItems.Insert(gLastWSItem);
            end;
            dispose(gQualifiedSegmentList,Done);
            if gPremises <> nil then
            begin
               gLastWSItem:=gWsTextProper^.NewItem(itAssumption,gSuchPos);
               gLastWSItem^.nContent:=new(CollectiveAssumptionPtr,Init(gThatPos,gPremises));
               gPremises:=nil;
               gLastWSItem^.nItemEndPos:=PrevPos;
               nLastWSItem:=gLastWSItem;
               gLastWSBlock^.nItems.Insert(gLastWSItem);
            end;
         end;

@ \node{Pop a mode definition.} A mode is either expandable (an
abbreviation) or nonexpandable. For expandable modes, we just add a
new \\{ExpandableModeDefinition} \WSM/ object to the
caller's \\{nLastWSItem}'s contents.

On the other hand, non-expandable modes should add to the
caller's \\{nLastWSItem}'s contents a new \\{StandardModeDefinition}
object. If this is not a redefinition, then we must add the
``\texttt{existence}'' correctness condition to the global
variable \\{gCorrectnessConditions}. 

@<Pop a definition item@>=
      itDefMode:
         begin
            if gExpandable  then
               nLastWSItem^.nContent:=
                  new(ExpandableModeDefinitionPtr,
                      Init(gPatternPos,ModePatternPtr(gPattern),gLastType))
            else
            begin
               nLastWSItem^.nContent:=
                  new(StandardModeDefinitionPtr,
                      Init(gPatternPos,gRedefinitions,ModePatternPtr(gPattern),
                           gSpecification,gDefiniens));
               if not gRedefinitions then
                  include(gCorrectnessConditions,syExistence);
            end;
         end;

@ \node{Pop a functor definition.} When popping a functor definition,
we just add a \\{FunctorDefinition} object to the
caller's \\{nLastWSItem}'s contents.

@<Pop a definition item@>=
      itDefFunc:
         begin
            nLastWSItem^.nContent:=
               new(FunctorDefinitionPtr,
                   Init(gPatternPos,gRedefinitions,FunctorPatternPtr(gPattern),
                        gSpecification,gDefiningWay,gDefiniens));

         end;

@ \node{Pop an attribute definition.} We just need to add
an \\{AttributeDefinition} object to the caller's \\{nLastWSItem}'s
contents.

@<Pop a definition item@>=
      itDefAttr:
         begin
            nLastWSItem^.nContent:=
               new(AttributeDefinitionPtr,
                   Init(gPatternPos,gRedefinitions,AttributePatternPtr(gPattern),gDefiniens));
         end;

@  \node{Pop a predicate definition.} We just need to add
a \\{PredicateDefinition} object to the caller's \\{nLastWSItem}'s
contents.

@<Pop a definition item@>=
      itDefPred:
         begin
            nLastWSItem^.nContent:=
               new(PredicateDefinitionPtr,
                   Init(gPatternPos,gRedefinitions,PredicatePatternPtr(gPattern),gDefiniens));
         end;

@ \node{Popping a structure definition.} We just need to add
a \\{StructureDefinition} object to the caller's \\{nLastWSItem}'s
contents.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gConstructorNr: integer;

@ @<Local variables for parser additions@>=
  @! gParams: PList;
  @! gStructFields: PList;

@ @<Pop a definition item@>=
      itDefStruct:
         begin
            nLastWSItem^.nContent:=
               new(StructureDefinitionPtr,
                   Init(gPatternPos,gStructPrefixes,gConstructorNr,gParams,gStructFields));
         end;

@ \node{Pop a cluster registration item.} A ``cluster'' registration
(i.e., a existential, conditional, or functor registration) adds to
the caller's \\{nLastWSItem}'s contents a new cluster object (of
appropriate kind). The \\{gClusterSort} is populated when the parser
finishes a cluster registration when
invoking \\{extItemObj.FinishAntecedent}
(\section\xref{extItemObj.FinishAntecedent}) or similar methods.

The \\{gClusterTerm} is populated in
the \\{extItemObj.FinishClusterTerm} method
(\section\xref{extItemObj.FinishClusterTerm}). 

@<Local variables for parser additions@>=
  @! gAntecedent,gConsequent: PList;
  @! gClusterTerm: TermPtr;

@ @<Pop a registration item@>=
      itCluster:
         begin
            case gClusterSort of
               ExistentialRegistration:
                  begin
                     nLastWSItem^.nContent:=new(EClusterPtr,Init(nItemPos,gConsequent,gLastType));
                     include(gCorrectnessConditions,syExistence)
                  end;
               ConditionalRegistration:
                  begin
                     nLastWSItem^.nContent:=
                        new(CClusterPtr,Init(nItemPos,gAntecedent,gConsequent,gLastType));
                     include(gCorrectnessConditions,syCoherence);
                  end;
               FunctorialRegistration:
                  begin
                     nLastWSItem^.nContent:=
                        new(FClusterPtr,Init(nItemPos,gClusterTerm,gConsequent,gLastType));
                     include(gCorrectnessConditions,syCoherence);
                  end;
            endcases;
         end;

@ \node{Pop a registration item.} For an \texttt{identify}
or \texttt{reduce} registration, we assign the content of the
caller's \\{nLastWSItem} a new \\{IdentifyRegistration}
(resp., \\{ReduceRegistration}) object. Identify registrations use
the \\{gIdentifyEqLociList} local variable, while the reduction
registrations use the \\{gLeftTermInReduction} module-wide variable.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gLeftTermInReduction: TermPtr;

@ @<Local variables for parser additions@>=
  @! gIdentifyEqLociList: PList;

@ @<Pop a registration item@>=
      itIdentify:
         begin
            nLastWSItem^.nContent:=
               new(IdentifyRegistrationPtr,Init(nItemPos,gNewPattern,gPattern,gIdentifyEqLociList));
            include(gCorrectnessConditions,syCompatibility);
         end;
      itReduction:
         begin
            nLastWSItem^.nContent:=
               new(ReduceRegistrationPtr,Init(nItemPos,gLeftTermInReduction,gLastTerm));
            include(gCorrectnessConditions,syReducibility);
         end;
      itPropertyRegistration:
         SethoodRegistrationPtr(nLastWSItem^.nContent)^.nJustification:=nInference;


@ \node{Check linkages are valid.} When popping an item, we should
check if the block containing the caller is \\{nLinked}. If so, flag a
``178'' error and assign |nLinked := false|. Update the block's
|nLinkAllowed| depending on the caller's |nLinkable| field. But if the
parser is in panic mode, the containing block's |nLinkAllowed| and
|nLinkProhibited| are both assigned to false. \Ithink{This
configuration appears to encode a particular state which feels a bit
of a ``kludge'' to me\dots}

@^Error, 178@>

@<Check the popped item's linkages are valid@>=
   with extBlockPtr(gBlockPtr)^ do
   begin
      if nLinked then
      begin
         Error(nLinkPos,178);
         nLinked:=false @+
      end;
      nLinkAllowed:=nLinkable;
      nLinkProhibited:=not nLinkable;
      if not StillCorrect then
      begin
         nLinkAllowed:=false;
         nLinkProhibited:=false @+
      end;
   end

@* [s] Registrations and notations.
\node{Processing synonyms.} We need to update the \\{gNewPatternPos}
and \\{gNewPattern} global variables when processing a synonym.

@d process_notation_item ==
   gNewPatternPos:=gPatternPos;
   gNewPattern:=gPattern

@<Extended item implementation@>=
procedure @? extItemObj.ProcessModeSynonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessAttrSynonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessAttrAntonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessPredSynonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessPredAntonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessFuncSynonym;
begin process_notation_item; @+
end; @#

@ \node{Starting attributes.} This is used when the parser encounters
a cluster registration
(\section\xref{RegisterCluster:parser.pas}). The \\{gAttrColl} is
populated in the \\{extSubexpObj.CompleteAdjectiveCluster}
(\section\xref{extSubexpObj.CompleteAdjectiveCluster}) method.

\label{extItemObj.StartAttributes}

@<Local variables for parser additions@>=
  @! gAttrColl: PList;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartAttributes;
begin
   gAttrColl:=new(PList,Init(6));
end;

@ \node{Starting a sentence.} We just need to populate the
caller's \\{nPropPos}, assigning to it the current position of the
parser.

\label{extItemObj.StartSentence}

@<Extended item implementation@>=
procedure @? extItemObj.StartSentence;
begin
   nPropPos:=CurPos;
end;

@ \node{Processing conditional registration.} This populates
the \\{gClusterSort} and the related global variables, as the parser
finishes parsing the antecedent and consequent to the cluster.

\label{extItemObj.FinishAntecedent}

@<Extended item implementation@>=
procedure @? extItemObj.FinishAntecedent;
begin
   gClusterSort:=ConditionalRegistration;
   gAntecedent:=gAttrColl;
end; @#

procedure @? extItemObj.FinishConsequent;
begin
   gConsequent:=gAttrColl;
end;

@ \node{Finishing a cluster.} This populates the \\{gClusterSort} and
the \\{gClusterTerm}.

\label{extItemObj.FinishClusterTerm}

@<Extended item implementation@>=
procedure @? extItemObj.FinishClusterTerm;
begin
   gClusterSort:=FunctorialRegistration;
   gClusterTerm:=gLastTerm;
end;

@ \node{Identify registration.} Schematically, we have the
registration statement look like (using global variable names for the
subexpressions): 
$$\texttt{identify}~\langle\textit{gNewPattern\/}\rangle~\texttt{with}~\langle\textit{gPattern}\rangle~[\texttt{when}~\langle\textit{gIdentifyEqLociList\/}\rangle]\texttt{;}$$
We store the first pattern in the \\{gNewPattern} global variable,
then the second pattern in the \\{gPattern} global
variable. Completing the identify registration will check if the
current word is ``\texttt{when}'' and, if so, start a list of loci equalities.

@<Extended item implementation@>=
procedure @? extItemObj.StartFuncIdentify;
begin
end; @#

procedure @? extItemObj.ProcessFuncIdentify;
begin
   gNewPatternPos:=gPatternPos;
   gNewPattern:=gPattern;
end; @#

procedure @? extItemObj.CompleteFuncIdentify;
begin
   gIdentifyEqLociList:=nil;
   if CurWord.Kind = sy_When then
      gIdentifyEqLociList:=new(PList,Init(0));
end;

@ \node{``Reduces to'' registrations.}
Recall, these schematically look like
$$\hbox{\texttt{reduce}\ }\langle\textit{gLeftLocus\/}\rangle\hbox{ \texttt{to} }\langle\textit{Locus\/}\rangle\hbox{\texttt{;}}$$
Mizar will populate \\{gLeftLocus}. The gambit will be to treat this
as a functor pattern; i.e., the \\{gLeftLocus} will be used to
populate \\{gNewPattern} in the method
\\{extItemObj.FinishFunctorPattern} (\section\xref{extItemObj.FinishFunctorPattern}).

@<Local variables for parser additions@>=
  @! gLeftLocus: LocusPtr;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessLeftLocus;
begin
   gLeftLocus:=new(LocusPtr,Init(CurPos,GetIdentifier));
end; @#

procedure @? extItemObj.ProcessRightLocus;
begin
   gIdentifyEqLociList.Insert(new(LociEqualityPtr,
                                 Init(PrevPos,gLeftLocus,new(LocusPtr,Init(CurPos,GetIdentifier)))));
end; @#

procedure @? extItemObj.StartFuncReduction;
begin
end; @#

procedure @? extItemObj.ProcessFuncReduction;
begin
   gNewPatternPos:=gPatternPos;
   gLeftTermInReduction:=gLastTerm;
end;

@* [s] Processing definitions.
The terminology used by the parser appears to be
(\section\section\xref{FixedVariables:parser.pas} \textit{et seq.}):
$$\hbox{\texttt{let} }\langle\textit{Fixed\ Variables}\rangle\hbox{\texttt{;}}$$
and
$$\hbox{\texttt{consider} }\langle\textit{Fixed\ Variables}\rangle\hbox{ \texttt{such that}}\dots$$
This would mean that we would have ``fixed variables'' refer to a list
of qualified segments. We remind the reader of the grammar
\smallbreak
{\advance\leftskip3pc\parindent=0pt
\<Fixed-Variables> $::=$ \<Implicitly-Qualified-Variables> $\LB$ \texttt{","} \<Fixed-Variables> $\RB$\par
\hskip7.3333pc\pipe\ \<Explicitly-Qualified-Variables> $\LB$ \texttt{","} \<Fixed-Variables> $\RB$

\<Implicitly-Qualified-Variables> $::=$ \<Variables>

\<Explicitly-Qualified-Variables> $::=$ \<Qualified-Segment> $\LB$ \texttt{","}
\<Qualified-Segment> $\RB$

\<Qualified-Segment> $::=$ \<Variables> \<Qualification>

\<Variables> $::=$ \<Variable> $\LB$ \texttt{","} \<Variable> $\RB$

\<Qualification> $::=$ (\texttt{"be"} $\pipe$ \texttt{"being"}) \<Type>
\par}
\smallbreak\noindent%
The ``fixed variables'' routine in the parser will parse a
comma-separated list of qualified variables.

\CAUTION/: The grammar in the \texttt{syntax.txt} file is actually
more strict than this, because it actually states the following:
$$\<Loci-Declaration> ::= \hbox{\texttt{"let"} } \<Qualified-Variables> [ \hbox{ \texttt{"such"} } \<Conditions> \hbox{ }] \hbox{ \texttt{;}}$$
The grammar for a qualified segment \emph{requires} implicitly
qualified variables appear at the very end.

\label{extItemObj.StartFixedVariables}

@<Extended item implementation@>=
procedure @? extItemObj.StartFixedVariables;
begin
   gQualifiedSegmentList:=new(PList,Init(0));
end;

@ @<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gQualifiedSegment: MList;
  @! gSegmentPos: Position;

@ \node{Fixed segments.} This refers to each ``explicitly qualified segment''
or ``implicitly qualified segment'' appearing in the fixed variables
portion. The fixed segments are separated by commas.

@<Extended item implementation@>=
procedure @? extItemObj.StartFixedSegment;
begin
   gQualifiedSegment.Init(0);
   gSegmentPos:=CurPos;
end;

@ When parsing fixed variables, and the parser has just entered the
loop to parse fixed variables, this function will be invoked.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessFixedVariable;
begin
   gQualifiedSegment.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end;

@ This ``clears the cache'' for assigning the type in an explicitly
qualified segment (appearing in a fixed variable segment).

@<Extended item implementation@>=
procedure @? extItemObj.ProcessBeing;
begin
   gLastType:=nil;
end;

@ The last statement in the parser loop when parsing ``fixed
variables'' is to push the ``fixed segment'' onto
the \\{gQualifiedSegmentList} global variable. There are two cases to
consider: the implicitly qualified variables and the explicitly
qualified variables.

The implicitly qualified case simple \emph{moves} the pointers around
``manually'', so we need to update every entry
of \\{gQualifiedSegment.Items} to be nil. The explicitly qualified
case moves the pointers around using the \\{MList} constructor,
mutating \\{gQualifiedSegment} into a list of |nil| pointers.

@<Extended item implementation@>=
procedure @? extItemObj.FinishFixedSegment;
var k:integer;
begin
   if gLastType <> nil then {explicitly qualified case}
   begin
      gQualifiedSegmentList^.Insert(new(ExplicitlyQualifiedSegmentPtr,
                                        Init(gSegmentPos,new(PList,MoveList(gQualifiedSegment)),gLastType)));
      gQualifiedSegment.DeleteAll;
   end
   else
   begin
      for k := 0 to gQualifiedSegment.Count - 1 do
      begin
         gQualifiedSegmentList^.Insert(new(ImplicitlyQualifiedSegmentPtr,
                                           Init(VariablePtr(gQualifiedSegment.Items^[k])^.nVarPos,
                                                gQualifiedSegment.Items^[k])));
         gQualifiedSegment.Items^[k]:=nil;
      end;
   end;
   gQualifiedSegment.Done;
end;

@ When we finish parsing fixed variables, we need to ``unset''
the \\{gPremises} global variable. The parser will either be looking
at a semicolon token or at ``\texttt{such} \<Conditions>''. The reader
should note that \\{gSuchThatOcc} is not used in the parser, nor
anywhere else in Mizar. But we recall (\section\xref{pop-let-statement})
the \\{gSuchPos} is used when popping a \texttt{let} statement.

\label{extItemObj.FinishFixedVariables}

@<Local variables for parser additions@>=
  @! gSuchThatOcc: boolean; {not used}

@ @<Extended item implementation@>=
procedure @? extItemObj.FinishFixedVariables;
begin
   gSuchThatOcc:=CurWord.Kind = sy_Such;
   gSuchPos:=CurPos;
   gPremises:=nil;
end;

@ When the parser encounters the statement:
$$\hbox{\texttt{let }} \<Fixed-Variables> \hbox{\texttt{ such that }} \<Assumption>\texttt{;}$$
The first things it does when encountering the ``\texttt{such}'' token
is move to the next token (``\texttt{that}'') and then invoke
the \\{StartAssumption} method. We should allocate a fresh list
for \\{gPremises} and mark the position of the ``\texttt{that}'' token.

@<Extended item implementation@>=
procedure @? extItemObj.StartAssumption;
begin
   gPremises:=new(PList,Init(0));
   gThatPos:=CurPos;
end;

@ Finishing an assumption will update the global
variable \\{gBlockPtr}'s field reflecting it has assumptions.

@<Extended item implementation@>=
procedure @? extItemObj.FinishAssumption;
begin
   ExtBlockPtr(gBlockPtr)^.nHasAssumptions:=true;
end;

@ When the Mizar parser has encountered
$$\hbox{\texttt{assume that }} \<Conditions> \texttt{;}$$
we start a collective assumption when the parser has just encountered
the ``\texttt{that}'' token. As with the ``\texttt{let} statement with
assumptions'', we need to allocate a new list for \\{gPremises} and
assign the \\{gThatPos} to the current position.

@<Extended item implementation@>=
procedure @? extItemObj.StartCollectiveAssumption;
begin
   gPremises:=new(PList,Init(0));
   gThatPos:=CurPos;
end;

@ \node{Processing copula in a definition.} When defining a
(nonexpandable) mode, a functor, a predicate, or an attribute, we have
$$\<Pattern> \hbox{ \texttt{means} } \<Expression>\texttt{;}$$
or
$$\<Pattern> \hbox{ \texttt{equals} } \<Expression>\texttt{;}$$
The expression may or may not be labeled, we may or may not have the
definition-by-cases. Whatever the situation, we should initialize the
variables describing the definiens:
\bul the \\{gDefLabId} should be reset to zero (and populated in
the \\{ProcessDefLabel} method);
\bul the \\{gDefLabPos} should be reset to the current position (and
populated in the \\{ProcessDefLabel} method);
\bul the \\{gDefiningWay} should be assigned to \\{dfMeans}
or \\{dfEquals} depending on the copula used in the definition;
\bul the \\{gOtherwise} pointer should be assigned to |nil|;
\bul the \\{gMeansPos} position should be assigned to the current position.

\medbreak\noindent%
Following tradition in logic, we will refer to ``\texttt{means}'' and
``\texttt{equals}'' as the \define{Copula} in the definition.

@^Copula@>

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gDefLabId:integer;
  @! gDefLabPos: Position;
   
@ @<Local variables for parser additions@>=
  @! gOtherwise: PObject;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessMeans;
begin
   gDefLabId:= 0;
   gDefLabPos:=CurPos;
   gDefiningWay:=dfMeans;
   gOtherwise:=nil;
   gMeansPos:=CurPos
end; @#

procedure @? extItemObj.ProcessEquals;
begin
   gDefLabId:= 0;
   gDefLabPos:=CurPos;
   gDefiningWay:=dfEquals;
   gOtherwise:=nil;
   gMeansPos:=CurPos;
end;

@ When parsing a definition-by-cases, the cases are terminated with an
``\texttt{otherwise}'' keyword. Recall the grammar for such
definitions looks like:
$$ \<Partial-Definiens-List> \hbox{ \texttt{"otherwise"} } \<Expression>\texttt{;}$$
What happens depends on whether the definition uses ``\texttt{means}''
or ``\texttt{equals}'': in the former case, we should update
the \\{gOtherwise} pointer to be the \\{gLastFormula}; in the latter
case, we should update the \\{gOtherwise} to be the \\{gLastTerm}.

@<Extended item implementation@>=
procedure @? extItemObj.FinishOtherwise;
begin
   if gDefiningWay = dfEquals then
      gOtherwise:=gLastTerm
   else gOtherwise:=gLastFormula;
end;

@ Starting a definiens should mutate the |it_Allowed| global variable
to be equal to the caller's |nItAllowed| field. The |it_Allowed|
global variable is toggled on and off when the parser encounters ``guards'' in
conditional definitions, whereas the |nItAllowed| fields reflects
whether the sort of definition allows ``\texttt{it}'' in the definiens.

@<Extended item implementation@>=
procedure @? extItemObj.StartDefiniens;
begin
   it_Allowed:=nItAllowed;
end;

@ ``Guards'' refers to the conditions in a
definition-by-cases. Specifically, we have
$$\<Partial-Definiens> ::= \<Expression> \hbox{ \texttt{"if"} } \<Guard-Formula>$$
be the grammar for one particular case. We have a comma-separated list
of partial definiens, so whenever the parser (a) first encounters the
``\texttt{if}'' keyword in a definiens, or (b) has already encountered
the ``\texttt{if}'' keyword and now has encountered a comma --- these
are the two cases to start a new guard.

@<Local variables for parser additions@>=
  @! gPartDef: PObject;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartGuard;
begin
   if gPartialDefs = nil then
      gPartialDefs:=new(PList,Init(0));
   it_Allowed:=false;
   if gDefiningWay = dfMeans  then
      gPartDef:=gLastFormula
   else gPartDef:=gLastTerm;
end;

@ After parsing a formula, then the parser will invoke \\{FinishGuard}.
This will append to \\{gPartialDefs} a new partial definiens.

@<Extended item implementation@>=
procedure @? extItemObj.FinishGuard;
begin
   it_Allowed:=nItAllowed;
   case gDefiningWay of
      dfMeans:
         gPartialDefs.Insert(new(PartDefPtr,Init(new(DefExpressionPtr,Init(exFormula,gPartDef)),gLastFormula)));
      dfEquals:
         gPartialDefs.Insert(new(PartDefPtr,Init(new(DefExpressionPtr,Init(exTerm,gPartDef)),gLastFormula)));
   endcases;
end;

@ Recall for functor definitions we have something like:
$$ \hbox{\texttt{func }} \<Pattern> \hbox{ \texttt{->} } \<Type> \hbox{ ( \texttt{means} \pipe\ \texttt{equals} ) }\dots$$
Similarly, nonexpandable modes look like
$$ \hbox{\texttt{mode }} \<Pattern> \hbox{ \texttt{->} } \<Type> \hbox{ \texttt{means} } \dots$$
The ``\texttt{->} \<Type>'' is called the [type] \emph{specification} for the
definition. We should update the \\{gSpecification} global variable to
point to whatever the last type parsed was --- which is stored in
the \\{gLastType} global variable.

@<Extended item implementation@>=
procedure @? extItemObj.FinishSpecification;
begin
   gSpecification:=gLastType;
end;

@ ``Construction type'' is the term used by the parser for
``nonexpandable modes''. They, too, have a type
specification. The \\{FinishConstructionType} populates
the \\{gSpecification} global variable with this type.

\label{extItemObj.FinishConstructionType}

@<Extended item implementation@>=
procedure @? extItemObj.FinishConstructionType;
begin
   gSpecification:=gLastType;
end;

@ Expandable mode definitions, after encountering the ``\texttt{is}''
keyword, invokes the \\{StartExpansion} method. This just ensures
there is no definiens, and the \\{gExpandable} global variable is
assigned to ``true''.

@<Extended item implementation@>=
procedure @? extItemObj.StartExpansion;
begin
   if gRedefinitions then  ErrImm(271);
   nDefiniensProhibited:=true;
   gExpandable:=true;
end;

@ The parser, when determining the pattern for an attribute (\section\xref{GetAttrPattern:parser.pas}), resets the state when
starting to determine the pattern for the attribute. This is handled
by the \\{StartAttribute} method.

We should remind the reader that attributes can only have
arguments \emph{to its left}.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gParamNbr: integer;

@ @<Local variables for parser additions@>=
  @! gLocus: LocusPtr;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartAttributePattern;
begin
   gParamNbr:=0;
   gParams:=nil;
   gLocus:=new(LocusPtr,Init(CurPos,GetIdentifier));
end;

@ Since an attribute can only have attributes to its left, it's pretty
clear when the attribute pattern has been parsed: the parser has found
the attribute being defined. In that case (assuming we're not
panicking), we should add the attribute format to the \\{gFormatsColl}
dictionary and update the global variables.

@<Extended item implementation@>=
procedure @? extItemObj.FinishAttributePattern;
var lFormatNr: integer;
begin
   lFormatNr:=0;
   if (CurWord.Kind = AttributeSymbol) and stillcorrect then
      lFormatNr:=gFormatsColl.CollectPrefixForm('V',CurWord.Nr,gParamNbr);
   gPatternPos:=CurPos;
   gConstructorNr:=CurWord.Nr;
   gPattern:=new(AttributePatternPtr,Init(gPatternPos,gLocus,gConstructorNr,gParams));
end;

@ A mode definition may include a ``\texttt{sethood}'' property. This
particular function is used when registering sethood in a registration
block. 

@<Extended item implementation@>=
procedure @? extItemObj.FinishSethoodProperties;
begin
   nLastWSItem^.nContent:=
      new(SethoodRegistrationPtr,Init(nItemPos,gPropertySort,gLastType));
end;

@ We remind the reader the grammar for a mode pattern
$$ \<Mode-Pattern> ::= \<Mode-Symbol>\;[\hbox{ \texttt{"of"} } \<Loci>\;] $$
The loci parameters can only appear \emph{after} the mode symbol (and
before the ``\texttt{of}'' reserved keyword). Starting a mode pattern
should reset the relevant global variables.

\label{extItemObj.StartModePattern}

@<Extended item implementation@>=
procedure @? extItemObj.StartModePattern;
begin
   gParamNbr:=0;
   gParams:=nil;
   gPatternPos:=CurPos;
   gConstructorNr:=CurWord.Nr;
end;

@ Finishing a mode pattern should build a new \\{ModePatternObj}, and
store it in the \\{gPattern} global variable. And if we are not
panicking, we should add it to the \\{gFormatsColl} dictionary.

\label{extItemObj.FinishModePattern}

@<Extended item implementation@>=
procedure @? extItemObj.FinishModePattern;
var lFormatNr: integer;
begin
   lFormatNr:=0;
   if StillCorrect then
      lFormatNr:=gFormatsColl.CollectPrefixForm('M',gConstructorNr,gParamNbr);
   gPattern:=new(ModePatternPtr,Init(gPatternPos,gConstructorNr,gParams));
end;

@ When parser starts parsing a new predicate pattern, we should reset
the relevant global variables.

@<Extended item implementation@>=
procedure @? extItemObj.StartPredicatePattern;
begin
   gParamNbr:=0;
   gParams:=nil;
end;

@ When the parser tries to parse a ``predicative formula'' (i.e., a
formula involving a predicate) --- including predicate patterns ---
the first thing it does is invoke this \\{ProcessPredicateSymbol} method.
This resets the global variables needed to populate the arguments to
the predicate in the formula.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gLeftLociNbr: integer;

@ @<Local variables for parser additions@>=
  @! gLeftLoci: PList;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessPredicateSymbol;
begin
   gPatternPos:=CurPos;
   gLeftLociNbr:=gParamNbr;
   gLeftLoci:=gParams;
   gParamNbr:=0;
   gParams:=nil;
   gConstructorNr:=CurWord.Nr;
end;

@ Finishing a predicate pattern will create a new \\{PredicatePattern}
object, update the \\{gPattern} global variable to point to it, and
(if the parser is not panicking) add the predicate's format to
the \\{gFormatsColl} dictionary.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPredicatePattern;
var lFormatNr: integer;
begin
   lFormatNr:=0;
   if StillCorrect then
      lFormatNr:=gFormatsColl.CollectPredForm(gConstructorNr,gLeftLociNbr,gParamNbr);
   gPattern:=new(PredicatePatternPtr,Init(gPatternPos,gLeftLoci,gConstructorNr,gParams));
end;

@ Functor patterns a bit trickier. When starting one, what should
occur depends on the type of functor being defined. Specifically, we
handle brackets differently than other functors, and within the
brackets we handle braces (i.e., definitions like $\LB x_{1},\dots,x_{n}\RB$)
differently than square brackets ($\hbox{\texttt{[}}x_{1},\dots,x_{n}\hbox{\texttt{]}}$)
differently than everything other functor bracket.

In all cases, even non-bracket functors, we need to reset
the \\{gParamNbr} and \\{gParams} global variables so they may be
populated correctly.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gSubItemKind: TokenKind;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartFunctorPattern;
begin
   gPatternPos:=CurPos;
   gSubItemKind:=CurWord.Kind;
   case CurWord.Kind of
      LeftCircumfixSymbol: gConstructorNr:=CurWord.Nr;
      sy_LeftSquareBracket:
         begin
            gSubItemKind:=LeftCircumfixSymbol;
            gConstructorNr:=SquareBracket
         end;
      sy_LeftCurlyBracket:
         begin
            gSubItemKind:=LeftCircumfixSymbol;
            gConstructorNr:=CurlyBracket
         end;
   othercases gConstructorNr:=0;
   endcases;
   gParamNbr:=0;
   gParams:=nil;
end;

@ For ``non-bracket'' functors (i.e., infix operators), the functor
pattern is processed by (1) getting the left parameters, (2)
processing the functor symbol, (3) getting the right parameters. This
function is precisely step (2).

\label{extItemObj.ProcessFunctorSymbol}
@<Extended item implementation@>=
procedure @? extItemObj.@!ProcessFunctorSymbol;
begin
   gPatternPos:=CurPos;
   if CurWord.Kind = InfixOperatorSymbol then
   begin
      gSubItemKind:=InfixOperatorSymbol;
      gConstructorNr:=CurWord.Nr;
      gLeftLociNbr:=gParamNbr;
      gLeftLoci:=gParams;
      gParamNbr:=0;
      gParams:=nil;
   end;
end;

@ When defining a bracket functor pattern, we add a new bracket
format to the \\{gFormatsColl} dictionary, and then set \\{gPattern}
to a newly allocated Bracket pattern.

When defining an infix functor, we add a new functor format to
the \\{gFormatsColl} dictionary, and then we set the \\{gPattern} to a
newly allocated infix functor pattern.

The ``other cases'' constructs an infix functor pattern, but does not
add the form to the \\{gFormatsColl} dictionary.

\label{extItemObj.FinishFunctorPattern}
@<Extended item implementation@>=
procedure @? extItemObj.FinishFunctorPattern;
var lConstructorNr,lFormatNr: integer;
begin
   lFormatNr:=0;
   case gSubItemKind of
      LeftCircumfixSymbol:
         begin
            lConstructorNr:=CurWord.Nr;
            if StillCorrect then
               lFormatNr:=gFormatsColl.CollectBracketForm(gConstructorNr,lConstructorNr,gParamNbr,0,0);
            gPattern:=new(CircumfixFunctorPatternPtr,Init(gPatternPos,gConstructorNr,lConstructorNr,gParams));
         end;
      InfixOperatorSymbol:
         begin
            if StillCorrect then
               lFormatNr:=gFormatsColl.CollectFuncForm(gConstructorNr,gLeftLociNbr,gParamNbr);
            gPattern:=new(InfixFunctorPatternPtr,Init(gPatternPos,gLeftLoci,gConstructorNr,gParams));
         end;
   othercases
      gPattern:=new(InfixFunctorPatternPtr,Init(gPatternPos,gLeftLoci,gConstructorNr,gParams));
   endcases;
end;

@ The Parser's \\{ReadVisible} procedure begins by invoking
this \\{StartVisible} method. The \\{ReadVisible} procedure occurs
when getting most patterns.

@<Extended item implementation@>=
procedure @? extItemObj.StartVisible;
begin
   gParams:=new(PList,Init(0));
end;

@ The Parser iteratively calls its \\{GetVisible} (\section\xref{GetVisible:parser.pas}) procedure
when \\{ReadVisible} arguments in a pattern. The \\{GetVisible}
procedure in turn invokes this \\{ProcessVisible}, which increments
the number of parameters, and pushes a new \\{Locus} object onto
the \\{gParams} stack.

\label{extItemObj.ProcessVisible}

@<Extended item implementation@>=
procedure @? extItemObj.ProcessVisible;
begin
   inc(gParamNbr);
   if gParams<>nil then
      gParams^.Insert(new(LocusPtr,Init(CurPos,GetIdentifier)));
end;

@ Recall a structure definition, when it has ancestors, looks like
$$\hbox{\texttt{struct (}} \<Ancestors> \hbox{\texttt{) }} \<Structure-Symbol>\cdots$$
The \<Ancestors> field is considered the ``prefix'' to the structure
definition. The Parser parses a type (thereby populating
the \\{gLastType} global variable), then invokes the \\{FinishPrefix}
method, then iterates if it encounters a comma.

The \\{FinishPrefix} method pushes the \\{gLastType} global variable
to the \\{gStructPrefixes} state variable.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPrefix;
begin
   gStructPrefixes.Insert(gLastType);
end;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessStructureSymbol;
var lFormatNr: integer;
begin
   gConstructorNr:=0;
   gPatternPos:=CurPos;
   if CurWord.Kind = StructureSymbol then gConstructorNr:=CurWord.Nr;
   lFormatNr:=gFormatsColl.CollectPrefixForm('J',gConstructorNr,1);
   gParamNbr:=0;
   gParams:=nil;
end;

@ When the Parser has just finished parsing the ancestors to a
structure, but has not parsed the visible arguments. Then the Parser
prepares for reading the visible arguments and then the fields by
invoking this method.
This initializes the \\{gStructFields} state variable as well as
the \\{gFieldsNbr} state variable.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gFieldsNbr:integer;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartFields;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.CollectPrefixForm('L',gConstructorNr,gParamNbr);
   in_AggrPattern:=true;
   gStructFields:=new(PList,Init(0));
   gFieldsNbr:=0;
end;

@ The Parser has just encountered the end structure bracket
(``\texttt{\#)}'') token, so we want to add the format to
the \\{gFormatsColl} dictionary.

@<Extended item implementation@>=
procedure @? extItemObj.FinishFields;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.CollectPrefixForm('G',gConstructorNr,gFieldsNbr);
end;

@ Recall that each field-segment looks like
$$\<Field-Segment> ::= \<Selector-Symbol>\ \LB\hbox{\texttt{","} } \<Selector-Symbol>\RB\ \<Specification>$$
Before parsing the field-segment, the \\{StartAggrPattSegment} is
invoked. 

@<Local variables for parser additions@>=
  @! gStructFieldsSegment: PList;
  @! gSgmPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartAggrPattSegment;
begin
   gStructFieldsSegment:=new(Plist,Init(0));
   gSgmPos:=CurPos;
end;

@ For each selector-symbol the Parser encounters, it invokes
the \\{ProcessField}. 

@<Extended item implementation@>=
procedure @? extItemObj.ProcessField;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.CollectPrefixForm('U',CurWord.Nr,1);
   gStructFieldsSegment^.Insert(new(FieldSymbolPtr,Init(CurPos,CurWord.Nr)));
   inc(gFieldsNbr);
end;

@ After each field has been parsed, the Parser invokes this method to
update the \\{gStructFields} will push a new field segment object onto it.

@<Extended item implementation@>=
procedure @? extItemObj.FinishAggrPattSegment;
begin
   gStructFields.Insert(new(FieldSegmentPtr,Init(gSgmPos,gStructFieldsSegment,gLastType)));
end;

@* [s] Processing remaining statements.
\node{Processing schemes.}
Most of these methods are used in parsing a scheme block
(\section\xref{SchemeBlock:parser.pas}). It will be useful to examine
that function to see where these methods are invoked.

When the Parser starts a new scheme,
several state variables need to be reset. The \\{gSchemeIdNr} is
populated by the \\{GetIdentifier} (\section\xref{GetIdentifier}) procedure,
the \\{gSchemeIdPos} is assigned the current position, and
the \\{gSchemeParams} should be allocated to an empty list.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessSchemeName;
begin
   gSchemeIdNr:=GetIdentifier;
   gSchemeIdPos:=CurPos;
   gSchemeParams:=new(PList,Init(0));
end;

@ A scheme qualification segment looks like, for predicates:
$$\<Variable>\ \LB\ \hbox{ \texttt{","} } \<Variable>\ \RB\ \hbox{\texttt{"["}}
[\<Type-Expression-List>] \hbox{\texttt{"]"}}$$
And for functors:
$$\<Variable>\ \LB\ \hbox{ \texttt{","} } \<Variable>\ \RB\ \hbox{ \texttt{"("} } [\<Type-Expression-List>] \hbox{ \texttt{")"}}$$
When the comma-separated list of identifiers have all been read, but
before either ``\texttt{(}'' or ``\texttt{[}'' has been discerned, the
Parser invokes \\{StartSchemeQualification}.

This will assign the current word kind to \\{gSubItemKind}, and then
initialize the \\{gTypeList} to 4 items.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gTypeList: MList;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartSchemeQualification;
begin
   gSubItemKind:=CurWord.Kind;
   gTypeList.Init(4);
end;

@ After the type-list has been parsed, but before the closing
parentheses or bracket has been encountered, the Parser invokes
the \\{FinishSchemeQualification} method. This assigns the current
position to the \\{gSubItemPos}.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gSubItemPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.FinishSchemeQualification;
begin
   gSubItemPos:=CurPos
end;

@ Starting a scheme segment describes the situation where we
are \emph{just about} to start parsing the comma-separated list of
identifiers for the scheme parameters. This just assigns the current
position to the \\{gSubItemPos}, then initializes \\{gSchVarIds} to 2 spots.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gSchVarIds: MList;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartSchemeSegment;
begin
   gSubItemPos:=CurPos;
   gSchVarIds.Init(2);
end;

@ After parsing the identifier for an entry in the comma-separated
list of scheme variables, the Parser invokes \\{ProcessSchemeVariable}
to add the recently parsed identifier to the \\{gSchVarIds} state
variable. 

@<Extended item implementation@>=
procedure @? extItemObj.ProcessSchemeVariable;
begin
   gSchVarIds.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end;

@ Once the list of scheme variables and their type specification has
been parsed, then the Parser invokes the \\{FinishSchemeSegment} method.
This just turns the \\{gSchVarIds} list into a Predicate segment or a
Functor segment, using the type list the Parser just finished parsing.

@<Extended item implementation@>=
procedure @? extItemObj.FinishSchemeSegment;
begin
   case gSubItemKind of
      sy_LeftParanthesis:
         begin
            gSchemeParams.Insert(new(FunctorSegmentPtr,Init(gSubItemPos,
                                                            new(PList,MoveList(gSchVarIds)),
                                                            new(PList,MoveList(gTypeList)),gLastType)));
         end;
      sy_LeftSquareBracket:
         begin
            gSchemeParams.Insert(new(SchemeSegmentPtr,Init(gSubItemPos,PredicateSegment,
                                                           new(PList,MoveList(gSchVarIds)),
                                                           new(PList,MoveList(gTypeList)))));
         end;
   endcases;
end;

@ The ``scheme thesis'' is the formula statement of the
scheme. Informally, a scheme looks like:
$$ \hbox{\texttt{scheme} }\LB\<Scheme-Parameters>\RB\ \<Scheme-thesis>\ \hbox{\texttt{"provided"}}\ \<Scheme-premises>$$
This means the \\{gLastFormula} state variable contains the scheme's
thesis. But the Parser has not yet started the list of premises. This
is when the Parser invokes the \\{FinishSchemeThesis} method, which
assigns the \\{gLastFormula} to \\{gSchemeConclusion}, then allocates
a new empty list for the \\{gSchemePremises}.

@<Extended item implementation@>=
procedure @? extItemObj.FinishSchemeThesis;
begin
   gSchemeConclusion:=gLastFormula;
   gSchemePremises:=new(Plist,Init(0));
end;

@ The premises for a scheme consists of finitely many formulas
separated by ``\texttt{and}'' keywords. The Parser enters into a loop
invoking this method \emph{after} parsing the formula
but \emph{before} checking the next word is ``\texttt{and}'' 
(and iterating loop). We just need to push the formula onto
the \\{gSchemePremises} list.

@<Extended item implementation@>=
procedure @? extItemObj.FinishSchemePremise;
begin
   gSchemePremises^.Insert(new(PropositionPtr,
                               Init(nLabel,
                                    gLastFormula,nPropPos)));
end;

@ \node{Reserved variables.} These methods are invoked only when the
Parser parses a reservation (\section\xref{Reservation:parser.pas}). A
``reservation segment'' refers to the comma-separated list of
variables and the type.

Starting a reservation segment allocates a new (empty) list
for \\{gResIdents}, and assigns the \\{gResPos} to the current
position. Each variable encountered in the comma-separated list of
variables is appended to the \\{gResIdents} list using
the \\{ProcessReservedIdentifier} method.

Mizar treats each reservation segment as a separate statement. So
there is no difference between:
\smallbreak
{\advance\leftskip3pc\obeylines\parindent=0pt\tt
reserve G for Group, x,y,z for Element of G;
\par}
\smallbreak\noindent%
\dots and\dots
\smallbreak
{\advance\leftskip3pc\obeylines\parindent=0pt\tt
reserve G for Group;

reserve x,y,z for Element of G;
\par}
\smallbreak\noindent%
Finishing a reservation mutates both the \\{gLastWSItem}
and \\{gLastWSBlock} global variables. Specifically, we allocate a new
reservation \\{Item}, then update \\{gLastWSItem} to point to it. The
caller's \\{nLastWSItem} is updated to point to it, too. We assign the
content of this newly allocated reservation \\{Item} based on
the \\{gResIdents} list. We insert this \\{Item} to the end of
the \\{gLastWSBlock}'s items.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
   @!gResIdents: PList;
   @!gResPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartReservationSegment;
begin
   gResIdents:=new(Plist,Init(0));
   gResPos:=CurPos;
end; @#

procedure @? extItemObj.ProcessReservedIdentifier;
begin
   gResIdents^.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end; @#

procedure @? extItemObj.FinishReservationSegment;
begin
   gLastWSItem:=gWsTextProper^.NewItem(itReservation,gResPos);
   nLastWSItem:=gLastWSItem;
   gLastWSItem^.nContent:=new(ReservationSegmentPtr,Init(gResIdents,gLastType));
   gLastWSItem^.nItemEndPos:=PrevPos;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
end;

@ Both ``\texttt{defpred}'' and ``\texttt{deffunc}''
invokes \\{StartPrivateDefiniendum} to initialize the \\{gTypeList},
store the identifier in the \\{gPrivateId}, and assign the current
position to the \\{gPrivateIdPos}. Further, |dol_Allowed| 
is toggled to \\{true} --- placeholder variables are going to be
allowed in the type declarations of the private functor or private
predicate (for example ``\texttt{defpred Foo[set, Element of \$1]}'').

@<Global variables introduced in \texttt{parseraddition.pas}@>=
   @!gPrivateId: Integer;
   @!gPrivateIdPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartPrivateDefiniendum;
begin
   gPrivateId:=GetIdentifier;
   gPrivateIdPos:=CurPos;
   dol_Allowed:=true;
   gTypeList.Init(4);
end;

@ Reading a ``type list'' (for scheme parameters or for private
definitions) loops over reading a type, then pushing it onto
the \\{gTypeList}. The parser delegates that latter ``push work'' to
the \\{FinishLocusType} method.

@<Extended item implementation@>=
procedure @? extItemObj.FinishLocusType;
begin
   gTypeList.Insert(gLastType);
end;

@ The life-cycle of expressions is a little convoluted. The \\{Item}
will allocate a new \\{extExpression} object and assign it to
the \\{gExpPtr}. Later, almost always, the \\{gExpPtr} will invoke a
method to create a subexpression. This subexpression will be
populated, then the \\{gLastTerm} (or \\{gLastFormula}) will be
updated to point to this subexpression object. The expression object
will be freed.

\label{extItemObj.CreateExpression}
@<Extended item implementation@>=
procedure @? extItemObj.CreateExpression(fExpKind:ExpKind);
begin
   gExpPtr:=new(extExpressionPtr,Init(fExpKind));
end;

@ Recall the ``set'' statement is of the form
$$\hbox{\texttt{"set"} } \<Variable> \hbox{ \texttt{"="} } \<Term>\ \LB\ \hbox{\texttt{","} } \<Variable> \hbox{ \texttt{"="} } \<Term>\ \RB$$
The Parser parses this as a loop of assignments of terms to
identifiers. Before iterating, the Parser invokes
the \\{FinishPrivateConstant} method. This allocates a new item for
the constant definition, then assigns it to the \\{gLastWSItem} and to
the caller's \\{nLastWSItem} field. Then the content for the new item
is allocated to be a constant definition object using
the \\{VariablePtr} state variable and the \\{gLastTerm} state
variable. The \\{gLastBlock} global variable pushes the new constant
definition item to its contents.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPrivateConstant;
begin
   gLastWSItem:=gWsTextProper^.NewItem(itConstantDefinition,nItemPos);
   nLastWSItem:=gLastWSItem;
   gLastWSItem^.nContent:=
      new(ConstantDefinitionPtr,
          Init(new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),gLastTerm));
   gLastWSItem^.nItemEndPos:=PrevPos;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
   nItemPos:=CurPos;
end;

@ When the Parser is about to start parsing an assignment
``\<Variable> \texttt{=} \<Term>'' in a ``\texttt{set}'' statement,
the Parser invokes this method. The caller assigns the \\{gPrivateId}
state variable to be the result of \\{GetIdentifier}, and
the \\{gPrivateIdPos} state variable to be the current position.

@<Extended item implementation@>=
procedure @? extItemObj.StartPrivateConstant;
begin
   gPrivateId:=GetIdentifier;
   gPrivateIdPos:=CurPos;
end;

@ For a ``\texttt{defpred}'' and a ``\texttt{deffunc}'', before
parsing the definiens, we need to set the |dol_Allowed| global
variable to true (to allow placeholder variables).

@<Extended item implementation@>=
procedure @? extItemObj.StartPrivateDefiniens;
begin
   dol_Allowed:=true;
end;

@ After parsing the definiendum term for a ``\texttt{deffunc}'', the
Parser invokes this \\{FinishPrivateFuncDefinienition} method. This
assigns the contents of the caller to a \WSM/ private functor
definition syntax tree.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPrivateFuncDefinienition;
begin
   nLastWSItem^.nContent:=
      new(PrivateFunctorDefinitionPtr,
          Init(new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),
               new(PList,MoveList(gTypeList)),gLastTerm));
end;

@ When finishing the definiendum formula for a ``\texttt{defpred}'',
the Parser invokes this \\{FinishPrivatePredDefinienition} method.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPrivatePredDefinienition;
begin
   nLastWSItem^.nContent:=
      new(PrivatePredicateDefinitionPtr,
          Init(new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),
               new(PList,MoveList(gTypeList)),gLastFormula));
end;

@ \node{Reconsider statements.}

@<Extended item implementation@>=
procedure @? extItemObj.ProcessReconsideredVariable;
begin
   gPrivateId:=GetIdentifier;
   gPrivateIdPos:=CurPos;
end; @#

procedure @? extItemObj.FinishReconsideredTerm;
begin
   gReconsiderList^.Insert(new(TypeChangePtr,
                               Init(Equating,new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),gLastTerm)));
end;

@ This is invoked when parsing a private item which is a
``\texttt{reconsider}'' statement.

@<Extended item implementation@>=
procedure @? extItemObj.FinishDefaultTerm;
begin
   gReconsiderList^.Insert(new(TypeChangePtr,Init(VariableIdentifier,
                                                  new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),nil)));
end;

@ When the Parser finishes parsing a formula in
``\texttt{consider} \<Segment> \texttt{such that} \<Formula> $\LB$\texttt{and} \<Formula>$\RB$'',
the Parser invokes the \\{FinishCondition} method. This checks
that \\{gPremises} has been allocated, then pushes a new labeled
formula into it.

@<Extended item implementation@>=
procedure @? extItemObj.FinishCondition;
begin
   if gPremises = nil then
      gPremises:=new(PList,Init(0));
   gPremises^.Insert(new(PropositionPtr,
                         Init(nLabel,
                              gLastFormula,nPropPos)));
end;

@ In statements of the form
$$\texttt{assume\ } \<Formula>\texttt{;}$$
Or of the form
$$\texttt{assume\ } \<Formula> \texttt{\ and\ } \<Formula> \texttt{\ and\ } \dots \texttt{\ and\ } \<Formula>\texttt{;}$$
After each formula parsed, the Parser invokes
the \\{FinishHypothesis}. This just inserts a new labeled formula into
the \\{gPremises} state variable, when the \\{gPremises} state
variable is not |nil|.

@<Extended item implementation@>=
procedure @? extItemObj.FinishHypothesis;
begin
   if gPremises <> nil then
      gPremises^.Insert(new(PropositionPtr,
                            Init(nLabel,
                                 gLastFormula,nPropPos)));
end;

@ \node{``Take'' statements.} For statements of the form
$$\texttt{take\ }\<Variable>\texttt{\ =\ }\<Term>\texttt{;}$$
The Parser invokes the \\{ProcessExemplifyingVariable} method, then
parses the term, and then constructs the AST by invoking \\{FinishExemplifyingVariable}.

Finishing a ``\texttt{take}'' statement
mutates both the \\{gLastWSItem} and the \\{gLastWSBlock} global variables.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessExemplifyingVariable;
begin
   gPrivateId:=GetIdentifier;
   gPrivateIdPos:=CurPos;
end; @#

procedure @? extItemObj.FinishExemplifyingVariable;
begin
   gLastWSItem:=gWsTextProper^.NewItem(itExemplification,nItemPos);
   nLastWSItem:=gLastWSItem;
   gLastWSItem^.nContent:=new(ExamplePtr,Init(new(VariablePtr,
                                                  Init(gPrivateIdPos,gPrivateId)),gLastTerm));
   gLastWSItem^.nItemEndPos:=PrevPos;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
   nItemPos:=CurPos;
end;

@ In statements of the form
$$\texttt{take\ }\<Term>\texttt{;}$$
the Parser begins by invoking \\{StartExemplifyingTerm}, parses the
term, then \\{FinishExemplifyingTerm}.

@<Extended item implementation@>=
procedure @? extItemObj.StartExemplifyingTerm;
begin
   if (CurWord.Kind=Identifier) and extBlockPtr(gBlockPtr)^.nInDiffuse and
         ((AheadWord.Kind=sy_Comma) or (AheadWord.Kind=sy_Semicolon)) then
   begin
      gPrivateId:=GetIdentifier;
      gPrivateIdPos:=CurPos;
   end
   else gPrivateId:=0;
end; @#

procedure @? extItemObj.FinishExemplifyingTerm;
begin
   gLastWSItem:=gWsTextProper^.NewItem(itExemplification,nItemPos);
   nLastWSItem:=gLastWSItem;
   if gPrivateId <> 0 then
      gLastWSItem^.nContent:=
         new(ExamplePtr,Init(new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),nil))
   else
      gLastWSItem^.nContent:=new(ExamplePtr,Init(nil,gLastTerm));
   gLastWSItem^.nItemEndPos:=PrevPos;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
   nItemPos:=CurPos;
end;

@ When the Parser examines the correctness conditions
(\section\xref{Correctness:parser.pas}), it loops over the correctness
conditions and justifications. Afterwards, it invokes
the \\{ProcessCorrectness} method, which tests that the parser is not
current looking at a correctness keyword. Then it tests if
|gCorrectnessConditions| is empty or |AxiomsAllowed| (in which case,
correctness has been satisfies, so the Parser moves happily
along). But if $\\{gCorrectnessConditions}\neq\emptyset$ or axioms are
not allowed, then a 73 error is raised.

@:Error, 073}{Error, 73@>

\label{extItemObj.ProcessCorrectness}

@<Extended item implementation@>=
procedure @? extItemObj.ProcessCorrectness;
begin
   if CurWord.Kind <> sy_Correctness then
      if (gCorrectnessConditions <> []) and not AxiomsAllowed then
         Error(gDefPos,73);
end;

@ A ``construction type'' appears in a redefinition where the type is
redefined. In such a situation, we need to add ``\texttt{coherence}''
as a correctness condition. The \\{StartConstructionType} handles this
task. 

\label{extItemObj.StartConstructionType}

@<Extended item implementation@>=
procedure @? extItemObj.StartConstructionType;
begin
   if gRedefinitions and (CurWord.Kind = sy_Arrow) then
      include(gCorrectnessConditions,syCoherence);
end;

@ This is used in the Parser's \\{ProcessLab} procedure. Really, all
the work is being done here: the \\{nLabel} field of the caller is
assigned to a newly allocated \\{Label} object.

\label{extItemObj.ProcessLabel}

@<Extended item implementation@>=
procedure @? extItemObj.ProcessLabel;
begin
   nLabelIdNr:=0;
   nLabelIdPos:=CurPos;
   if (CurWord.Kind=Identifier) and (AheadWord.Kind=sy_Colon) then
      nLabelIdNr:=CurWord.Nr;
   nLabel:=new(LabelPtr,Init(nLabelIdNr,nLabelIdPos));
end;

@ A regular statement is either a ``diffuse'' statement (which occurs
with the ``\texttt{now}'' keyword) or else it's a ``compact'' statement.

@<Extended item implementation@>=
procedure @? extItemObj.StartRegularStatement;
begin
   if CurWord.Kind=sy_Now then
      nRegularStatementKind:=stDiffuseStatement
   else nRegularStatementKind:=stCompactStatement;
end;

@ If the Parser encounters a colon after the copula, then it invokes
this method to construct a label for the Definiens.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
   @!gDefLabel: LabelPtr;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessDefiniensLabel;
begin
   gDefLabId:= 0;
   gDefLabPos:=CurPos;
   if (CurWord.Kind=Identifier) and (AheadWord.Kind=sy_Colon) then
      gDefLabId:= CurWord.Nr;
   gDefLabel:= new(LabelPtr,Init(gDefLabId,gDefLabPos));
end;

@ The Parser, having encountered ``\texttt{from}'' and a non-MML
reference, tries to treat the identifier as the label for a scheme
declared in the current article. The \\{nInference} field would be
a \\{SchemeJustification} object, so we just populate
its \\{nSchemeIdNr} and position fields.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessSchemeReference;
begin
   if CurWord.Kind = Identifier then
   begin
      SchemeJustificationPtr(nInference)^.nSchemeIdNr:=CurWord.Nr;
      SchemeJustificationPtr(nInference)^.nSchemeInfPos:=CurPos;
   end;
end;

@ When a ``\texttt{by}'' refers to a theorem or definition from an
article in the MML, the Parser invokes the \\{StartLibraryReference} method.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gTHEFileNr:integer;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartLibraryReferences;
begin
   gTHEFileNr:=CurWord.Nr;
end;

@ The Parser has already encountered a ``\texttt{from}'' and then an
MML article identifier. Before continuing to parse the scheme number,
the Parser invokes this method to initialize the relevant state variables.

@<Extended item implementation@>=
procedure @? extItemObj.StartSchemeLibraryReference;
begin
   gTHEFileNr:=CurWord.Nr;
end;

@ For references to labels found in the article being processed
(``private references''), this method is invoked.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessPrivateReference;
begin
   SimpleJustificationPtr(nInference)^.nReferences^.Insert(new(LocalReferencePtr,
                                                               Init(GetIdentifier,CurPos)));
end;

@ When using a definition from an MML article in a scheme reference
(something like\hfill\break
``\texttt{from MyScheme(ARTICLE:def 5,\dots)}''), well, the Parser
stores this fact in a state
variable \\{gDefinitional}. The \\{ProcessDef} method populates this
state variable correctly.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gDefinitional: boolean;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessDef;
begin
   gDefinitional:=(CurWord.Kind = ReferenceSort) and (CurWord.Nr = ord(syDef))
end;

@ When accumulating the references in a Scheme-Justification, and a
reference is from an MML article, \\{ProcessTheoremNumber} transforms
it into a newly allocated reference object. The
caller's \\{nInference} then adds the newly allocated object to
its \\{nReferences} collection. 

@^Error, 146@>

@<Extended item implementation@>=
procedure @? extItemObj.ProcessTheoremNumber;
var lRefPtr: ReferencePtr;
begin
   if CurWord.Kind <> Numeral then exit;
   if CurWord.Nr = 0 then
   begin
      ErrImm(146);
      exit
   end;
   if gDefinitional then
      lRefPtr:=new(DefinitionReferencePtr, Init(gTHEFileNr,CurWord.Nr,CurPos))
   else
      lRefPtr:=new(TheoremReferencePtr, Init(gTHEFileNr,CurWord.Nr,CurPos));
   SimpleJustificationPtr(nInference)^.nReferences^.Insert(lRefPtr);
end;

@ When a Scheme-Justification uses a local reference, the Parser
delegates the work to the \\{Item}'s \\{ProcessSchemeNumber} method. This updates
the caller's \\{nInference} field.

@^Error, 146@>

@<Extended item implementation@>=
procedure @? extItemObj.ProcessSchemeNumber;
begin
   if CurWord.Kind <> Numeral then exit;
   if CurWord.Nr = 0 then
   begin
      ErrImm(146);
      exit
   end;
   with SchemeJustificationPtr(nInference)^ do
   begin
      nSchFileNr:=gTHEFileNr;
      nSchemeIdNr:=CurWord.Nr;
      nSchemeInfPos:=PrevPos;
   end;
end;

@ This appears when the Parser starts its \\{Justification}
(\section\xref{Justification:parser.pas}) procedure, or in the
\\{RegularStatement}
(\section\xref{RegularStatement:parser.pas}) procedure.

This clears the \\{nInference}, reassigning it to the |nil| pointer.

For nested ``\texttt{proof}'' blocks, check if the `check proofs'
(``\texttt{::\$P+}'') pragma has been enabled --- if so, just set the
caller's \\{nInference} to be a new Justification object with a
`proof' tag. Otherwise, we're skipping the proofs, so
set \\{nInference} to be the `skipped' justification.

@<Extended item implementation@>=
procedure @? extItemObj.StartJustification;
begin
   nInference:=nil;
   if CurWord.Kind = sy_Proof then
   begin
      if ProofPragma then
         nInference:=new(JustificationPtr,Init(infProof,CurPos))
      else
         nInference:=new(JustificationPtr,Init(infSkippedProof,CurPos))
   end;
end;

@ A simple justification is either a Scheme-Justification
(``\texttt{from}\dots''), a Straightforward-Justification
(``\texttt{by}\dots''), or\dots somethign else?

@<Extended item implementation@>=
procedure @? extItemObj.@!StartSimpleJustification;
begin
   case CurWord.Kind of
      sy_From:
         nInference:=new(SchemeJustificationPtr,Init(CurPos,0,0));
      sy_By:
         with extBlockPtr(gBlockPtr)^ do
         nInference:=new(StraightforwardJustificationPtr,Init(CurPos,nLinked,nLinkPos));
   othercases
      with extBlockPtr(gBlockPtr)^ do
         nInference:=new(StraightforwardJustificationPtr,Init(PrevPos,nLinked,nLinkPos));
   endcases;
end;

@ We should update the \\{nInference} field's sort to be \\{infError}
when, well, the inference is an error (e.g., the Parser is in panic
mode). We should set the \\{gBlockPtr}'s \\{nLinked} field to false
when we just added a straightforward justification (or an erroneous
justification). 

@d is_inference_error == not StillCorrect or@|
       ((CurWord.Kind <> sy_Semicolon) and (CurWord.Kind <> sy_DotEquals)) or@|
       ((nInference^.nInfSort = infStraightforwardJustification) and (byte(nLinked) > byte(nLinkAllowed))) or@|
       ((nInference^.nInfSort = infSchemeJustification) and (SchemeJustificationPtr(nInference)^.nSchemeIdNr = 0))

@<Extended item implementation@>=
procedure @? extItemObj.@!FinishSimpleJustification;
begin
   with extBlockPtr(gBlockPtr)^ do
   begin
      if is_inference_error
      then nInference^.nInfSort:=infError;
   end;
   if (nInference^.nInfSort = infStraightforwardJustification) or (nInference^.nInfSort = infError)
   then extBlockPtr(gBlockPtr)^.nLinked:=false;
end;

@ For iterative equalities, we should recall that it looks like
\smallbreak
{\advance\leftskip5pc\tt\obeylines\parindent=0pt
LHS = RHS \<Justification>

\ \ \ .= RHS2

\ \ \ .= \dots;\par}

\smallbreak\noindent%
This matters because, well, when the Parser has parsed ``\texttt{LHS = RHS} \<Justification>'',
the Parser believes it is a compact statement. Until the Parser looks
at the next token, it does not know whether this is a
Compact-Statement or an iterated equality. The \\{FinishCompactMethod}
peeks at the token, and when the token is an iterated equality
(``\texttt{.=}'') updates the caller's fields as well as initialize
the \\{gIterativeLastFormula}, \\{gIterativeSteps}, and \\{gInference}
state variables. The \\{gBlockPtr} is updated to make its \\{nLinked}
field false.

@<Extended item implementation@>=
procedure @? extItemObj.@!FinishCompactStatement;
begin
   if CurWord.Kind = sy_DotEquals then
   begin
      gIterativeLastFormula:=gLastFormula;
      nRegularStatementKind:=stIterativeEquality;
      extBlockPtr(gBlockPtr)^.nLinked:=false;
      gIterativeSteps:=new(PList,Init(0));
      gInference:=nInference;
   end;
end;

@ Every time the Parser encounters the ``\texttt{.=}'' token, it
immediately invokes the \\{StartIterativeStep} method. This just
updates the \\{gIterPos} state variable to the current position.

@<Local variables for parser additions@>=
  @! gIterPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.@!StartIterativeStep;
begin
   gIterPos:=CurPos; @+
end;

@ Right before the Parser iterates the loop checking if
``\texttt{.=}'' is the next token for an iterative equation, the
Parser invokes the \\{FinishIterativeStep} method. This just adds a
new \\{IterativeStep} object, an AST node representing the preceding
``\texttt{.= RHS by} \<Justification>''.

@<Extended item implementation@>=
procedure @? extItemObj.@!FinishIterativeStep;
begin
   gIterativeSteps^.Insert(new(IterativeStepPtr,Init(gIterPos,gLastTerm,nInference)));
end;

@ In a definition, after the Parser finishes parsing the definiens, we
construct the AST node for it with the \\{FinishDefiniens} method.

For each copula (``\texttt{means}'' and ``\texttt{equals}''), the
algorithm is the same: if we just had a definition-by-cases, then
store the ``\texttt{otherwise}'' clause in \\{lExp} and assign
the \\{gDefiniens} state variable to a newly allocated conditional
definiens object. If the definiens is not a definition-by-cases (i.e.,
it's a ``simple'' definition), then just assign \\{gDefiniens} a newly
allocated \\{SimpleDefiniens} object.

For functor definitions (not redefinitions),
the \\{gCorrectnessConditions} are assigned here.

@^Correctness Conditions@>

@<Extended item implementation@>=
procedure @? extItemObj.@!FinishDefiniens;
var lExp: DefExpressionPtr;
begin
   case gDefiningWay of
      dfMeans:@|@/
         if gPartialDefs <> nil then
         begin
            lExp:=nil;
            if gOtherwise <> nil then
               lExp:=new(DefExpressionPtr,Init(exFormula,gOtherwise));
            gDefiniens:=new(ConditionalDefiniensPtr,Init(gMeansPos,gDefLabel,gPartialDefs,lExp))
         end
         else
            gDefiniens:=new(SimpleDefiniensPtr,Init(gMeansPos,gDefLabel,
                                                    new(DefExpressionPtr,Init(exFormula,gLastFormula))));
      dfEquals:@|@/
         if gPartialDefs <> nil then
         begin
            lExp:=nil;
            if gOtherwise <> nil then
               lExp:=new(DefExpressionPtr,Init(exTerm,gOtherwise));
            gDefiniens:=new(ConditionalDefiniensPtr,Init(gMeansPos,gDefLabel,gPartialDefs,lExp))
         end
         else
            gDefiniens:=new(SimpleDefiniensPtr,Init(gMeansPos,gDefLabel,new(DefExpressionPtr,Init(exTerm,gLastTerm))));
   endcases;
   if not gRedefinitions and (nItemKind = itDefFunc) then
   begin
      if gDefiningWay = dfMeans then
         gCorrectnessConditions:=[syExistence,syUniqueness]
      else if gDefiningWay = dfEquals then
         gCorrectnessConditions:=[syCoherence];
   end;
end;


@* [S] Extended subexpression class.
\node{Aside: refactoring.}
We should probably refactor a private procedure \\{PushTermStack} to
push a new term onto the term stack, and a private
function \\{PopTermStack} to return the top of the term stack (and
mutate the term stack), and possibly a \\{ResetTermStack} procedure
(which will clear the term stack and possibly the objects stored in it?).

We see that \\{TermNbr} is
decremented when popping the \\{Term} stack (via \\{FinishTerm});
when \\{FinishQualifyingFormula} is invoked, it decrements the \\{TermNbr};
when \\{FinishAttributiveFormula} is invoked, it decrements the \\{TermNbr};
but these latter two methods can (and should) be refactored to use
the \\{FinishTerm} to pop the term stack and decrement the \\{TermNbr}
state variable.

Assigning the \\{TermNbr} occurs
when \\{CreateArgs} method is invoked;
the \\{InsertIncorrBasic} method resets the \\{TermNbr} to the \\{nTermBase};
the \\{ProcessAtomicFormula}, when a 157 error is raised, will reset
the \\{TermNbr} to the \\{nTermBase};
when the constructor for an \\{extExpression} object is invoked, it
resets the \\{TermNbr} to zero (which happens in
the \\{extItem}'s \\{CreateExpression} method---which occurs
frequently enough to be a worry).

The only time when the \\{TermNbr} is incremented is when we push a
new term onto the \\{Term} stack.


@
There is a comment in Polish ``teraz jest to kolekcja
MultipleTypeExp'', which Google translates to ``now it is a
MultipleTypeExp collection''. I have made this replacement in the code
below, prefixed with a ``+'' sign (to distinguish it from the other
comment already in English).

Also note: the \\{nRestriction} refers to the subformula in a
universally quantified formula
$$\hbox{\texttt{for }}\<Variables>\hbox{ \texttt{st} }\<Restriction>\hbox{ \texttt{holds} }\dots$$

\label{extSubexprObj:class}

@d arg_type == record Start,Length: integer; end
@d func_type == record Instance,SymPri: integer; FuncPos: Position; end

@<Methods implemented by subclasses of |SubexpObj|@>=

@ @<Extended subexpression class declaration@>=
   @! extSubexpPtr = ^extSubexpObj; @/
   @! extSubexpObj = object(SubexpObj) @t\1@> @/
      @! nTermBase, @! nRightArgBase: integer;
      @! nSubexpPos,@! nNotPos,@! nRestrPos: Position;
      @! nQuaPos:Position;
      @! nSpelling: Integer;
      @! nSymbolNr, @!nRSymbolNr: integer;
      @! nConnective, @! nNextWord: TokenKind;
      @! nModeKind: TokenKind;
      @! nModeNr: integer;
      @! nRightSideOfPredPos: Position;
      @! nMultipredicateList:MList; @#
      
      @! nSample: TermPtr; {for Fraenkel terms}
      @! nAllPos: Position;
      @! nPostQualList: MList; {+ now it is a MultipleTypeExp collection}
      @! nQualifiedSegments: MList;
      @! nSegmentIdentColl: MList; {quantified variables, keeps spellings of vars}
      @! nSegmentPos: Position; @#

      @! nFirstSententialOperand: FormulaPtr;
      @! nRestriction: FormulaPtr; @#

      @! nAttrCollection: MList; @#

      @! nNoneOcc: boolean;
      @! nNonPos:Position;
      @! nPostNegated: boolean; @#

      @! nArgListNbr: integer; {position in a term (\section\xref{AppendFunc:parser.pas})}
      @! nArgList: array of arg_type;
      @! nFunc: array of func_type; @#

      constructor @? Init; @t\2@> @/

@t\4@> @<Methods implemented by subclasses of |SubexpObj|@>@t\2\2@>@;
   end;


@ The |TermNbr| is used to treat a list of terms as a stack data
structure. Specifically, the \\{Term} array is treated as a stack, and
the \\{TermNbr} is the index of the ``top'' of the stack.

@<Local variables for parser additions@>=
  @! TermNbr: integer;

@ @<Extended subexpression implementation@>=
{{\it Subexpressions handling}}

constructor @? extSubexpObj.Init;
const MaxArgListNbr = 20;
begin
   inherited Init;
   nRestriction:=nil;
   nTermBase:=TermNbr;
   nArgListNbr:=0;
   setlength(nArgList,MaxArgListNbr+1);
   setlength(nFunc,MaxArgListNbr+1);
   nArgList[0].Start:=TermNbr+1;
end;


@ When the Parser is about to parse a stack of attributes, either in a
registration or on a type, we need to initialize the appropriate state
variables. We also need the caller's \\{nAttrCollection} to be
initialized with an empty list.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartAttributes;
begin
   nAttrCollection.Init(0);
   gLastType:=nil;
end;

@ When the Parser expects an adjective, and the caller is used to
store the adjective or attribute, we need to check if it is
negated. This handles it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessNon;
begin
   nNoneOcc:=CurWord.Kind = sy_Non;
   nNonPos:=CurPos;
end;

@ \node{Pop arguments from term stack.} This will take some
parameter \\{aBase} and copy pointers to each element of |Term[aBase .. TermNbr]| into a new list. 
Then the \\{TermNbr} state variable is updated to be $\\{aBase}-1$.

This means that executing ``|list1 := CreateArgs(aBase); list2 := CreateArgs(aBase);|''
will have |list2 = nil|.

Bug: when |aBase <= 0|, this will set |TermNbr| to a negative number.

\label{CreateArgs}
@<Extended subexpression implementation@>=
function CreateArgs(aBase:integer): PList;
var k:integer;
lList: PList;
begin
   lList:=new(PList,Init(TermNbr-aBase));
   for k:=aBase to TermNbr do
      lList.Insert(Term[k]);
   TermNbr:=aBase-1;
   CreateArgs:=lList;
end;

@ The ``process (singular) attribute'' method is invoked in
the ``process (plural) attributes'' procedure (\section\xref{ProcessAttributes:parser.pas}), and in the \\{ATTSubexpression} procedure (\section\xref{ATTSubexpression}).
This method will be invoked when the Parser is looking at an attribute
token.

When there is no format recorded for such an attribute, then a 175
error will be raised.

This will allocate a new Adjective object, store it in
the \\{gLastAdjective} state variable, then append it to
the \\{nAttrCollection} field of the caller.

@^Error, 175@>

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gLastAdjective: AdjectiveExpressionPtr;

@ @<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessAttribute;
var lFormatNr:integer;
begin
   if CurWord.Kind = AttributeSymbol then
   begin
      lFormatNr:=gFormatsColl.LookUp_PrefixFormat('V',CurWord.Nr,TermNbr-nTermBase+1);
      if lFormatNr = 0 then {format not found!}
      begin
         gLastAdjective:=new(AdjectivePtr,Init(CurPos,0,CreateArgs(nTermBase+1)));
         Error(CurPos,175)
      end
      else
      begin
         gLastAdjective:=new(AdjectivePtr,Init(CurPos,CurWord.Nr,CreateArgs(nTermBase+1)));
         if nNoneOcc then
            gLastAdjective:=new(NegatedAdjectivePtr,Init(nNonPos,gLastAdjective));
      end;
   end
   else {needed for \\{ATTSubexpression} adjective cluster handling}
   begin
      gLastAdjective:=new(AdjectivePtr,Init(CurPos,0,CreateArgs(nTermBase+1)));
   end; @/
   nAttrCollection.Insert(gLastAdjective);
end;

@ These next next method is invoked before the Parser parses arguments
for an attribute.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartAttributeArguments;
begin
   nTermBase:=TermNbr;
end;

@ The next two methods are invoked after the Parser has finished
parsing the arguments for an attribute.

I am confused why there is
duplicate code here, and the naming conventions suggest
the \\{FinishAttributeArguments} method should be preferred.

\label{extSubexpObj.CompleteAttributeArguments}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.CompleteAttributeArguments;
begin
   nSubexpPos:=CurPos;
   nRightArgBase:=TermNbr;
end; @#

procedure @? extSubexpObj.FinishAttributeArguments;
begin
   nSubexpPos:=CurPos;
   nRightArgBase:=TermNbr;
end;

@ This allocates a new list of pointers, moves the
caller's \\{nAttrCollection} into the list, and updates the \\{gAttrColl}
state variable to point at them.

Again, this should be named \\{FinishedAdjectiveCluster} to be
consistent with the naming conventions seemingly adopted.

\label{extSubexpObj.CompleteAdjectiveCluster}
@<Extended subexpression implementation@>=
procedure @? extSubexpObj.CompleteAdjectiveCluster;
begin
   gAttrColl:=new(PList,MoveList(nAttrCollection));
end;

@ When the Parser works its way through a registration block, check
that the \\{TermNbr} points to not farther ahead than one more token 
ahead from the caller's \\{nTermBase} field. Raise an error if that
happens.

This method is only invoked in the Parser module's
the \\{RegisterCluster} (\section\xref{RegisterCluster:parser.pas}) procedure.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.CompleteClusterTerm;
begin
   if TermNbr-nTermBase > 1 then
   begin
      ErrImm(379);
      gLastTerm:=new(IncorrectTermPtr,Init(CurPos));
   end;
end;

@ A ``simple term'' appears to be a variable. This is used when the
Parser parses an identifier as a closed term
(\section\xref{GetClosedSubterm:identifier:parser.pas}). The state
variable |gLastTerm| is updated to point to a newly
allocated \\{SimpleTerm} object.

This method should probably be moved closer to the other methods
used when parsing terms.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessSimpleTerm;
begin
   gLastTerm:=new(SimpleTermPtr,Init(CurPos,GetIdentifier));
end;

@ \node{Qualified terms.} The Parser invokes \\{ProcessQua} when it is
looking directly at a ``\texttt{qua}'' token, specifically in
the \\{AppendQua} (\section\xref{AppendQua})
procedure. The \\{ProcessQua} method is used nowhere else. It is
solely responsible for ``marking the current position'' of the Parser,
and storing that in the caller's \\{nQuaPos} field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessQua;
begin
   nQuaPos:=CurPos
end;

@ The Parser invokes the \\{FinishedQualifiedTerm} method after
encountering a ``\texttt{qua}'' and after parsing the type. This
method constructs a new \\{QualifiedTerm} object reflecting the top of
the \\{Term} stack is taken ``\texttt{qua}'' the \\{gLastType}, and
the mutates the top of the \\{Term} stack to be this newly
allocated \\{QualifiedTerm} object.

This method does not push anything new to
the term stack, but it does mutate the \\{Term} stack.

This method is used nowhere else other than the Parser's \\{AppendQua}
(\section\xref{AppendQua}) procedure.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishQualifiedTerm;
begin
   Term[TermNbr]:=new(QualifiedTermPtr, Init(nQuaPos,Term[TermNbr],gLastType));
end;

@ Although the ``\texttt{exactly}'' reserved keyword is not used for
anything, the method for \\{ProcessExactly} marks the current position
and stores it in the caller's \\{nQuaPos}, then \emph{updates}
(\textbf{not} pushes) to the top of the term
stack by turning the top of the stack into an \\{ExactlyTerm} object.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessExactly;
begin
   nQuaPos:=CurPos;
   Term[TermNbr]:=new(ExactlyTermPtr, Init(nQuaPos,Term[TermNbr]));
end;

@ \node{Arguments to a term.} The \\{CheckTermLimit} procedure is a
``private helper function'' for the \\{FinishArgument} method.

@<Extended subexpression implementation@>=
procedure CheckTermLimit;
var l: integer;
begin
   if TermNbr >= length(Term) then
   begin
      l:=2*length(Term);
      setlength(Term,l);
   end;
end;

@ \node{Pushing the Term stack.}
This method pushes the \\{gLastTerm} state variable's contents to
the \\{Term} stack, mutating the \\{TermNbr} and \\{Term} module-local variables.

\label{extSubexpObj.FinishArgument}
@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishArgument;
begin
   CheckTermLimit;
   inc(TermNbr);
   Term[TermNbr]:=gLastTerm;
end;

@ \node{Pop the Term stack.} The evil twin to ``pushing'' an element
onto a stack, ``popping'' a stack removes the top element. We pop
the \\{Term} stack whenever we finish the term.

This is only used in \\{AppendFunc} (\section\xref{AppendFunc:parser.pas}).

This should probably check that the \\{Term} stack is not empty before
being invoked.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishTerm;
begin
   gLastTerm:=Term[TermNbr];
   dec(TermNbr);
end;

@* [s] Parsing Types.
When we start parsing a new type, we make sure the \\{gLastType}
state variable is not caching an old type. We assign it to be the |nil|
pointer. 

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartType;
begin
   gLastType:=nil;
end;

@ This is invoked only by the Parser's \\{RadixTypeSubexpression}
(\section\xref{RadixTypeSubexpression:parser.pas}) procedure. The
Parser delegates the work of storing the mode information to this
method. In turn, the caller's \\{nModeKind} field stores the current word's
token \\{Kind}, and the caller's \\{nModeNr} field stores the current
word's number. The Parser's current position is marked and stored in
the caller's \\{nSubexpPos} field.

But no state variables are mutated by this method.

\label{extSubexpObj.ProcessModeSymbol}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessModeSymbol;
begin
   nModeKind:=CurWord.Kind;
   nModeNr:=CurWord.Nr;
   if (CurWord.Kind = sy_Set) {?|and (AheadWord.Kind <> sy_Of)|?} then
      nModeKind:=ModeSymbol;
   nSubexpPos:=CurPos;
end;

@ The Parser has just finished parsing a type and its arguments ---
``\<Mode> \texttt{of} \<Term-list>'' or ``\<Structure> \texttt{over} \<Term-list>''.
The data has been accumulated into the caller, which will now be
constructed into an AST object. The newly allocated AST node will be
stored in the \\{gLastType} state variable.

If the caller is trying to construct a mode which does not match the
format recorded in the \\{gFormatsColl}, a 151 error will be raised.

Similarly, if the caller is trying to construct a structure which does
not match the format recorded in the \\{gFormatsColl}, a 185 error
will be raised.

@^Error, 151@>
@^Error, 185@>

This is invoked only by the Parser's \\{RadixTypeSubexpression}
(\section\xref{RadixTypeSubexpression:parser.pas}) procedure.
@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishType;
var lFormatNr: integer;
begin
   case nModeKind of
      ModeSymbol:
         begin
            lFormatNr:=gFormatsColl.LookUp_PrefixFormat('M',nModeNr,TermNbr-nTermBase);
            if lFormatNr=0 then Error(nSubexpPos,151); {format missing}
            gLastType:=new(StandardTypePtr,Init(nSubexpPos,nModeNr,CreateArgs(nTermBase+1)));
         end;
      StructureSymbol:
         begin
            lFormatNr:=gFormatsColl.LookUp_PrefixFormat('L',nModeNr,TermNbr-nTermBase);
            if lFormatNr = 0 then SemErr(185); {format missing}
            gLastType:=new(StructTypePtr,Init(nSubexpPos,nModeNr,CreateArgs(nTermBase+1)));
         end;
   othercases
   begin
      gLastType:=new(IncorrectTypePtr, Init(CurPos)); @+
   end;
   endcases;
end;

@ If the Parser has the misfortune of trying to make sense of a
malformed type expression, then with a heavy heart it invokes this
method to update the \\{gLastType} state variable to be an incorrect
type expression at the current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.InsertIncorrType;
begin
   gLastType:=new(IncorrectTypePtr, Init(CurPos));
end;

@ When the parser encounters a qualifying formula
(``\<Term> \texttt{is} \<Type>'') or is parsing a type for a cluster
(the ``\texttt{cluster} \dots \texttt{for} \<Type>''), after parsing
the type, this method is invoked to \textbf{update} the \\{gLastType} state
variable to store the \\{ClusteredType} AST node (which decorates a
type --- the contents of \\{gLastType} at the time of calling --- with
a bunch of attributes).

The caller's \\{nAttrCollection} is transferred to the \\{gLastType}.
At the end of the method, the caller's \\{nAttrCollection} (array of
pointers) is freed. This does not free the objects referenced by the
pointers, however.

If |gLastType = nil|, then the Parser has somehow failed to parse the
type expression. An error should be raised.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.CompleteType;
var j: integer;
begin
   mizassert(5433,gLastType <> nil);
   if nAttrCollection.Count > 0 then
   begin
      gLastType:=new(ClusteredTypePtr,Init(gLastType^.nTypePos,
                                           new(PList,Init(nAttrCollection.Count)),gLastType));
      for j := 0 to nAttrCollection.Count-1 do
         ClusteredTypePtr(gLastType)^.nAdjectiveCluster^.Insert(PObject(nAttrCollection.Items^[j]));
      nAttrCollection.DeleteAll;
   end;
end;

@* [s] Parsing operator precedence.
Mario Carneiro's ``Mizar in Rust'' (\section6.2) gives an overview of
this parsing routine (see also his \texttt{mizar-rs/src/parser/miz.rs}
for the Rust version of the same code). It is a constrained
optimization problem. We shall take care to dissect this routine.
This appears to be where operator precedence, the \\{gPriority}
(\section\xref{gFormatsColl}) global variable, comes into play.


@ \node{Starting a ``long term''.}

We can observe that \\{nTermBase} is initialized upon construction to \\{TermNbr};
in \\{ProcessAtomicFormula} and \\{StartPrivateFormula} it is assigned to \\{TermNbr}.


\label{extSubexpObj.StartLongTerm}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartLongTerm;
begin
   nArgListNbr:=0;
   nArgList[0].Length:=TermNbr-nTermBase;
end;

@ \node{Malformed term errors.}

We should remind the reader, errors 165--175 are ``unknown functor format'',
errors 176 is ``unknown attribute format'', and error 177 is ``unknown
structure format''. Only when such an error occurs, the flow experiences a
|goto AfterBalance|.

For an example of a 168, 169 error:
\medbreak
{\obeylines\tt
for x being Nat

holds (id + x +) = x;
\par}
\medbreak\noindent%
For an example of a 170, 171 error (the first \texttt{0} will be
flagged 170, the second \texttt{0} will be flagged as 171):
\medbreak
{\obeylines\tt
for x being Nat

holds 0 0 + x = x;

\par}
\medbreak\noindent%
For an example of a 172, 173 error:
\medbreak
{\obeylines\tt
for x being Nat

holds x + / = x;\par}

\medbreak\noindent%
For an example of a 174, 175 error:

\medbreak
{\obeylines\tt
for x being Nat

holds x + (1,2) + x = x;\par}

@ We can recall that a ``generic'' term looks like an infixed operator
of the form
$$ (t^{(\ell)}_{1},\dots,t^{(\ell)}_{m})\;t\;(t^{(r)}_{1},\dots,t^{(r)}_{n}) $$
The parentheses are optional. Constants will have $m=n=0$ and look
like $()\;t\;()$. Function-like terms will have $m=0$ and look like
$()\;t\;(t^{(r)}_{1},\dots,t^{(r)}_{n})$.
The problem statement could be re-phrased as: given several infixed
terms without parentheses inserted anywhere, determine how to cluster
terms together.

@ The problem statement for constructing the syntax tree for a term is
something like the following: we have an expression of the form
$$ x^{(0)}_{1},\dots,x^{(0)}_{k_{0}}\;F_{1}\; x^{(1)}_{1},\dots,x^{(1)}_{k_{1}}\;F_{2}\;\cdots \;F_{n}\; x^{(n)}_{1},\dots,x^{(n)}_{k_{n}}$$
We want to produce a suitable binary tree with $F_{i}$ on the internal
nodes and the $(x^{(i)}_{j})_{j\leq k_{i}}$ on the leafs, respecting
precedence such that each $F_{i}$ is applied to the correct number of arguments.

Mario Carneiro noted (\arXiv{2304.08391}, \section6.2) the existence of an $O(n^{4})$ algorithm using
dynamic programming techniques. The trick is to compute the minimal
``cost'' [number of violations] for each substring of nodes
$F_{a}\cdots F_{b}$ for each $1\leq a\leq i\leq b\leq n$ with node
$F_{i}$ being the root of the subtree. There are $O(n^{3})$ such
subproblems, and they can be calculated from smaller subproblems in $O(n)$.
This might seem alarmingly large, but usually the terms in Mizar are
sufficiently small.

It is interesting to see how other languages tackle this problem, so I
am going to give a haphazard literature review:
\enumerate
\item Nils Anders Danielsson and Ulf Norell's ``Parsing Mixfix Operators''
(in SB.\ Scholz and O.\ Chitil (eds.), \emph{Symposium on Implementation and Application of Functional Languages},
Springer 2008, pp.\ 80--99; \doi{10.1007/978-3-642-24452-0_5})
discuss how Agda approaches parsing mixfix operators with different precedence.
\item The Isabelle proof assistant uses a modified version of Earley
parsing of terms, supporting precedence between 0 to 1000.
\endenumerate

@ The only two place where \\{FinishLongTerm} is invoked is in
the \\{AppendFunc} procedure (\section\xref{AppendFunc:parser.pas})
in \texttt{parser.pas}.

This relies on |MFormatsList.LookUpFuncFormat| (\section\xref{MFormatsList.LookUp_FuncFormat}),
which attempts to look up an \\{MInfixFormatObj}
(\section\xref{MInfixFormatObj}) with a given id number as well as
number of left and right arguments.

We will need to populate |ArgsLength| and |To_Right| to determine the
syntax tree for the term (which is our real goal here). The
|ArgsLength| encodes the number of terms are to the left and right of
each ``internal node''. The |To_Right| controls associativity (which
is how Mizar handles operator precedence): if node $F_{k+1}$ is higher
precedence than node $F_{k}$, then |To_Right(k)| is true.

The |Exchange(i)| procedure will make node $i$ a child of $i-1$
(when node $i$ is a child of $i-1$), and vice-versa. 
Visually, this means we transform the tree as:
$$\bigl(\cdots F_{i-1}\;x_{1},\dots,x_{\ell}\bigr),x_{\ell+1},\dots,x_{n}\; F_{i}\cdots\longleftrightarrow\cdots F_{i-1}\;x_{1},\dots,x_{\ell-1},\bigl(x_{\ell},x_{\ell+1},\dots,x_{n}\; F_{i}\cdots\bigr)$$
Observe that ``|Exchange(i);Exchange(i)|'' is equivalent to doing nothing.

We should recall (\section\xref{extSubexprObj:class})
that \\{nArgList} is an array of ``|record Instance,SymPri: integer; FuncPos: Position; end|''.

\label{extSubexpObj.FinishLongTerm}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishLongTerm;
var
   ArgsLength: array of record l,r: integer; end;
To_Right: array of boolean@t\1@>; 
procedure Exchange(i:integer);
var l: integer;
begin
   l:=ArgsLength[i].l;
   ArgsLength[i].l:=ArgsLength[i-1].r;
   ArgsLength[i-1].r:=l;
   To_Right[i-1]:=not To_Right[i-1];
end; @t\2@>
var
   Bl,new_Bl: integer; {indexes |nFunc|, |ArgsLength|}
   i,j,k: integer; {various indices}
   @<Variables for finishing a long term in a subexpression@>
label Corrected,AfterBalance;@t\2@>
begin
   @<Rebalance the long term tree@>@;
AfterBalance:
   @<Construct the term's syntax tree after balancing arguments among subterms@>
end;

@ \node{Rebalancing the term tree.}

Note that \\{nArgListNbr} is mutated only in \\{extSubexpObj.ProcessFunctorSymbol}
(\section\xref{extSubexpObj.ProcessFunctorSymbol}), and
in \\{ProcessAtomicFormula}
(\section\xref{extSubexpObj.ProcessAtomicFormula}) it is reset to zero.

@d missing_functor_format == gFormatsColl.LookUp_FuncFormat(Instance,l,r) = 0

@<Rebalance the long term tree@>=
   @<Initialize |To_Right| and |ArgsLength| arrays@>@;
   @<Initialize |Bl|, |goto AfterBalance| if term has at most one argument@>@; @/
   {|Bl = 1 or Bl = 2|}
   for k:=2 to nArgListNbr-1 do
      with nFunc[k], ArgsLength[k] do
   begin
      if missing_functor_format then
      @<Guess the $k^{th}$ functor format@>@;
      Corrected:
   end;
   for j:=nArgListNbr downto Bl+1 do
      with nFunc[j], ArgsLength[j] do
   begin
      if not missing_functor_format then goto AfterBalance;
      Exchange(j);
      @<Check for 172/173 error, |goto AfterBalance| if erred@>@;
   end;
   @<Check for 174/175 error, |goto AfterBalance| if erred@>@;

@ @<Check for 172/173 error, |goto AfterBalance| if erred@>=
      if missing_functor_format then
      begin
         Error(FuncPos,172);
         Error(nFunc[nArgListNbr].FuncPos,173);
         goto AfterBalance; @+
      end;

@ @<Check for 174/175 error, |goto AfterBalance| if erred@>=
   with nFunc[Bl], ArgsLength[Bl] do
      if missing_functor_format then
      begin
         Error(FuncPos,174);
         Error(nFunc[nArgListNbr].FuncPos,175);
         goto AfterBalance; @+
      end;

@ We first allocate the arrays, the we initialize the values.

@<Initialize |To_Right| and |ArgsLength| arrays@>=
   setlength(ArgsLength,nArgListNbr+1);
   setlength(To_Right,nArgListNbr+1);
   setlength(Depo,nArgListNbr+1); 

@ The
initial guess depends on whether $F_{k}$ has precedence over $F_{k+1}$
or not.

If $F_{k+1}$ has higher precedence than $F_{k}$, then the initial
guess groups terms as:
$$ \cdots F_{k} \;\;\bigl((x_{1}^{(k)},\dots,x^{(k)}_{m_{k}}) F_{k+1} (\cdots)\bigr)\cdots,\quad\hbox{and}\quad\\{To\_Right}[k]=\\{true}.$$
On the other hand, if $F_{k+1}$ \emph{does not} have higher precedence
than $F_{k}$, then we guess the terms are grouped as
$$ \cdots \bigl(\cdots F_{k} (x_{1}^{(k)},\dots,x^{(k)}_{m_{k}})\bigr)\;\; F_{k+1} \cdots,\quad\hbox{and}\quad\\{To\_Right}[k]=\\{false}.$$
This is a first stab, but sometimes we get lucky and it's correct.

@d next_term_has_higher_precedence(#) == @/
  gPriority.Value(ord('O'),nFunc[#].Instance) < gPriority.Value(ord('O'),nFunc[#+1].Instance)

@<Initialize |To_Right| and |ArgsLength| arrays@>=
   ArgsLength[1].l:=nArgList[0].Length;
   To_Right[0]:=true;
   for k:=1 to nArgListNbr-1 do
      with ArgsLength[k] do
         if next_term_has_higher_precedence(k) then
         begin
            r:=1;
            ArgsLength[k+1].l:=nArgList[k].Length;
            To_Right[k]:=true @+
         end
         else
         begin
            r:=nArgList[k].Length;
            ArgsLength[k+1].l:=1;
            To_Right[k]:=false @+
         end;
   ArgsLength[nArgListNbr].r:=nArgList[nArgListNbr].Length;
   To_Right[nArgListNbr]:=false;

@ The first situation we encounter is if the user tries to tell Mizar
to evaluate something like:

\medbreak
{\obeylines\tt
for x being Nat

holds x + (1,2) = x;
\par}
\medbreak\noindent%
Mizar will not understand ``{\tt x + (1,2)}'' because it is an invalid
functor format --- the format would look something like
$\langle\hbox{``\texttt{+}''}, {\rm left}: 1, {\rm right}: 1\rangle$ but
the format of the expression is $\langle {\rm left}: 1, {\rm right}: 2\rangle$.
The mismatch on the ``right'' values in the formats will raise a 165 error.

For a 166 error example,
\medbreak
{\obeylines\tt
for x being Nat

holds + / = x;
\par}
\medbreak\noindent%
Mizar will not like the leading ``{\tt + /}'' expression, and flag
this with the 166 error.

Mizar will flag ``{\tt + 0}'' as a 165 error.

@<Initialize |Bl|, |goto AfterBalance| if term has at most one argument@>=
   with nFunc[1], ArgsLength[1] do
   begin
      if nArgListNbr = 1 then
      begin
         if missing_functor_format then
         begin
            Error(FuncPos,165);
            goto AfterBalance @+
         end;
         goto AfterBalance;
      end;
      Bl:=1;
      if missing_functor_format then
      begin
         Exchange(2);
         Bl:=2;
         if missing_functor_format then
         begin
            Error(FuncPos,166);
            goto AfterBalance @+
         end;
      end;
   end;

@ @<Guess the $k^{th}$ functor format@>=
      begin
         Exchange(k+1);
         new_Bl:=Bl;
         if missing_functor_format then
         begin
            if Bl = k then
            begin
               Error(nFunc[k-1].FuncPos,168);
               Error(FuncPos,169);
               goto AfterBalance; @+
            end;
            Exchange(k+1);
            Exchange(k);
            new_Bl:=k;
            if missing_functor_format then
            begin
               Exchange(k+1);
               new_Bl:=k+1;
               if missing_functor_format then
               begin
                  Error(FuncPos,167);
                  goto AfterBalance @+
               end;
            end;
            for j:=k-1 downto Bl+1 do
               with nFunc[j], ArgsLength[j] do
            begin
               if not missing_functor_format then goto Corrected;
               Exchange(j);
               if missing_functor_format then
               begin
                  Error(FuncPos,168);
                  Error(nFunc[k].FuncPos,169);
                  goto AfterBalance; @+
               end;
            end;
            @<Check term |Bl| has valid functor format, |goto AfterBalance| if not@>@;
         end;
         Bl:=new_Bl;
      end;

@ @<Check term |Bl| has valid functor format, |goto AfterBalance| if not@>=
            with nFunc[Bl], ArgsLength[Bl] do
               if missing_functor_format then
               begin
                  Error(FuncPos,170);
                  Error(nFunc[k].FuncPos,171);
                  goto AfterBalance; @+
               end;

@ \node{Constructing the syntax tree.} The second half of finishing a
long term constructs the syntax tree for the term.

@<Variables for finishing a long term in a subexpression@>=
   ak,pl,ll,kn: integer;
   lTrm: TermPtr;
   lLeftArgs,lRightArgs: PList;
   DepoNbr: integer;
   Depo: array of record FuncInstNr:integer; dArgList:PList; end;

@ @<Construct the term's syntax tree after balancing arguments among subterms@>=
   @<Initialize symbol priorities, determine last |ll|, |pl| values@>@;
   DepoNbr:=0;
   for kn:=nArgListNbr downto 2 do
      if To_Right[kn-1] then {if |kn| node is parent of |kn-1| node}
      begin
         with nFunc[kn] do
         begin
            lRightArgs:=CreateArgs(nArgList[kn].Start); { (\section\xref{CreateArgs}) }
            lLeftArgs:=CreateArgs(nArgList[kn-1].Start);
            lTrm:=new(InfixTermPtr,Init(FuncPos,Instance,lLeftArgs,lRightArgs));
         end;
         for j:=DepoNbr downto 1 do
            with Depo[j], nFunc[FuncInstNr] do
         begin
            if symPri <= nFunc[kn-1].SymPri then break;
            dec(DepoNbr);
            lLeftArgs:=new(PList,Init(1));
            lLeftArgs^.Insert(lTrm);
            lTrm:=new(InfixTermPtr,Init(FuncPos,Instance,lLeftArgs,dArgList));
         end;
         gLastTerm:=lTrm; @/
         gSubexpPtr^.FinishArgument;
      end
      else
      begin
         inc(DepoNbr);
         with Depo[DepoNbr] do
         begin
            FuncInstNr:=kn;
            dArgList:=CreateArgs(nArgList[kn].Start); @+
         end;
      end;
   with nFunc[1] do
   begin
      lRightArgs:=CreateArgs(nArgList[1].Start);
      lLeftArgs:=CreateArgs(nArgList[0].Start);
      lTrm:=new(InfixTermPtr,Init(FuncPos,Instance,lLeftArgs,lRightArgs));
   end;
   for j:=DepoNbr downto 1 do
      with Depo[j], nFunc[FuncInstNr] do
   begin
      lLeftArgs:=new(PList,Init(1));
      lLeftArgs^.Insert(lTrm);
      lTrm:=new(InfixTermPtr,Init(FuncPos,Instance,lLeftArgs,dArgList));
   end;
   gLastTerm:=lTrm;

@ @<Initialize symbol priorities, determine last |ll|, |pl| values@>=
   for ak:=1 to nArgListNbr do
   begin
      ll:=1;
      pl:=1;
      if To_Right[ak-1] then ll:=nArgList[ak-1].Length;
      if not To_Right[ak] then pl:=nArgList[ak].Length;
      with nFunc[ak] do
      begin
         symPri:=gPriority.Value(ord('O'),Instance); @+
      end;
   end;

@* [s] Processing subexpressions.
Note that \\{ProcessFunctorSymbol} is the only place where
|nArgListNbr| is incremented. Processing functor symbols occurs in the
parser's \\{AppendFunc} (\section\xref{AppendFunc:parser.pas}) in a loop.

\label{extSubexpObj.ProcessFunctorSymbol}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.@!ProcessFunctorSymbol;
var l: integer;
begin
   inc(nArgListNbr);
   if nArgListNbr >= length(nFunc) then
   begin
      l:=2*length(nFunc)+1;
      setlength(nArgList,l);
      setlength(nFunc,l);
   end;
   nArgList[nArgListNbr].Start:=TermNbr+1;
   nFunc[nArgListNbr].FuncPos:=CurPos;
   nFunc[nArgListNbr].Instance:=CurWord.Nr;
end;

@ The Parser is in the middle of \\{AppendFunc} and has just finished
parsing a term $t$ or a tuple of 
terms \hbox{\texttt{(} $t_{1}$, \dots, $t_{n}$ \texttt{)}}. Before the
Parser checks if it's looking at an infixed functor operator or not,
the Parser invokes the \\{FinishArgList} method. It's the only time
where the \\{FinishArgList} method is invoked.

This allocates either 1 or $n$ to the length of |nArgList[nArgListNbr]|,
to store the information for the term(s).

\label{extSubexpObj.FinishArgList}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishArgList;
begin
   nArgList[nArgListNbr].Length:=TermNbr-nArgList[nArgListNbr].Start+1;
end;

@ The Parser is looking at ``\texttt{where}'' or (when the variables
are all reserved) a colon ``\texttt{:}'', the Parser invokes
the \\{StartFraenkelTerm} which will store the previous term in
the \\{nSample} field --- so schematically, the Fraenkel term could
look like
$$\LB\<nSample>\hbox{ \texttt{where} }\<Postqualification> : \<Formula>\RB$$

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartFraenkelTerm;
begin
   nSample:=gLastTerm;
end;

@ This is only invoked in the Parser's \\{ProcessPostqualification}
(\section\xref{ProcessPostqualification}) procedure, which is only
invoked after the Parser calls the \\{extSubexp}
object's \\{StartFraenkelTerm} method.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPostqualification;
begin
   nPostQualList.Init(0);
end;

@ The parser is looking at the post-qualified segment of a Fraenkel
operator. This will be a list of variables ``\texttt{being}'' a type,
we allocate an array for the variables. This is handled by
the \\{StartPostQualifyingSegment} method.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPostQualifyingSegment;
begin
   nSegmentIdentColl.Init(2);
end;

@ While looping over the comma-separated list of variables in a
post-qualified segment (in a Fraenkel term), the Parser invokes
the \\{ProcessPostqualifiedVariable} on each iteration until it has
parsed all the variables. This allocates a new \\{Variable} object,
and pushes it onto the \\{nSegmentIdentColl} ``stack''.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessPostqualifiedVariable;
begin
   nSegmentIdentColl.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end;

@ The parser is looking at ``\texttt{is}'' or ``\texttt{are}'' in a
Fraenkel term's post-qualification segment, but has not yet parsed the
type. This method will assign the \\{nSegmentPos} field to be the
current position, and assign the \\{gLastType} state variable to be
the \&{nil} pointer.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPostqualificationSpecyfication;
begin
   nSegmentPos:=CurPos;
   gLastType:=nil;
end;

@ The Parser has just parsed either (1) a comma-separated list of variables, the
copula ``\texttt{is}'' or ``\texttt{are}'', and the type; or (2) a
comma-separated list of reserved variables (but no copula and no
type). We just need to construct an appropriate node for the abstract
syntax tree. This method will append a new Segment to the \\{nPostQualList}.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishPostQualifyingSegment;
var k: integer;
lSegment: ExplicitlyQualifiedSegmentPtr;
begin
   if gLastType <> nil then
   begin
      lSegment:=new(ExplicitlyQualifiedSegmentPtr,
                    Init(nSegmentPos,new(PList,Init(0)),gLastType));
      nPostQualList.Insert(lSegment);
      for k := 0 to nSegmentIdentColl.Count - 1 do
      begin
         ExplicitlyQualifiedSegmentPtr(lSegment)^.nIdentifiers.Insert(nSegmentIdentColl.Items^[k]);
      end;
   end
   else
   begin
      for k := 0 to nSegmentIdentColl.Count - 1 do
      begin
         nPostQualList.Insert(new(ImplicitlyQualifiedSegmentPtr,
                                  Init(VariablePtr(nSegmentIdentColl.Items^[k])^.nVarPos,
                                       nSegmentIdentColl.Items^[k])));
      end;
   end;
   nSegmentIdentColl.DeleteAll;
   nSegmentIdentColl.Done;
end;

@ The Parser has just finished the formula in a Fraenkel term, and it
is staring at the closet ``$\RB$'' bracket. The Parser invokes this
method to construct a new \\{FraenkelTerm} AST node, and updates
the \\{gLastTerm} to point at it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishFraenkelTerm;
begin
   gLastTerm:=new(FraenkelTermPtr,Init(CurPos,new(PList,MoveList(nPostQualList)),
                                       nSample,gLastFormula));
end;

@ The Parser has already encountered ``\texttt{the set}'' and the next
token is ``\texttt{of}'', which means the Parser has encountered a
``simple'' Fraenkel term of the form ``\texttt{the set of all} \<Term>\dots''.
This method will be invoked once the Parser has stumbled across the
``\texttt{all}''. The caller updates its \\{nAllPos} to the Parser's
current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartSimpleFraenkelTerm;
begin
   nAllPos:=CurPos;
end;

@ The Parser has just finished parsing the post-qualification to the
simple Fraenkel term, which means it has finished parsing the simple
Fraenkel term. This method allocates a new \\{SimpleFraenkelTerm} AST
node with the accumulated AST nodes, then updates the \\{gLastTerm} to
point to the allocated \\{SimpleFraenkelTerm} node.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishSimpleFraenkelTerm;
begin
   gLastTerm:=new(SimpleFraenkelTermPtr,Init(nAllPos,new(PList,MoveList(nPostQualList)),nSample));
end;

@ The Parser is looking at a closed term of the form ``\<Identifier> \texttt{(}\dots'',
and so it looks like a private functor. This method updates the
caller's \\{nSubexpPos} to the Parser's current position, and
the \\{nSpelling} is assigned to the identifier's number (for the
private functor).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPrivateTerm;
begin
   nSubexpPos:=CurPos;
   nSpelling:=CurWord.Nr;
end;

@ The Parser just finished parsing all the arguments to the private
functor, and is looking at the closing parentheses for the private
functor. This method allocates a new \\{PrivateFunctorTerm} object,
using the arguments just parsed, and updates the \\{gLastTerm} state
variable to point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishPrivateTerm;
begin
   gLastTerm:=new(PrivateFunctorTermPtr,Init(nSubexpPos,nSpelling,CreateArgs(nTermBase+1)));
end;

@ The Parser has just encountered either a left bracket term or the
opening left bracket for a set ``$\LB$''. The Parser calls this
method, which just updates the caller's \\{nSymbolNr} to be whatever
the current token's numeric ID value is.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartBracketedTerm;
begin
   nSymbolNr:=CurWord.Nr;
end;

@ If the Parser is in panic mode, this method does nothing.

Either the Parser has finished parsing an enumerated set
$\LB\,x_{1},\dots,x_{n}\,\RB$ or a bracketed term. We need to double
check the format for the bracket matches what is stored in
the \\{gFormatsColl}, and raise a 152 error if there's a
mismatch. Otherwise, allocate a new AST node for the bracketed term,
and use \\{CreateArgs} on the terms contained within the brackets.

@^Error, 152@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishBracketedTerm;
var lFormatNr: integer;
begin
   if StillCorrect then
   begin
      nRSymbolNr:=CurWord.Nr;
      lFormatNr:=gFormatsColl.LookUp_BracketFormat(nSymbolNr,nRSymbolNr,TermNbr-nTermBase,0,0);
      if lFormatNr=0 then SemErr(152);
      gLastTerm:=new(CircumfixTermPtr, Init(CurPos,nSymbolNr,nRSymbolNr,CreateArgs(nTermBase+1)));
   end;
end;

@ Remember that Mizar calls ``an instance of structure''
an \define{Aggregate}. When the Parser is parsing for a closed subterm
and has stumbled across a structure constructor (\section\xref{ClosedSubter:structure:parser.pas}), it first invokes this
method. This stores the ID number for the structure in the
caller's \\{nSymbolNr}. 

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartAggregateTerm;
begin
   nSymbolNr:=CurWord.Nr;
end;

@ The Parser has just parsed the arguments for the structure
constructor, and the Parser is now looking at the ``\texttt{\#)}''
token. This method is invoked.

We should check the format for the structure constructor is stored in
the \\{gFormatsColl}. If not, raise a 176 error. Otherwise, we
allocate a new \\{AggregateTerm} with the parsed arguments, and then
update the \\{gLastTerm} pointer to point at it.

@^Error, 176@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishAggregateTerm;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.LookUp_PrefixFormat('G',nSymbolNr,TermNbr-nTermBase);
   if lFormatNr = 0 then Error(CurPos,176); {missing format error}
   gLastTerm:=new(AggregateTermPtr, Init(CurPos,nSymbolNr,CreateArgs(nTermBase+1)));
end;

@ The Parser is parsing for a closed subterm, and has stumbled across
``\texttt{the}'' and is looking at a selector token
(\section\xref{GetClosedSubterm:the:parser.pas}). This method is
invoked. We assign the caller's \\{nSymbolNr} to the ID number for the
selector token, assign the caller's \\{nSubexpPos} to the Parser's
current position, and store the next token's kind (i.e., the
``\texttt{of}'' token's kind) in the \\{nNextWord}
field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartSelectorTerm;
begin
   nSymbolNr:=CurWord.Nr;
   nSubexpPos:=CurPos;
   nNextWord:=AheadWord.Kind;
end;

@ The Parser has just parsed ``\texttt{the} \<Selector> \texttt{of} \<Term>''.
Now this method is invoked to assemble the parsed data into an AST
node.

If there is no selector with this matching format, then a 182 error
will be raised.

If the caller's \\{nNextWord} is an ``\texttt{of}'' token's kind, then
we're describing a selector term. We update the \\{gLastTerm} state
variable to point to a newly allocated \\{SelectorTerm} object with
the appropriate data set.

On the other hand, \define{internal selectors} occur when defining a
structure. For example,

\smallbreak
{\tt\obeyspaces\obeylines\parindent=0pt\advance\leftskip3pc
\noindent struct (1-sorted) multMagma \hbox{(\#}

\quad carrier -> set,

\quad multF -> BinOp of the carrier

\ \hbox{\#);}
\par}

\smallbreak\noindent%
Observe the \texttt{multF} specification is \texttt{BinOp of the carrier}.
That ``\texttt{the carrier}'' is an internal selector. In this case,
allocate a new \\{InternalSelectorTerm} object, and update
the \\{gLastTerm} state variable to point to it.

If, for some reason, the Parser is in neither situation, then
just \\{gLastTerm} state variable to be an incorrect term.

@^Error, 182@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishSelectorTerm;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.LookUp_PrefixFormat('U',nSymbolNr,1);
   if lFormatNr = 0 then Error(nSubexpPos,182); {missing format error}
   if nNextWord = sy_Of then
      gLastTerm:=new(SelectorTermPtr, Init(nSubexpPos,nSymbolNr,gLastTerm))
   else
      if in_AggrPattern then
         gLastTerm:=new(InternalSelectorTermPtr, Init(nSubexpPos,nSymbolNr))
      else
      begin
         gLastTerm:=new(IncorrectTermPtr, Init(nSubexpPos));
         Error(nSubexpPos,329)
      end;
end;

@ The Parser is about to start parsing a forgetful functor
(\section\xref{GetClosedSubterm:forgetful-functor:parser.pas}) --- for
example ``\texttt{the multMagma of REAL.TopGroup}''. This
method is invoked. The caller's \\{nSymbolNr} field is updated to the
current token's ID Number, the \\{nSubexpPos} field is assigned the
Parser's current position, and the \\{nNextWord} field is assigned to
the token kind of the next token --- this is expected to be ``\texttt{of}''.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartForgetfulTerm;
begin
   nSymbolNr:=CurWord.Nr;
   nSubexpPos:=CurPos;
   nNextWord:=AheadWord.Kind;
end;

@ The Parser just finished parsing a forgetful functor. If the Parser
is not panicking, check the format for the forgetful functor matches
what is stored in the \\{gFormatsColl} state variable. If the format
is invalid, raise a 184 error.

Whether the Parser is panicking or not, allocate a
new \\{ForgetfulFunctor} term, and update the \\{gLastTerm} to point
to it.

@^Error, 184@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishForgetfulTerm;
var lFormatNr: integer;
begin
   lFormatNr:=0;
   if StillCorrect then
   begin
      lFormatNr:=gFormatsColl.LookUp_PrefixFormat('J',nSymbolNr,1);
      if lFormatNr = 0 then Error(nSubexpPos,184); {missing format}
   end;
   gLastTerm:= new(ForgetfulFunctorTermPtr, Init(nSubexpPos,nSymbolNr,gLastTerm));
end;

@ There are several situations where this is invoked:
\enumerate
\item The Parser has just parsed ``\texttt{the}'' but is not looking
  at a selector symbol (``\texttt{the multF of}\dots''), nor is the
  Parser looking at a forgetful functor (``\texttt{the multMagma of}\dots'').
  Then this is interpreted as looking at a choice operator
  (\section\xref{GetClosedSubterm:the:parser.pas}).
\item The Parser has just parsed ``\texttt{the}'' but is not looking
  at a forgetful functor, so the Parser believes it must be looking at
  a choice operator
  (\section\xref{GetClosedSubterm:forgetful-functor:parser.pas}). 
\item The Parser has just parsed ``\texttt{the}'' and is now looking
  at ``\texttt{set}'' --- so this is invoking the axiom of choice to
  pick ``\texttt{the set}'' (\section\xref{ParseSimpleFraenkelExprOrTheSet:parser.pas}).
\endenumerate
\smallbreak\noindent%
In these three situations, the Parser invokes this method. It just
updates the caller's \\{nSubexpPos} field to point to the Parser's
current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartChoiceTerm;
begin
   nSubexpPos:=CurPos;
end;

@ The Parser has just parsed a type, and now believes it has finished
parsing a choice expression. Then it invokes this method to construct
an appropriate AST node for the term, by specifically allocating a
new \\{ChoiceTerm} for the \\{gLastType} type. We then update
the \\{gLastTerm} state variable to point to this newly allocated term.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishChoiceTerm;
begin
   gLastTerm:=new(ChoiceTermPtr,Init(nSubexpPos,gLastType));
end;

@ When the Parser encounters a numeral while seeking a closed subterm
(\section\xref{GetClosedSubterm:parser.pas}), it invokes this method
to allocate a new \\{NumeralTerm}. The \\{gLastTerm} state variable is
updated to point to this newly allocated numeral object.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessNumeralTerm;
begin
   gLastTerm:=new(NumeralTermPtr, Init(CurPos,CurWord.Nr));
end;

@ The Parser tries to parse a closed subterm
(\section\xref{GetClosedSubterm:parser.pas}) and encounters the
``\texttt{it}'' token. Well, if the |it_Allowed| state variable is
true, then we should allocate a new \\{ItTerm} and update
the \\{gLastTerm} state variable to point to it.

Otherwise, when the |it_Allowed| state variable is false, we should
raise a 251 error.

@^Error, 251@>
@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessItTerm;
begin
   if it_Allowed then gLastTerm:=new(ItTermPtr, Init(CurPos))
   else
   begin
      gLastTerm:=new(IncorrectTermPtr, Init(CurPos));
      ErrImm(251)
   end;
end;

@ The Parser tries parsing for a closed subterm and has encountered a
placeholder term for a private functor (e.g., ``\texttt{\$1}''). If
the |dol_Allowed| state variable is true, then allocate a
new \\{PlaceholderTerm} object and update the \\{gLastTerm} state
variable to point at it.

If the |dol_Allowed| state variable is false, then we should raise a
181 error.

@^Error, 181@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessLocusTerm;
begin
   if dol_Allowed then
      gLastTerm:=new(PlaceholderTermPtr, Init(CurPos,CurWord.Nr))
   else
   begin
      gLastTerm:=new(IncorrectTermPtr, Init(CurPos));
      ErrImm(181)
   end;
end;

@ Calamity! An incorrect expression has crossed the Parser's
path. Allocate an \\{IncorrectTerm} object located at the Parser's
current position, then update the \\{gLastTerm} state variable to
point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.InsertIncorrTerm;
begin
   gLastTerm:=new(IncorrectTermPtr, Init(CurPos));
end;

@* [s] Parsing formulas.
The Parser is trying to parse an atomic formula
(\section\xref{CompleteAtomicFormula:parser.pas}), but something has
gone awry. Allocate a new \\{IncorrectFormula} object located at the
Parser's current position, update the \\{gLastFormula} state variable
to point to it, and ``reset'' the \\{TermNbr} state variable to point
to where the caller's \\{nTermBase} is located.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.InsertIncorrBasic;
begin
   gLastFormula:=new(IncorrectFormulaPtr,Init(CurPos));
   TermNbr:=nTermBase;
end;

@ While the Parser was trying to parse a formula, it found something
which ``doesn't quite fit''. Allocate a new \\{IncorrectFormula}
object, then update the \\{gLastFormula} state variable to point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.InsertIncorrFormula;
begin
   gLastFormula:=new(IncorrectFormulaPtr,Init(CurPos));
end;

@ If we are in a proof, allocate a new \\{ThesisFormula} object
(recall the \WEB/ macro for this \section\xref{thesis-formula:macro-def}).
Otherwise, raise a 65 error.

@:Error, 065}{Error, 65@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessThesis;
begin
   if gProofCnt > 0 then
      gLastFormula:=thesis_formula
   else
   begin
      ErrImm(65);
      gLastFormula:=new(IncorrectFormulaPtr,Init(CurPos));
   end;
end;

@ The Parser has encountered ``\<Term> \texttt{is}'', or some other
generic atomic formula
(\section\xref{CompleteAtomicFormula:parser.pas}), this method is invoked.

If more than one term appears before the ``\texttt{is}'' token (i.e.,
if |TermNbr - nTermBase <> 1|), then a 157 error is raised.
There is a Polish comment here, ``Trzeba chyba wstawic recovery dla |TermNbr = nTermBase|'',
which I translated to English.

This will initialize the fields for the caller in preparation for
parsing some atomic formula.
In particular, this is the only place where \\{TermNbr} is initialized
to a nonzero value (and isn't in an incorrect formula).

@^Error, 157@>

\label{extSubexpObj.ProcessAtomicFormula}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.@!ProcessAtomicFormula;
const MaxArgListNbr = 20;
begin
   nSubexpPos:=CurPos;
   nSymbolNr:=0;
   case CurWord.Kind of
      sy_Is:
         if TermNbr - nTermBase <> 1 then
         begin
            ErrImm(157);
            TermNbr:=nTermBase;
            InsertIncorrTerm;
            FinishArgument;
            { I think you need to insert recovery for |TermNbr = nTermBase| }
         end;
   endcases; @/
   nRightArgBase:=TermNbr;
   nTermBase:=TermNbr;
   nPostNegated:=false;
   nArgListNbr:=0;
   nArgList[0].Start:=TermNbr+1;
end;

@ The Parser is either finishing a ``predicative formula'' (\section\xref{CompletePredicativeFormula:parser.pas}) or it's parsing a predicate pattern (\section\xref{GetPredPattern:parser.pas}),
it invokes this method to initialize the fields needed when forming an
AST node. Specifically, the \\{nSubexpPos} is assigned to the Parser's
current position, the \\{nSymbolNr} is updated either to the current
token's ID number (if the current token is ``\texttt{=}'' or a
predicate) or else assigned to be zero. Last, the \\{nRightArgBase} is
assigned to equal the \\{TermNbr} state variable.

\label{extSubexpObj.ProcessPredicateSymbol}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessPredicateSymbol;
begin
   nSubexpPos:=CurPos;
   case CurWord.Kind of
      sy_Equal,PredicateSymbol: nSymbolNr:=CurWord.Nr;
   othercases nSymbolNr:=0;
   endcases; @/
   nRightArgBase:=TermNbr;
end;

@ The Parser is parsing a ``predicate formula'' which has arguments on
the righthand side of the predicate symbol (\section\xref{CompleteRightSideOfThePredicativeFormula:parser.pas}).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessRightSideOfPredicateSymbol;
begin
   nRightSideOfPredPos:=CurPos;
   case CurWord.Kind of
      sy_Equal,PredicateSymbol: nSymbolNr:=CurWord.Nr;
   othercases nSymbolNr:=0;
   endcases; @/
   nRightArgBase:=TermNbr;
end;

@ The Parser has just finished a ``predicate formula''
(\section\xref{CompletePredicativeFormula:parser.pas}), then this
method is invoked to construct an AST for the formula. First we check
if the format is valid. If the format for the formula is not found in
the \\{gFormatsColl}, then we must raise a 153 error.
Otherwise, we construct two lists (one for the left arguments, another
for the right arguments), and use them to construct a
new \\{PredicativeFormula} object. We update the \\{gLastFormula}
state variable to point to the newly allocated formula object.

@^Error, 153@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishPredicativeFormula;
var lLeftArgs,lRightArgs: PList;
lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.LookUp_PredFormat(nSymbolNr,nRightArgBase-nTermBase,TermNbr-nRightArgBase);
   if lFormatNr = 0 then Error(nSubexpPos,153); {missing format}
   lRightArgs:=CreateArgs(nRightArgBase+1);
   lLeftArgs:=CreateArgs(nTermBase+1);
   gLastFormula:=new(PredicativeFormulaPtr,Init(nSubexpPos,nSymbolNr,lLeftArgs,lRightArgs));
end;

@ The Parser tries to construct an AST when finishing up the
right-hand side of a predicative formula
(\section\xref{CompleteRightSideOfThePredicativeFormula:parser.pas}),
it invokes this method after the \\{extSubexpObj.FinishPredicativeFormula}
has been invoked.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishRightSideOfPredicativeFormula;
var lRightArgs: PList;
lLeftArgsNbr,lFormatNr: integer;
lFrm:FormulaPtr;
begin
   lFrm:=gLastFormula;
   if lFrm^.nFormulaSort = wsNegatedFormula then
      lFrm:=NegativeFormulaPtr(lFrm)^.nArg;
   lLeftArgsNbr:=RightSideOfPredicativeFormulaPtr(lFrm)^.nRightArgs^.Count;
   lFormatNr:=gFormatsColl.LookUp_PredFormat(nSymbolNr,lLeftArgsNbr,TermNbr-nRightArgBase);
   if lFormatNr = 0 then Error(nSubexpPos,153); {missing format}
   lRightArgs:=CreateArgs(nRightArgBase+1);
   gLastFormula:=new(RightSideOfPredicativeFormulaPtr,Init(nSubexpPos,nSymbolNr,lRightArgs));
   nMultiPredicateList.Insert(gLastFormula);
end;

@ When the Parser is parsing an atomic formula, when it has parsed a
formula and encounters another predicate, it defaults to
thinking that it is starting a ``multi-predicative formula''
(\section\xref{CompleteMultiPredicativeFormula:parser.pas}), and it
invokes this method. This initializes the \\{nMultiPredicateList} to
an empty list of length 4, and the first entry points to the same
formula pointed to by the \\{gLastFormula} state variable.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartMultiPredicativeFormula;
begin
   nMultiPredicateList.Init(4);
   nMultiPredicateList.Insert(gLastFormula);
end;

@ Finishing a ``multi-predicative formula'' allocates a
new \\{MultiPredicativeFormula} object, and moves the contents of the
caller's \\{nMultiPredicateList} to the newly minted
formula. The \\{gLastFormula} state variable is updated to point to
this newly allocated formula object.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishMultiPredicativeFormula;
begin
   gLastFormula:=new(MultiPredicativeFormulaPtr,Init(nSubexpPos,new(PList,MoveList(nMultiPredicateList))));
end;

@ The Parser has just parsed ``\<Term> \texttt{is} \<Type>'', and now
we need to store the accumulated data into a Formula AST. Of course,
if the \\{gLastType} variable is not pointing to a type object, then
we should raise an error (clearly something has gone wrong somewhere).

If we have accumulated attributes while parsing, then we should update
the \\{gLastType} to be a clustered type object (and we should move
the attributes over).

We should allocate a \\{QualifiedFormula} object, update
the \\{gLastFormula} state variable to point to it. If the Parser has
encountered ``\<Term> \texttt{is not} \<Type>'', then it will tell the
caller to toggle the \\{nPostNegated} to be true --- and in that case,
we should negate the \\{gLastFormula} state variable.

We mutate the \\{TermNbr} state variable, decrementing it by one
(since we consumed the top of the term stack).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishQualifyingFormula;
var j: integer;
begin
   mizassert(5430,gLastType <> nil);
   if nAttrCollection.Count > 0 then
   begin
      gLastType:=new(ClusteredTypePtr,
                     Init(gLastType^.nTypePos,new(PList,Init(nAttrCollection.Count)),gLastType));
      for j := 0 to nAttrCollection.Count-1 do
         ClusteredTypePtr(gLastType)^.nAdjectiveCluster^.Insert(PObject(nAttrCollection.Items^[j]));
   end;
   gLastFormula:=new(QualifyingFormulaPtr,Init(nSubexpPos,Term[TermNbr],gLastType));
   if nPostNegated then
      gLastFormula:=new(NegativeFormulaPtr,Init(nNotPos,gLastFormula));
   dec(TermNbr);
end;

@ The Parser has just finished parsing ``\<Term> \texttt{is} \<Attribute>''
or ``\<Term> \texttt{is not} \<Attribute>'', and so it invokes this
method. We allocate a new \\{AttributiveFormula} object, and negate it
if needed. We also decrement the \\{TermNbr} state variable (since we
consumed one element of the term stack).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishAttributiveFormula;
begin
   gLastFormula:=
      new(AttributiveFormulaPtr,Init(nSubExpPos,Term[TermNbr],new(PList,MoveList(nAttrCollection))));
   if nPostNegated then
      gLastFormula:=new(NegativeFormulaPtr,Init(nNotPos,gLastFormula));
   dec(TermNbr);
end;

@ While the Parser is working its way through a formula, and it is
looking at an identifier and the next token is a square bracket
``\texttt{[}'', then the Parser invokes this method to initialize the
relevant fields to store accumulated data.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPrivateFormula;
begin
   nTermBase:=TermNbr;
   nSubexpPos:=CurPos;
   nSpelling:=CurWord.Nr;
end;

@ The Parser has just encountered ``\texttt{]}'' and now we assemble
the accumulated data into a formula. This allocates a
new \\{PrivatePredicativeFormula}, moves the arguments encountered
since starting the private predicate into a list
(\section\xref{CreateArgs}) owned by the formula
object. The \\{gLastFormula} is updated to point to the newly
allocated formula object.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishPrivateFormula;
begin
   gLastFormula:=new(PrivatePredicativeFormulaPtr,Init(nSubexpPos,nSpelling,CreateArgs(nTermBase+1)));
end;

@ The Parser has encountered the ``\texttt{contradiction}'' token, so
it invokes this method, which allocates a \\{ContradictionFormula} and
updates the \\{gLastFormula} state variable to point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessContradiction;
begin
   gLastFormula:=new(ContradictionFormulaPtr,Init(CurPos));
end;

@ The Parser routinely allocates a formula object, then realizes later
it should negate that formula object. This is handled by storing the
formula object in the \\{gLastFormula} object, then this method
allocates a new formula (which is the negation of
the \\{gLastFormula}) and updates the \\{gLastFormula} to point to the
newly allocated negated formula.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessNegative;
begin
   gLastFormula:=new(NegativeFormulaPtr,Init(CurPos,gLastFormula));
end;

@ When the Parser has encountered the ``\texttt{not}'' reserved
keyword, it invokes the \\{ProcessNegation} method which just toggles
the \\{nPostNegated} field of the caller, and assigns the \\{nNotPos}
field to the Parser's current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessNegation;
begin
   nPostNegated:=not nPostNegated;
   nNotPos:=CurPos;
end;

@ When the Parser is looking at a binary connective token
(e.g., ``\texttt{implies}'', ``\texttt{or}'', etc.), this method is
invoked to store the connective kind as well as the ``left-hand side'' to the
binary connective in the \\{nFirstSententialOperand} field. 

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessBinaryConnective;
begin
   nConnective:=CurWord.Kind;
   nFirstSententialOperand:=gLastFormula;
   nSubexpPos:=CurPos;
end;

@ The Parser has seen ``\<Formula> \texttt{or} \texttt{...} \texttt{or}''. 
Then this method will be invoked to store that first formula parsed in
the caller's \\{nFirstSententialOperand} field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessFlexDisjunction;
begin
   nFirstSententialOperand:=gLastFormula;
end;

@ The Parser has seen ``\<Formula> \texttt{\AM} \texttt{...} \texttt{\AM}''. 
Then this method will be invoked to store that first formula parsed in
the caller's \\{nFirstSententialOperand} field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessFlexConjunction;
begin
   nFirstSententialOperand:=gLastFormula;
end;

@ The Parser has parsed ``\texttt{for} \<Qualified-Variables> \texttt{st}'',
and it is staring at the ``\texttt{st}'' token. Then it will invoke
this method to mark the \\{nRestrPos}, setting it equal to the
Parser's current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartRestriction;
begin
   nRestrPos:=CurPos;
end;

@ The Parser has just parsed the formula appearing after
``\texttt{st}'', so this method is invoked to store that formula in
the caller's \\{nRestriction} field (for later use when constructing
an AST).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishRestriction;
begin
   nRestriction:=gLastFormula;
end;

@ The Parser has finished parsing a formula involving binary
connectives, then it invokes this method to construct the formula AST.

If somehow the connective is not ``\texttt{implies}'',
``\texttt{iff}'', ``\texttt{or}'', or ``\texttt{\AM}'', then we should
raise an error.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishBinaryFormula;
begin
   case nConnective of
      sy_Implies:
         gLastFormula:=new(ConditionalFormulaPtr,Init(nSubExpPos,nFirstSententialOperand,gLastFormula));
      sy_Iff:
         gLastFormula:=new(BiconditionalFormulaPtr,Init(nSubexpPos,nFirstSententialOperand,gLastFormula));
      sy_Or:
         gLastFormula:=new(DisjunctiveFormulaPtr,Init(nSubexpPos,nFirstSententialOperand,gLastFormula));
      sy_Ampersand:
         gLastFormula:=new(ConjunctiveFormulaPtr,Init(nSubexpPos,nFirstSententialOperand,gLastFormula));
   othercases
      RunTimeError(3124);
   endcases;
end;

@ We have parsed ``\<Formula> \texttt{or ... or} \<Formula>'', and the
Parser invokes this method to construct an AST for the formula. This
method allocates a new \\{FlexaryDisjunctive} formula object, and
updates the \\{gLastFormula} state variable to point to it.

There is a comment in Polish, ``polaczyc z flexConj'', which Google
translates to ``connect to flexConj''.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishFlexDisjunction; {polaczyc z flexConj}
begin
   gLastFormula:=new(FlexaryDisjunctiveFormulaPtr,
                     Init(CurPos,nFirstSententialOperand,gLastFormula));
end;

@ We have parsed ``\<Formula> \texttt{\AM\ ... \AM} \<Formula>'', and
the Parser invokes this method to construct an AST for the
formula. This allocates a new \\{FlexaryConjunctive} formula object,
and updates the \\{gLastFormula} state variable to point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishFlexConjunction;
begin
   gLastFormula:=new(FlexaryConjunctiveFormulaPtr,
                     Init(CurPos,nFirstSententialOperand,gLastFormula));
end;

@ The Parser is looking at the ``\texttt{ex}'' token, then invokes
this method to reset the caller's fields in preparation for
accumulating data needed when constructing the formula's AST.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartExistential;
begin
   nQualifiedSegments.Init(0);
   nSubexpPos:=CurPos;
end;

@ The Parser is looking at the ``\texttt{for}'' token, and it invokes
this method to reset the relevant fields in the caller.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartUniversal;
begin
   nQualifiedSegments.Init(0);
   nSubexpPos:=CurPos;
end;

@ After the Parser has invoked \\{StartUniversal}
or \\{StartExistential}, it parses the quantified variables (which
begins by invoking this method).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartQualifiedSegment;
begin
   nSegmentIdentColl.Init(2);
   nSegmentPos:=CurPos;
end;

@ The Parser has parsed a comma-separated list and is expecting either
``\texttt{be}'' or ``\texttt{being}'', but before parsing for that
copula the Parser invokes the \\{StartQualifyingType} method to update
the \\{gLastType} state variable to point to \&{nil}.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartQualifyingType;
begin
   gLastType:=nil;
end;

@ The Parser has just finished parsing quantified variables. There are
two possible situations:
\enumerate
\item We have just parsed reserved variables, so the types are all
known. Then the |gLastType = nil|.
\item We have parsed an explicitly typed list of variables, so the
|gLastType <> nil|.
\endenumerate

\smallbreak\noindent In the first case, we should allocate
an \\{ImplicitlyQualifiedSegment} object and move all the segment's
identifiers to this object. Then we clean up the
caller's \\{nSegmentIdentColl} field (since it's an array of \&{nil}
pointers). 

In the second case, we can just move the identifiers when allocating a
new \\{ExplicitlyQualifiedSegment} object.

In both cases, the new allocated \\{QuantifiedSegment} object is
appended to the caller's \\{nQualifiedSegments} field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishQualifiedSegment;
var k: integer;
begin
   if gLastType = nil then
   begin
      for k := 0 to nSegmentIdentColl.Count - 1 do
      begin
         nQualifiedSegments.Insert(new(ImplicitlyQualifiedSegmentPtr,
                                       Init(VariablePtr(nSegmentIdentColl.Items^[k])^.nVarPos,
                                            nSegmentIdentColl.Items^[k])));
         nSegmentIdentColl.Items^[k]:=nil;
      end;
      nSegmentIdentColl.Done;
   end
   else
   begin
      nQualifiedSegments.Insert(new(ExplicitlyQualifiedSegmentPtr,
                                    Init(nSegmentPos,new(PList,MoveList(nSegmentIdentColl)),gLastType)));
   end;
end;

@ When the Parser is parsing quantified variables, specifically when
it is parsing a comma-separated list of variables, it will invoke this
method, then check if the next token is a comma (and if so
iterate). This \\{ProcessVariable} method should accumulate
a \\{Variable} object with the current token's identifier, then insert
it into the caller's \\{nSegmentIdentColl} field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessVariable;
begin
   nSegmentIdentColl.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end;

@ The Parser has just finished something like
$$\hbox{\texttt{ex }} \<Qualified-Variables>\hbox{ \texttt{,} }\dots\hbox{ \texttt{,} }\<Qualified-Variables>\hbox{ \texttt{st} }\<Formula>$$
Now we assemble it as
$$\hbox{\texttt{ex }} \<Qualified-Variables>\hbox{ \texttt{st} }\bigl(\hbox{\texttt{ex }}\dots\hbox{ \texttt{st} }(\hbox{\texttt{ex} }\<Qualified-Variables>\hbox{ \texttt{st} }\<Formula>)\bigr)$$
starting with the innermost existentially quantified formula, working
our ways outwards.

Importantly, assembling the AST reflects the quantified variables has
the grammar

\smallbreak
{\obeylines\parindent=0pt\advance\leftskip3pc

\<Qualified-Variables> = \<Implicitly-Qualified-Variables>

\hskip3pc\pipe\ \<Explicitly-Qualified-Variables>

\hskip3pc\pipe\ \<Explicitly-Qualified-Variables> \texttt{","} \<Implicitly-Qualified-Variables>
\par}

\smallbreak\noindent%


@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishExistential;
var k:integer;
begin
   for k:=nQualifiedSegments.Count-1 downto 1 do {from inside outwards}
   begin
      gLastFormula:=new(ExistentialFormulaPtr,
                        Init(QualifiedSegmentPtr(nQualifiedSegments.Items^[k])^.nSegmPos,
                             nQualifiedSegments.Items^[k],gLastFormula));
      nQualifiedSegments.Items^[k]:=nil;
   end;
   if nQualifiedSegments.Count > 0 then
   begin
      gLastFormula:=new(ExistentialFormulaPtr,
                        Init(nSubexpPos,nQualifiedSegments.Items^[0],gLastFormula));
      nQualifiedSegments.Items^[0]:=nil;
   end;
   nQualifiedSegments.Done;
end;

@ Universally quantified formulas first transforms
$$\hbox{\texttt{for }}\<Qualified-Variables>\hbox{ \texttt{st} }\<Formula>_{1} \hbox{ \texttt{holds} }\<Formula>_{2}$$
into
$$\hbox{\texttt{for }}\<Qualified-Variables>\hbox{ \texttt{holds} }\<Formula>_{1} \hbox{ \texttt{implies} }\<Formula>_{2}$$
which is handled immediately.

The remainder of the method iteratively constructs the universally
quantified formulas by ``unrolling'' the qualified segments, just as
we did for existentially quantified formulas.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishUniversal;
var k:integer;
begin
   if nRestriction <> nil then {transform \texttt{st} into \texttt{implies}}
      gLastFormula:=new(ConditionalFormulaPtr,Init(nRestrPos,nRestriction,gLastFormula));
   for k:=nQualifiedSegments.Count-1 downto 1 do
   begin
      gLastFormula:=new(UniversalFormulaPtr,
                        Init(QualifiedSegmentPtr(nQualifiedSegments.Items^[k])^.nSegmPos,
                             nQualifiedSegments.Items^[k],gLastFormula));
      nQualifiedSegments.Items^[k]:=nil;
   end;
   if nQualifiedSegments.Count > 0 then
   begin
      gLastFormula:=new(UniversalFormulaPtr,
                        Init(nSubexpPos,nQualifiedSegments.Items^[0],gLastFormula));
      nQualifiedSegments.Items^[0]:=nil;
   end;
end;

@* [S] Extended expression class.
When an expression is needed, the \\{gExpPtr} state variable is used
to build it out of subexpressions. The \\{gExpPtr} state variable is
an instance of the \\{extExpression} class.

@<Extended expression class declaration@>=
   extExpressionPtr = ^extExpressionObj; @/
   extExpressionObj = object(ExpressionObj) @t\1@>
      constructor Init(fExpKind:ExpKind); @t\2@>
      procedure CreateSubexpression; virtual; @t\2\2\2@>
   end;

@ \node{Constructor.} This just invokes the parent class's constructor
(\section\xref{ExpressionObj.Init}), then resets the module-wide
variable \\{TermNbr} to zero.

@<Extended expression implementation@>=
constructor extExpressionObj.Init(fExpKind:ExpKind);
begin
   inherited Init(fExpKind);
   TermNbr:=0;
end;

@ An \\{extExpression} creating a subexpression \emph{overrides} the
parent class's method (\section\xref{ExpressionObj.CreateSubexpression}),
and sets the global \\{gSubexpPtr} to point to a new \\{extSubexp}
object.

\label{extExpressionObj.CreateSubexpression}

@<Extended expression implementation@>=
procedure extExpressionObj.CreateSubexpression;
begin
   gSubexpPtr:=new(extSubexpPtr,Init)
end;


@* [F] Parser.
The parser has a ``big red button'': a single ``obvious'' function for
the user to, you know, push. Namely, the |Parse| procedure
(\section\section\xref{parser.pas::Parse} \emph{et seq.}). Everything else is just a helper
function.

The design of the parser appears to be a recursive descent parser on
statements, with parsing expressions handled specially.

Note that the \texttt{base/parser.pas} file appears to be naturally
divided up into sections, with comments which appear to use the
Germanic ``s~p~a~c~i~n~g \ f~o~r \ i~t~a~l~i~c~s'' (which I have just
replaced with more readable \emph{italicized} versions). I have used
these cleavages to organize the discussion of this file.

The |StillCorrect| global variable is \\{false} when the parser has
entered what programmers call \define{Panic Mode}: something has gone
awry, and the parser is trying to recover gracefully. For a friendly
review of panicking, see Bob Nystrom's \emph{Crafting Interpreters}
(\href{https://craftinginterpreters.com/parsing-expressions.html}{Chaper~6}, Section~3).

@^Panic mode@>

@<parser.pas@>=
@<GNU License@>
unit parser;

interface @|@#

uses mscanner; @#

var StillCorrect: boolean = true; @#

type ReadTokenProcedure = Procedure; @#

const ReadTokenProc: ReadTokenProcedure = ReadToken; {from mscanner.pas}

procedure Parse; @t\2@>
procedure SemErr(fErrNr: integer); @t\2@>

implementation @|@#

uses syntax,errhan,pragmas
mdebug ,info @+end_mdebug;

@<Implementation of parser.pas@>@;

@ We have a few constants, but the implementation is loosely organized
around parsing expressions (terms and formulas), statements, and then
blocks.


@<Implementation of parser.pas@>=
@<Local constants for parser.pas@>;

@<Parse expressions (\texttt{parser.pas})@>@;

@<Communicate with items (\texttt{parser.pas})@>@;

@<Process miscellany (\texttt{parser.pas})@>@;

@<Parse simple justifications (\texttt{parser.pas})@>@;

@<Parse statements and reasoning (\texttt{parser.pas})@>@;

@<Parse patterns (\texttt{parser.pas})@>@;

@<Parse definitions (\texttt{parser.pas})@>@;

@<Parse scheme block (\texttt{parser.pas})@>@;

@<Main parse method (\texttt{parser.pas})@>@;

@ We have error codes for syntactically invalid situations. These are
all different ways for panic to occur (hence the ``pa-'' prefix).

@<Local constants for parser.pas@>=
const
   paUnexpOf             = 183;
   paUnexpOver           = 184;
   paUnexpEquals         = 186;
   paUnexpAntonym1       = 198;
   paUnexpAntonym2       = 198;
   paUnexpSynonym        = 199;
   paUnpairedSymbol      = 214;
   paEndExp              = 215;
   paUnexpHereby         = 216;
   paAdjClusterExp       = 223;
   paUnexpReconsider     = 228;
   paPerExp              = 231;
   paSupposeOrCaseExp    = 232;
   paOfExp               = 256;
   paUnexpRedef          = 273;
   paAllExp              = 275;
   paIdentExp1           = 300;
   paIdentExp2           = 300;
   paIdentExp3           = 300;
   paIdentExp4           = 300;
   paIdentExp5           = 300;
   paIdentExp6           = 300;
   paIdentExp7           = 300;
   paIdentExp8           = 300;
   paIdentExp9           = 300;
   paIdentExp10          = 300;
   paIdentExp11          = 300;
   paIdentExp12          = 300;
   paIdentExp13          = 300;
   paWrongPredPattern    = 301;
   paFunctExp1           = 302;
   paFunctExp2           = 302;
   paFunctExp3           = 302;
   paFunctExp4           = 302;
   paWrongModePatternBeg = 303;
   paStructExp1          = 304;
   paSelectExp1          = 305;
   paAttrExp1            = 306;
   paAttrExp2            = 306;
   paAttrExp3            = 306;
   paNumExp              = 307;
   paWrongReferenceBeg   = 308;
   paTypeOrAttrExp       = 309;
   paRightBraExp1        = 310;
   paRightBraExp2        = 310;
   paWrongRightBracket1  = 311;
   paWrongRightBracket2  = 311;
   paDefExp              = 312;
   paSchExp              = 313;
   paWrongPattBeg1       = 314;
   paWrongPattBeg2       = 314;
   paWrongPattBeg3       = 314;
   paWrongModePatternSet = 315;
   paWrongAfterThe       = 320;
   paWrongPredSymbol     = 321;
   paSemicolonExp        = 330;
   paUnexpConnective     = 336;
   paWrongScopeBeg       = 340;
   paThatExp1            = 350;
   paThatExp2            = 350;
   paCasesExp            = 351;
   paLeftParenthExp      = 360;
   paLeftSquareExp       = 361;
   paLeftCurledExp       = 362;
   paLeftDoubleExp1      = 363;
   paLeftDoubleExp3      = 363;
   paWrongSchemeVarQual  = 364;
   paRightParenthExp1    = 370;
   paRightParenthExp2    = 370;
   paRightParenthExp3    = 370;
   paRightParenthExp4    = 370;
   paRightParenthExp5    = 370;
   paRightParenthExp6    = 370;
   paRightParenthExp7    = 370; {forgot right paren in ``\texttt{from SCHEME(}''}
   paRightParenthExp8    = 370;
   paRightParenthExp9    = 370;
   paRightParenthExp10   = 370;
   paRightParenthExp11   = 370;
   paRightSquareExp1     = 371;
   paRightSquareExp2     = 371;
   paRightSquareExp3     = 371;
   paRightSquareExp4     = 371;
   paRightSquareExp5     = 371;
   paRightCurledExp1     = 372;
   paRightCurledExp2     = 372;
   paRightCurledExp3     = 372;
   paRightDoubleExp1     = 373;
   paRightDoubleExp2     = 373;
   paWrongAttrPrefixExpr = 375;
   paWrongAttrArgumentSuffix = 376;
   paTypeExpInAdjectiveCluster = 377;
   paEqualityExp1         = 380;
   paEqualityExp2         = 380;
   paIfExp                = 381;
   paForExp               = 382;
   paIsExp                = 383;
   paColonExp1            = 384;
   paColonExp2            = 384;
   paColonExp3            = 384;
   paColonExp4            = 384;
   paArrowExp1            = 385;
   paArrowExp2            = 385;
   paMeansExp             = 386;
   paStExp                = 387;
   paAsExp                = 388;
   paProofExp             = 389;
   paWithExp              = 390;
   paWrongItemBeg         = 391;
   paUnexpItemBeg         = 392;
   paWrongJustificationBeg = 395;
   paWrongFormulaBeg      = 396;
   paWrongTermBeg         = 397;
   paWrongRadTypeBeg      = 398;
   paWrongFunctorPatternBeg = 399;
   paStillNotImplemented  = 400;
   paNotExpected          = 401;
   paInfinitiveExp        = 402;
   paSuchExp              = 403;
   paToExp                = 404;
   paTypeUnexpInClusterRegistration = 405;
   paForOrArrowExpected   = 406;

@ @<Implementation of parser.pas@>=
var gAddSymbolsSet: set of char = []; {not used anywhere}

@ Syntax errors do three things:
\enumerate
\item Marks \\{StillCorrect} to be false (i.e., enters panic mode)
\item Reports the error with the \\{ErrImm} (\section\xref{ErrImm}) function. 
\item Skips ahead until we find a token in the \\{gMainSet}, then try
to proceed like things are still alright (so we ``fail gracefully'').
\endenumerate


@<Implementation of parser.pas@>=
procedure SynErr(fPos:Position; fErrNr:integer);
begin
   if StillCorrect then
   begin
      StillCorrect:=false; @#
      if CurWord.Kind = sy_Error then
      begin
         if CurWord.Nr <> scTooLongLineErrorNr then ErrImm(CurWord.Nr)
         else Error(fPos,fErrNr);
      end
      else Error(fPos,fErrNr); @#
      while not (CurWord.Kind in gMainSet) do ReadTokenProc;
   end;
end;


@ What constants are good ``check-in points'' for the parser to
recover at? The beginning of blocks, the end of statements (especially
semicolons), and the end of text.

@<Local constants for parser.pas@>=
const
   gMainSet: set of TokenKind =
      [ sy_Begin,sy_Semicolon,sy_Proof,sy_Now,sy_Hereby,sy_Definition,
        sy_End, sy_Theorem,sy_Reserve,
        sy_Notation,sy_Registration,
        sy_Scheme,EOT,
        sy_Deffunc,sy_Defpred,
        sy_Reconsider,sy_Consider,sy_Then,
        sy_Per,sy_Case,sy_Suppose
      ];

@ We have a few more methods for \emph{specific} kinds of errors we
are likely to encounter.

@<Implementation of parser.pas@>=
procedure MissingWord(fErrNr:integer);
var lPos: Position;
begin
   lPos:=PrevPos;
   inc(lPos.Col);
   SynErr(lPos,fErrNr)
end; @#

procedure WrongWord(fErrNr:integer);
begin
   SynErr(CurPos,fErrNr)
end;

@ We will want to assert the parser has encountered a specific token
(like a semicolon or ``\texttt{end}'') and raise an error if it has
not. This will make for much more readable code later on. We should
recall \\{KillItem} (\section\xref{KillItem:syntax.pas}) mutates the
global state.

@<Implementation of parser.pas@>=
procedure Semicolon;
begin
   KillItem;
   if CurWord.Kind <> sy_Semicolon then
      MissingWord(paSemicolonExp);
   if CurWord.Kind = sy_Semicolon then ReadTokenProc;
end; @#

procedure AcceptEnd(fPos:Position);
begin
   if CurWord.Kind = sy_End then ReadTokenProc else
   begin
      Error(fPos,paEndExp);
      MissingWord(paUnpairedSymbol)
   end;
end;

@ These previous methods can be generalized to an \\{Accept}
procedure which checks whether a given |TokenKind| has
``occurred''. If so, just read the next word. Otherwise, flag an error.

@<Implementation of parser.pas@>=
procedure ReadWord;
begin
   Mizassert(2546,StillCorrect);
   ReadTokenProc
end; @#

function Occurs(fW:TokenKind): boolean;
begin
   Occurs:=false;
   if CurWord.Kind=fW then
   begin
      ReadWord;
      Occurs:=true
   end
end; @#

procedure Accept(fCh:TokenKind; fErrNr:integer);
begin
   if not Occurs(fCh) then MissingWord(fErrNr)
end;

@ Flagging a semantic error should first check if we are in ``panic mode''
or not. If we are already panicking, there's no reason to heap more
panicky error messages onto the screen.

@<Implementation of parser.pas@>=
procedure SemErr(fErrNr:integer);
begin
   if StillCorrect then ErrImm(fErrNr)
end;

@* [S] Expressions.
We have a few token kinds which indicate the start of a term:
\enumerate
\item identifiers (for variables and private functors),
\item infixed operators,
\item numerals,
\item left and right brackets of all sorts, 
\item the anaphoric ``\texttt{it}'' constant used in definitions,
\item ``\texttt{the}'' choice operator, 
\item placeholder variables appearing in private functors and predicates,
\item structure symbols.
\endenumerate

\label{TermBegSys}

@<Parse expressions (\texttt{parser.pas})@>=
 {{\it Expressions}}

const
   TermBegSys:set of TokenKind =
      [Identifier,InfixOperatorSymbol,Numeral,LeftCircumfixSymbol,sy_LeftParanthesis,
       sy_It,sy_LeftCurlyBracket,sy_LeftSquareBracket,sy_The,sy_Dolar,Structuresymbol];

@* [s] Terms.
We have a few helper function for |Accept|-ing parentheses.
This invokes the |ProcessLeftParenthesis| method for the |gSubexpPtr|
(\section\xref{gSubexpPtr}) global variable which we recall
(\section\xref{SubexpObj.abstract-methods}) is an empty virtual
method. So the parser just ``consumes'' a left parentheses, and will
continue to read tokens while they are left parentheses.
The argument passed in will be mutated to track the number of left
parentheses consumed.

Similarly, the |CloseParenth| method will have the compiler consume
right parentheses, mutating the argument passed in (to decrement the
number of right parentheses consumed). This will let us track
mismatched parentheses errors.

\label{OpenParenth:parser.pas}
\label{ClosedParenth:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure OpenParenth(var fParenthCnt:integer);
begin
   fParenthCnt:=0;
   while CurWord.Kind = sy_LeftParanthesis do
   begin
      gSubexpPtr^.ProcessLeftParenthesis;
      ReadWord;
      inc(fParenthCnt);
   end;
end; @#

procedure CloseParenth(var fParenthCnt:integer);
begin
   while (CurWord.Kind = sy_RightParanthesis) and (fParenthCnt > 0) do
   begin
      dec(fParenthCnt);
      gSubexpPtr^.ProcessRightParenthesis;
      ReadWord;
   end;
end;

@ \node{Qualified expressions.} Parsing qualified expressions includes
a control flow for ``exactly'' qualified expressions.

We should recall from ``Mizar in a nutshell'' that the
``\texttt{exactly}'' keyword is reserved but not currently used for
anything. The global subexpression pointer is invoking empty virtual
methods (\section\xref{SubexpObj.abstract-methods}). So what's going
on?

Well, the only work being done here is in the branch handling
``\texttt{qua}'', specifically the next word is read, and then control
is handed off to |TypeSubexpression|.

\label{AppendQua}

@<Parse expressions (\texttt{parser.pas})@>=
procedure @? TypeSubexpression; forward; @t\2@> @#

procedure AppendQua;
begin
   while CurWord.Kind = sy_Qua do
   begin
      gSubexpPtr^.ProcessQua;
      ReadWord;
      TypeSubexpression;
      gSubexpPtr^.FinishQualifiedTerm;
   end;
   if CurWord.Kind = sy_Exactly then
   begin
      gSubexpPtr^.ProcessExactly;
      ReadWord
   end;
end;

@ Parsing \emph{the contents of} a bracketed term starts a bracketed term
(\section\xref{SubexpObj.abstract-methods}), reads the next word after
the start of the bracket, then consumes the maximum number of visible
arguments (\section\xref{MaxVisArgNbr}).

The contract for this function is that a left bracket token has been
encountered, the parser has moved on to the next token, and then invoked
this function. 

\label{BracketedTerm}


@<Parse expressions (\texttt{parser.pas})@>=
procedure @? GetArguments(const fArgsNbr:integer); forward; @t\2@> @#

procedure BracketedTerm;
begin
   gSubexpPtr^.StartBracketedTerm;
   ReadWord;
   GetArguments(MaxVisArgNbr);
   gSubexpPtr^.FinishBracketedTerm;
end;

@ Parsing post-qualified variables (i.e., variables which appear in a
Fraenkel term's ``\texttt{where}'' clause) which consists of a
comma-separated list of post-qualified segments.

\label{ProcessPostqualification}

@<Parse expressions (\texttt{parser.pas})@>=
procedure @? TermSubexpression; forward; @t\2@>

procedure @? FormulaSubexpression; forward; @t\2@>

procedure @? ArgumentsTail(fArgsNbr:integer); forward; @t\2@> @#

procedure ProcessPostqualification;
begin
   gSubexpPtr^.StartPostqualification;
   while CurWord.Kind = sy_Where do
   begin
      repeat
         @<Process post-qualified segment@>@;
      until CurWord.Kind <> sy_Comma;
   end;
end;

@ Each ``segment'' in a post-qualification looks like:
$$\langle\textit{variable}\rangle\ \LB\hbox{\texttt{","} } \langle\textit{variable}\rangle\RB\ (\hbox{\texttt{"is"} } \pipe \hbox{ \texttt{"being"}})\ \langle\textit{type}\rangle$$
We can process the comma-separated list of variables, then the type
ascription term (``is'' or ``being''), then process the type.

@d process_postqualified_variables == @+ repeat
            gSubexpPtr^.ProcessPostqualifiedVariable;
            Accept(Identifier,paIdentExp1);
         until not Occurs(sy_Comma)
@d post_qualified_type == @+
         begin
            ReadWord;
            TypeSubexpression; @+
         end
@<Process post-qualified segment@>=
         gSubexpPtr^.StartPostQualifyingSegment;
         ReadWord; @/
         process_postqualified_variables; @/
         gSubexpPtr^.StartPostqualificationSpecyfication;
         if CurWord.Kind in [sy_Is,sy_are] then post_qualified_type;
         gSubexpPtr^.FinishPostqualifyingSegment;

@ Getting a closed subterm is part of the loop for parsing a term. The
intricate relationship of mutually recursive function calls looks
something like the following (assuming there are no parsing errors):

\medbreak
\figure
\centerline{\graphics{img/img-0}}
\caption{Control flow when parsing a term.}\label{fig:flow-of-parsing-term}
\endfigure
\medbreak\noindent%
The \\{GetArguments} parses a comma-separated list of terms. Since
each term in the comma-separated list will be a \emph{subterm} of a
larger expression, we parse it with \\{TermSubexpression} (which
invokes \\{GetClosedSubterm} in a mutually recursive relation). If
there is a chain of infix operators (like $x + y - z \times\omega$), then
\\{AppendFunc} is invoked on the infixed operators.

\label{GetClosedSubterm:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure GetClosedSubterm;
begin
   case CurWord.Kind of
      @<Get closed subterm of identifier@>;
      @<Get closed subterm of structure@>;
      Numeral:
         begin
            gSubexpPtr^.ProcessNumeralTerm;
            ReadWord @+
         end;
      @<Get closed subterm of bracketed expression@>;
      sy_It:
         begin
            gSubexpPtr^.ProcessItTerm;
            ReadWord @+
         end;
      sy_Dolar:
         begin
            gSubexpPtr^.ProcessLocusTerm;
            ReadWord @+
         end;
      @<Get closed subterm of Fraenkel operator or enumerated set@>;
      @<Get closed subterm of choice operator@>;
   othercases RunTimeError(2133);
   endcases;
end;

@ If we treat an identifier as a term, then it is either a private
functor or it is a variable. How do we tell the difference? A private
functor starts with an identifier followed by a left parentheses.

\label{GetClosedSubterm:identifier:parser.pas}

@<Get closed subterm of identifier@>=
      Identifier:
         if AheadWord.Kind = sy_LeftParanthesis then {treat identifier as private functor}
         begin
            gSubexpPtr^.StartPrivateTerm;
            ReadWord;
            ReadWord;
            if CurWord.Kind <> sy_RightParanthesis then GetArguments(MaxVisArgNbr);
            gSubexpPtr^.FinishPrivateTerm;
            Accept(sy_RightParanthesis,paRightParenthExp2);
         end
         else {treat identifier as variable}
         begin
            gSubexpPtr^.ProcessSimpleTerm;
            ReadWord @+
         end

@ If the parser stumbles across the name of a structure when expecting
a term, then the parser should treat it as constructing a new instance
of the structure.

\label{ClosedSubter:structure:parser.pas}

@<Get closed subterm of structure@>=
      StructureSymbol:
         begin
            gSubexpPtr^.StartAggregateTerm;
            ReadWord;
            Accept(sy_StructLeftBracket,paLeftDoubleExp1);
            GetArguments(MaxVisArgNbr);
            gSubexpPtr^.FinishAggregateTerm;
            Accept(sy_StructRightBracket,paRightDoubleExp1);
         end

@ Encountering a left bracket of some kind should cause the parser to
look for the contents of a bracketed term (\section\xref{BracketedTerm}),
then a right bracket.

@<Get closed subterm of bracketed expression@>=
      LeftCircumfixSymbol,sy_LeftSquareBracket:
         begin
            BracketedTerm;
            case Curword.Kind of
               sy_RightSquareBracket,sy_RightCurlyBracket,sy_RightParanthesis: ReadWord;
            othercases Accept(RightCircumfixSymbol,paRightBraExp1);
            endcases;
         end

@ When the parser runs into a left curly bracket ``$\LB$'', we either
have encountered a Fraenkel operator \emph{or} we have encountered a
finite set.



@<Get closed subterm of Fraenkel operator or enumerated set@>=
      sy_LeftCurlyBracket:
         begin
            gSubexpPtr^.StartBracketedTerm;
            ReadWord;
            TermSubexpression;
            if (CurWord.Kind = sy_Colon) or (CurWord.Kind = sy_Where) then
            @<Parse a Fraenkel operator@>
            else
            @<Parse an enumerated set@>;
         end

@ 
Parsing a Fraenkel operator, well, we recall Fraenkel operators look
like
$$\LB\langle\textit{term\/}\rangle\langle\hbox{\textit{post-qualified\ segment\/}}\rangle\hbox{\texttt{ ":" }}\langle\textit{formula\/}\rangle\RB$$

@<Parse a Fraenkel operator@>=
            begin
               gSubexpPtr^.StartFraenkelTerm;
               ProcessPostqualification;
               gSubexpPtr^.FinishSample;
               Accept(sy_Colon,paColonExp1);
               FormulaSubexpression;
               gSubexpPtr^.FinishFraenkelTerm;
               Accept(sy_RightCurlyBracket,paRightCurledExp1);
            end

@ We can also run into a finite set $\LB x_{1},\dots,x_{n}\RB$.

@<Parse an enumerated set@>=
            begin
               gSubexpPtr^.FinishArgument;
               ArgumentsTail(MaxVisArgNbr-1);
               gSubexpPtr^.FinishBracketedTerm;
               case Curword.Kind of
                  sy_RightSquareBracket,sy_RightCurlyBracket,sy_RightParanthesis: ReadWord;
               othercases Accept(RightCircumfixSymbol,paRightBraExp1);
               endcases;
            end


@ Mizar allows ``\texttt{the}'' to be used for selector functors,
forgetful functors, choice operators, or simple Fraenkel terms.

\label{GetClosedSubterm:the:parser.pas}

@<Get closed subterm of choice operator@>=
      sy_The:
         begin
            gSubexpPtr^.ProcessThe;
            ReadWord;
            case CurWord.Kind of
               SelectorSymbol:
                  begin
                     gSubexpPtr^.StartSelectorTerm;
                     ReadWord;
                     if Occurs(sy_Of) then TermSubexpression;
                     gSubexpPtr^.FinishSelectorTerm;
                  end;
               StructureSymbol:
                  @<Parse forgetful functor or choice of structure type@>;
               sy_Set:
                  @<Parse simple Fraenkel expression or ``the set''@>;
               ModeSymbol,AttributeSymbol,sy_Non,sy_LeftParanthesis,Identifier,
               InfixOperatorSymbol,Numeral,LeftCircumfixSymbol,sy_It,sy_LeftCurlyBracket,
               sy_LeftSquareBracket,sy_The,sy_Dolar:@|@/
                  begin
                     gSubexpPtr^.StartChoiceTerm;
                     TypeSubexpression;
                     gSubexpPtr^.FinishChoiceTerm;
                  end
            othercases
            begin
               gSubexpPtr^.InsertIncorrTerm;
               WrongWord(paWrongAfterThe) @+
            end;
            endcases;
         end

@ A forgetful functor always looks like
$$\hbox{\texttt{"the" }}\langle\textit{structure\/}\rangle\hbox{\texttt{ "of" }}\langle\textit{term\/}\rangle$$
On the other hand, the choice operator acting on a structure type
looks similar. We should distinguish these two by the presence of the
keyword \texttt{"of"}.

\label{GetClosedSubterm:forgetful-functor:parser.pas}

@<Parse forgetful functor or choice of structure type@>=
                  if AheadWord.Kind = sy_Of then {forgetful functor}
                  begin
                     gSubexpPtr^.StartForgetfulTerm;
                     ReadWord;
                     Accept(sy_Of,paOfExp);
                     TermSubexpression;
                     gSubexpPtr^.FinishForgetfulTerm;
                  end
                  else {choice operator}
                  begin
                     gSubexpPtr^.StartChoiceTerm;
                     TypeSubexpression;
                     gSubexpPtr^.FinishChoiceTerm;
                  end

@ Mizar allows ``\texttt{the set of}'' to start a simple Fraenkel
expression. But we could also refer to ``\texttt{the set}'' as the set
chosen by the axiom of choice.

\label{ParseSimpleFraenkelExprOrTheSet:parser.pas}

@<Parse simple Fraenkel expression or ``the set''@>=
                  if AheadWord.Kind = sy_Of then {simple Fraenkel expression}
                  begin
                     ReadWord; {set}
                     ReadWord; {of}
                     gSubexpPtr^.StartSimpleFraenkelTerm;
                     Accept(sy_All,paAllExp);
                     TermSubexpression;
                     gSubexpPtr^.StartFraenkelTerm;
                     ProcessPostqualification;
                     gSubexpPtr^.FinishSimpleFraenkelTerm;
                  end
                  else {``the set''}
                  begin
                     gSubexpPtr^.StartChoiceTerm;
                     TypeSubexpression;
                     gSubexpPtr^.FinishChoiceTerm;@+
                  end

@ Subexpression object's \\{FinishArgument} 
(\section\xref{extSubexpObj.FinishArgument}) is invoked. This will invoke
the \\{AppendQua} (\section\xref{AppendQua}) method and expect a
closed parentheses afterwards (\section\xref{ClosedParenth:parser.pas}).

Possible bug: what should happen when \\{fParenthCnt} is zero or negative?

\label{CompleteArgument:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure CompleteArgument(var fParenthCnt:integer);
begin
   gSubexpPtr^.FinishArgument;
   repeat
      AppendQua;
      CloseParenth(fParenthCnt);
   until CurWord.Kind<>sy_Qua; {|and (CurWord.Kind <> sy_Exactly)|}
end;

@ Keep parsing ``infixed operators''. When the current token is an
infixed operator, this will consume the arguments to its right, then
iterate. It's also worth remembering that \\{gExpPtr}
(\section\xref{gSubexpPtr}) was a global variable declared back
in \texttt{syntax.pas}, and the \\{CreateSubexpression}
(\section\xref{extExpressionObj.CreateSubexpression}) mutates
the \\{gSubexpPtr} variable. Now we see it in action.

This invokes the |ProcessLeftParenthesis| method for the |gSubexpPtr|
(\section\xref{gSubexpPtr}) global variable which we recall
(\section\xref{SubexpObj.abstract-methods}) is an empty virtual
method. So the parser just ``consumes'' a left parentheses.

Note that the |case| expression considers the type of |TokenKind|
(\section\xref{TokenKind}) of the current word. But it is not exhaustive.

There is a comment in Polish, ``Chyba po prostu TermSubexpression'',
which Google translated into English as ``I guess it's just Term Subexpression''.
I swapped this in the code below.

\label{AppendFunc:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure AppendFunc(var fParenthCnt: integer);
begin
   while CurWord.Kind = InfixOperatorSymbol do
   begin
      gSubexpPtr^.StartLongTerm; { (\section\xref{extSubexpObj.StartLongTerm}) }
      repeat
         gSubexpPtr^.ProcessFunctorSymbol; { (\section\xref{extSubexpObj.ProcessFunctorSymbol}) }
         ReadWord;
         case CurWord.Kind of
            sy_LeftParanthesis:@|@/
               begin {parenthetised term(s)}
                  gSubexpPtr^.ProcessLeftParenthesis; 
                  ReadWord; {consume the left paren}
                  GetArguments(MaxVisArgNbr); { (\section\xref{GetArguments:parser.pas}) }
                  gSubexpPtr^.ProcessRightParenthesis;
                  Accept(sy_RightParanthesis,paRightParenthExp3); {consume matching right paren}
               end; @#
            Identifier,Numeral,LeftCircumfixSymbol,sy_It,sy_LeftCurlyBracket,
            sy_LeftSquareBracket,sy_The,sy_Dolar,StructureSymbol:
               { I guess it's just Term Subexpression }
               begin
                  gExpPtr^.CreateSubexpression; { (\section\xref{extExpressionObj.CreateSubexpression}) }
                  GetClosedSubterm; { (\section\xref{GetClosedSubterm:parser.pas}) }
                  gSubexpPtr^.FinishArgument; { (\section\xref{extSubexpObj.FinishArgument}) }
                  KillSubexpression; { (\section\xref{KillSubexpression}) }
               end;
         endcases; @/
         gSubexpPtr^.FinishArgList; { (\section\xref{extSubexpObj.FinishArgList}) }
      until CurWord.Kind <> InfixOperatorSymbol;
      gSubexpPtr^.FinishLongTerm; { (\section\xref{extSubexpObj.FinishLongTerm}) }
      CompleteArgument(fParenthCnt); { (\section\xref{CompleteArgument:parser.pas}) }
   end;
end;

@ Parse terms with infix operators. Note this appears to parse infixed
operators as left-associative (e.g., $x+y+z$ is parsed as $(x+y)+z$).

@<Parse expressions (\texttt{parser.pas})@>=
procedure ProcessArguments;
var lParenthCnt: integer;
begin
   OpenParenth(lParenthCnt);
   case CurWord.Kind of
      Identifier,Numeral,LeftCircumfixSymbol,sy_It,sy_LeftCurlyBracket,
      sy_LeftSquareBracket,sy_The,sy_Dolar,StructureSymbol: @|@/
         begin
            GetClosedSubterm;
            CompleteArgument(lParenthCnt);@+
         end;
      InfixOperatorSymbol:;
   othercases
   begin
      gSubexpPtr^.InsertIncorrTerm;
      gSubexpPtr^.FinishArgument;
      WrongWord(paWrongTermBeg);
   end;
   endcases; @|@/
   @<Keep parsing as long as there is an infixed operator to the right@>;
   @<Check every remaining open (left) parentheses has a corresponding partner@>;
end;

@ @<Keep parsing as long as there is an infixed operator to the right@>=
   repeat
      AppendFunc(lParenthCnt);
      if CurWord.Kind = sy_Comma then
      begin
         ArgumentsTail(MaxVisArgNbr-1);
         if (lParenthCnt > 0) and (CurWord.Kind = sy_RightParanthesis) then
         begin
            dec(lParenthCnt);
            gSubexpPtr^.ProcessRightParenthesis;
            ReadWord;
         end;
      end;
   until CurWord.Kind <> InfixOperatorSymbol

@ @<Check every remaining open (left) parentheses has a corresponding partner@>=
   while lParenthCnt > 0 do
   begin
      gSubexpPtr^.ProcessRightParenthesis;
      Accept(sy_RightParanthesis,paRightParenthExp1);
      dec(lParenthCnt);
   end

@ An adjective cluster is just one or more (possibly negated) attribute.

@<Parse expressions (\texttt{parser.pas})@>=
@<Process attributes (\texttt{parser.pas})@>@;@#

procedure GetAdjectiveCluster;
begin
   gSubexpPtr^.StartAdjectiveCluster;
   ProcessAttributes;
   gSubexpPtr^.FinishAdjectiveCluster;
end;

@ Parsing an attribute amounts to:
\enumerate
\item handling a leading ``\texttt{non}''
\item handling attribute arguments (which always occurs \emph{before}
the attribute)
\item handling the attribute.
\endenumerate

\label{ProcessAttributes:parser.pas}

@d kind_is_radix_type(#) == (# in [sy_Set,ModeSymbol,StructureSymbol])
@d ahead_is_attribute_argument == @/
      (CurWord.Kind in (TermBegSys - [sy_LeftParanthesis,StructureSymbol])) or@|
      ((CurWord.Kind = sy_LeftParanthesis) and
          not(kind_is_radix_type(AheadWord.Kind))) or@|
      ((CurWord.Kind =  StructureSymbol) and (AheadWord.Kind = sy_StructLeftBracket))

@<Process attributes (\texttt{parser.pas})@>=
procedure ProcessAttributes;
begin
   while (CurWord.Kind in [AttributeSymbol,sy_Non]) or ahead_is_attribute_argument
   do
   begin
      gSubexpPtr^.ProcessNon;
      if CurWord.Kind = sy_Non then ReadWord;
      if ahead_is_attribute_argument
      then
      begin
         gSubexpPtr^.StartAttributeArguments;
         ProcessArguments;
         gSubexpPtr^.CompleteAttributeArguments;
      end;
      if CurWord.Kind = AttributeSymbol then
      begin
         gSubexpPtr^.ProcessAttribute;
         ReadWord; @+
      end
      else
      begin
         SynErr(CurPos,paAttrExp1) @+
      end;
   end;
end;

@ \node{Parsing a radix type.} For Mizar, a Radix type is either a
structure type or a mode (or it's the ``\texttt{set}'' type).

@^Radix type@>
@^Type, radix@>

There is a comment in Polish, ``zawieszone na czas zmiany semantyki'',
which is translated into English.

\label{RadixTypeSubexpression:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure RadixTypeSubexpression;
var lSymbol,lParenthCnt: integer;
begin
   lParenthCnt:=0;
   @<Parse optional left-paren@>;
   gSubexpPtr^.ProcessModeSymbol; {(\section\xref{extSubexpObj.ProcessModeSymbol})}
   case CurWord.Kind of
      sy_Set:
         begin ReadWord; {? if Occurs(syOf) then TypeSubexpression
                          suspended while semantics change}
         end;
      ModeSymbol:
         @<Parse mode as radix type@>;
      StructureSymbol:
         @<Parse structure as radix type@>;
   othercases
   begin MissingWord(paWrongRadTypeBeg); gSubexpPtr^.InsertIncorrType @+ end;
   endcases; @|@/
   @<Close the parentheses@>;
   gSubexpPtr^.FinishType;
end;

@ @<Parse mode as radix type@>=
         begin lSymbol:=CurWord.Nr; ReadWord;
         if CurWord.Kind = sy_Of then
            if ModeMaxArgs.fList^[lSymbol] = 0 then WrongWord(paUnexpOf)
            else begin ReadWord; GetArguments(ModeMaxArgs.fList^[lSymbol]) @+ end;
         end

@ @<Parse structure as radix type@>=
         begin
            lSymbol:=CurWord.Nr;
            ReadWord;
            if CurWord.Kind = sy_Over then
               if StructModeMaxArgs.fList^[lSymbol] = 0
               then WrongWord(paUnexpOver)
               else
               begin
                  ReadWord;
                  GetArguments(StructModeMaxArgs.fList^[lSymbol]) @+ 
               end;
         end

@ @<Parse optional left-paren@>=
   if  CurWord.Kind = sy_LeftParanthesis then
   begin
      gSubexpPtr^.ProcessLeftParenthesis;
      ReadWord;
      inc(lParenthCnt);
   end

@ @<Close the parentheses@>=
   if lParenthCnt > 0 then
   begin
      gSubexpPtr^.ProcessRightParenthesis;
      Accept(sy_RightParanthesis,paRightParenthExp1);
   end

@ Now we have to parse the type subexpression. We basically get the
adjectives with \\{GetAdjectiveCluster}, then we get the radix type
with \\{RadixTypeSubexpression}.

@<Parse expressions (\texttt{parser.pas})@>=
procedure TypeSubexpression;
begin
   gExpPtr^.CreateSubexpression;
   gSubexpPtr^.StartType;
   gSubexpPtr^.StartAttributes; @/
   GetAdjectiveCluster;
   RadixTypeSubexpression; @/
   gSubexpPtr^.CompleteAttributes;
   gSubexpPtr^.CompleteType; @/
   KillSubexpression;
end;

@ We should recall from Figure~\ref{fig:flow-of-parsing-term} (\section\xref{GetClosedSubterm:parser.pas}) that
this is a critical part of parsing terms.

\label{TermSubexpression:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure TermSubexpression;
var lParenthCnt: integer;
begin
   gExpPtr^.CreateSubexpression;
   OpenParenth(lParenthCnt); { (\section\xref{OpenParenth:parser.pas}) }
   case CurWord.Kind of
      Identifier,Numeral,LeftCircumfixSymbol,sy_It,sy_LeftCurlyBracket,
      sy_LeftSquareBracket,sy_The,sy_Dolar,StructureSymbol: @|@/
         begin
            GetClosedSubterm;
            CompleteArgument(lParenthCnt); @+
         end;
      InfixOperatorSymbol: {skip}@+;
   othercases
   begin
      gSubexpPtr^.InsertIncorrTerm;
      gSubexpPtr^.FinishArgument;
      WrongWord(paWrongTermBeg);
   end;
   endcases; @/
   AppendFunc(lParenthCnt); { (\section\xref{AppendFunc:parser.pas}) }
   while lParenthCnt > 0 do
   @<Parse arguments to the right@>;
   gSubexpPtr^.FinishTerm;
   KillSubexpression;
end;

@ @<Parse arguments to the right@>=
   begin
      ArgumentsTail(MaxVisArgNbr-1);
      dec(lParenthCnt);
      gSubexpPtr^.ProcessRightParenthesis;
      Accept(sy_RightParanthesis,paRightParenthExp10);
      if CurWord.Kind <> InfixOperatorSymbol then MissingWord(paFunctExp3);
      AppendFunc(lParenthCnt);
   end

@ This will parse \\{fArgsNbr} comma separated terms. It's used to
parse the arguments ``to the right'' of a term, for parsing the
contents of an enumerated set (e.g., $\{x,y,z,w\}$), among many other places.

We should recall that the \\{StartArgument} method is empty.

@<Parse expressions (\texttt{parser.pas})@>=
procedure ArgumentsTail(fArgsNbr:integer);
begin
   while (fArgsNbr > 0) and Occurs(sy_Comma) do
   begin
      gSubexpPtr^.StartArgument;
      TermSubexpression;
      gSubexpPtr^.FinishArgument;
      dec(fArgsNbr);
   end;
end;

@ Attributes, terms, predicates have terms as arguments. This relies
upon the \\{FinishArguments} method (\section\xref{extSubexpObj.FinishArgument}).

\label{GetArguments:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure GetArguments(const fArgsNbr:integer);
begin
   if fArgsNbr > 0 then
   begin
      TermSubexpression;
      gSubexpPtr^.FinishArgument;
      ArgumentsTail(fArgsNbr-1);
   end;
end;

@* [s] Formulas.
Quantified variables looks like
$$\<Variable>\ \LB\hbox{ \texttt{","} }\<Variable>\RB\ [(\hbox{\texttt{"be"}}\pipe\hbox{\texttt{"being"}})\ \<Type>]$$
The parsing routine follows the grammar fairly faithfully.

@<Parse expressions (\texttt{parser.pas})@>=
procedure QuantifiedVariables;
begin
   repeat
      gSubexpPtr^.StartQualifiedSegment;
      ReadWord;
      @<Parse comma-separated variables for quantified variables@>;
      gSubexpPtr^.StartQualifyingType;
      if Occurs(sy_Be) or Occurs(sy_Being) then TypeSubexpression;
      gSubexpPtr^.FinishQualifiedSegment;
   until CurWord.Kind <> sy_Comma;
end;

@ @<Parse comma-separated variables for quantified variables@>=
      repeat
         gSubexpPtr^.ProcessVariable;
         Accept(Identifier,paIdentExp2);
      until not Occurs(sy_Comma)

@ The existential formula looks like
$$\hbox{\texttt{ex} }\<Quantified-Variables>\hbox{ \texttt{st} }\<Formula>$$
The parser implements it quite faithfully.

@<Parse expressions (\texttt{parser.pas})@>=
procedure ExistentialFormula;
begin
   gSubexpPtr^.StartExistential;
   QuantifiedVariables;@/
   gSubexpPtr^.FinishQuantified;
   Accept(sy_St,paStExp);
   FormulaSubexpression;@/
   gSubexpPtr^.FinishExistential;
end;

@ Universally quantified formulas are tricky because both
$$\hbox{\texttt{for }}\<Quantified-Variables>\hbox{ \texttt{holds} }\<Formula>$$
and
$$\hbox{\texttt{for }}\<Quantified-Variables>\hbox{ \texttt{st} }\<Formula>\hbox{ \texttt{holds} }\<Formula>$$
are acceptable. Furthermore, we may include multiple ``\texttt{for} \<Quantified-Variables>''
(possibly with ``\texttt{st} \<Formula>'' restrictions)
before arriving at the single ``\texttt{holds} \<Formula>''.
The trick is to parse this as
$$\hbox{\texttt{for }}\<Quantified-Variables>\ [\hbox{\texttt{st} }\<Formula>]\ [\hbox{\texttt{holds}}]\ \<Formula>$$
so the recursive call to parse the final formula enables us to parse
another quantified formula.

@<Parse expressions (\texttt{parser.pas})@>=
procedure UniversalFormula;
begin
   gSubexpPtr^.StartUniversal;
   QuantifiedVariables;
   gSubexpPtr^.FinishQuantified;
   if CurWord.Kind = sy_St then
   begin
      gSubexpPtr^.StartRestriction;
      ReadWord;
      FormulaSubexpression;
      gSubexpPtr^.FinishRestriction;
   end;
   case CurWord.Kind of
      sy_Holds:
         begin
            gSubexpPtr^.ProcessHolds;
            ReadWord @+
         end;
      sy_For, sy_Ex: ; {fallthrough}
   othercases
   begin
      gSubexpPtr^.InsertIncorrFormula;
      MissingWord(paWrongScopeBeg) @+
   end;
   endcases;@#
   FormulaSubexpression;
   gSubexpPtr^.FinishUniversal;
end;

@ The Parser's current token is either ``\texttt{=}'' or a predicate
symbol. Then we should parse ``the right-hand side'' of the equation
(or formula). The current token's Symbol number is passed as the
argument to this procedure.

It's worth recalling the definition of \\{TermBegSys}
(\section\xref{TermBegSys}) which is all the token kinds for starting
a term. If the next token is a term, then |GetArguments| is invoked to
parse them.

\label{CompleteRightSideOfThePredicativeFormula:parser.pas}
@<Parse expressions (\texttt{parser.pas})@>=
procedure @? ConditionalTail; forward; @t\2@>@#

procedure CompleteRightSideOfThePredicativeFormula(aPredSymbol:integer);
begin
   gSubexpPtr^.ProcessRightSideOfPredicateSymbol;
   ReadWord;
   if CurWord.Kind in TermBegSys then
      GetArguments(PredMaxArgs.fList^[aPredSymbol]);
   gSubexpPtr^.FinishRightSideOfPredicativeFormula;
end;

@ Recall a ``multi-predicative formula'' is something of the form
$a\leq x\leq b$. More generally, we could imagine the grammar for such
a formula resembles:
$$ \<Formula>\ \LB\ \<Multi-Predicate>\ \<Term-List>\ \RB$$
The Parser's current token is \<Multi-Predicate>, and we want to keep
parsing until the entire multi-predicative formula has been parsed.

We should mention (because I have not seen it discussed anywhere)
Mizar allows ``\texttt{does not}'' and ``\texttt{do not}'' in formulas
(for example, ``\texttt{Y does not overlap X /\BS\ Z}''), but
Mizar \textbf{does not} support ``\texttt{does}'' (or ``\texttt{do}'')
without the ``\texttt{not}''. A 401 error would be raised.

Grammatically, this is known as ``do-support'', and Mizar uses it for
negating predicates. The verb following the ``do'' is a ``bare
infinitive'' (which is why Mizar allows an ``infinitive'' for
predicates). This makes sense when the predicate uses a ``finite
verb''. For ``non-finite verb forms'', it is idiomatic English to just negate
the verb (as in ``\emph{Not knowing} what that means, I just smile and nod''
and ``It would be a crime \emph{not to learn} grammar'').

@^Error, 401@>
@^Infinitive@>
@^Grammar, English@>
@:do}{\texttt{do}@>
@:does}{\texttt{does}@>
@^Do-support@>

\label{CompleteMultiPredicativeFormula:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure CompleteMultiPredicativeFormula;
begin
   gSubexpPtr^.StartMultiPredicativeFormula;
   repeat
      case CurWord.Kind of
         sy_Equal, PredicateSymbol:
            CompleteRightSideOfThePredicativeFormula(CurWord.Nr);
         sy_Does,sy_Do:
            @<Parse multi-predicate with ``\texttt{does}'' or ``\texttt{do}'' in copula@>;
      endcases;
   until not (CurWord.Kind in [sy_Equal,PredicateSymbol,sy_Does,sy_Do]);
   gSubexpPtr^.FinishMultiPredicativeFormula;
end;

@ @<Parse multi-predicate with ``\texttt{does}'' or ``\texttt{do}'' in copula@>=
            begin
               @<Consume ``\texttt{does not}'' or ``\texttt{do not}'', raise error otherwise@>;
               if CurWord.Kind in [PredicateSymbol,sy_Equal] then
               begin
                  CompleteRightSideOfThePredicativeFormula(CurWord.Nr);
                  gSubexpPtr^.ProcessNegative; @+
               end
               else
               begin
                  gSubExpPtr^.InsertIncorrFormula;
                  SynErr(CurPos,paInfinitiveExp) @+
               end;
            end

@ @<Consume ``\texttt{does not}'' or ``\texttt{do not}'', raise error otherwise@>=
               gSubexpPtr^.ProcessDoesNot;
               ReadWord;
               Accept(sy_Not,paNotExpected)

@ The Parser is trying to parse a predicate and has just parsed a
comma-separated list of terms. Now, the Parser's is
either (1) looking at a predicate or equality, or (2) has matched
``\texttt{does not}'' or ``\texttt{do not}'' and is now looking at a
predicate or equality. In both cases, the Parser tries to complete the
formula with the \\{CompletePredicativeFormula} procedure.

\label{CompletePredicativeFormula:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure CompletePredicativeFormula(aPredSymbol:integer);
begin
   gSubexpPtr^.ProcessPredicateSymbol; {(\section\xref{extSubexpObj.ProcessPredicateSymbol})}
   ReadWord;
   if CurWord.Kind in TermBegSys then
      GetArguments(PredMaxArgs.fList^[aPredSymbol]);
   gSubexpPtr^.FinishPredicativeFormula;
end;
@

\label{CompleteAtomicFormula:parser.pas}

@<Parse expressions (\texttt{parser.pas})@>=
procedure CompleteAtomicFormula(var aParenthCnt:integer);
var lPredSymbol: integer;
label Predicate; {not actually used}
begin
   @<Parse left arguments in a formula@>;
   case CurWord.Kind of
      sy_Equal,PredicateSymbol:
         @<Parse equation or (possibly infixed) predicate@>;
      sy_Does,sy_Do:
         @<Parse formula with ``\texttt{does not}'' or ``\texttt{do not}''@>;
      sy_Is:
         @<Parse formula with ``\texttt{is not}'' or ``\texttt{is not}''@>;
   othercases
   begin
      gSubexpPtr^.ProcessAtomicFormula;
      MissingWord(paWrongPredSymbol);
      gSubexpPtr^.InsertIncorrBasic;
   end;
   endcases;
end;

@ @<Parse left arguments in a formula@>=
   repeat
      AppendFunc(aParenthCnt);
      if CurWord.Kind = sy_Comma then
      begin
         ArgumentsTail(MaxVisArgNbr-1);
         if (aParenthCnt > 0) and (CurWord.Kind = sy_RightParanthesis) then
         begin
            dec(aParenthCnt);
            gSubexpPtr^.ProcessRightParenthesis;
            ReadWord;
            if CurWord.Kind <> InfixOperatorSymbol then MissingWord(paFunctExp1);
         end;
      end;
   until CurWord.Kind <> InfixOperatorSymbol

@ @<Parse equation or (possibly infixed) predicate@>=
         begin
            CompletePredicativeFormula(CurWord.Nr);
            if CurWord.Kind in [sy_Equal,PredicateSymbol,sy_Does,sy_Do] then
               CompleteMultiPredicativeFormula
         end

@ @<Parse formula with ``\texttt{does not}'' or ``\texttt{do not}''@>=
         begin
            gSubexpPtr^.ProcessDoesNot;
            ReadWord;
            Accept(sy_Not,paNotExpected);
            if CurWord.Kind in [PredicateSymbol,sy_Equal] then
            begin
               CompletePredicativeFormula(CurWord.Nr);
               gSubexpPtr^.ProcessNegative;
               if CurWord.Kind in [sy_Equal,PredicateSymbol,sy_Does,sy_Do] then
                  CompleteMultiPredicativeFormula
            end
            else
            begin
               gSubExpPtr^.InsertIncorrFormula;
               SynErr(CurPos,paInfinitiveExp) @+
            end;
         end

@ @<Parse formula with ``\texttt{is not}'' or ``\texttt{is not}''@>=
         begin
            gSubexpPtr^.ProcessAtomicFormula;
            ReadWord;
            if (CurWord.Kind = sy_Not) and
                  (AheadWord.Kind in TermBegSys+
                      [ModeSymbol,StructureSymbol,sy_Set,AttributeSymbol,sy_Non]) or
                  (CurWord.Kind in TermBegSys+
                      [ModeSymbol,StructureSymbol,sy_Set,AttributeSymbol,sy_Non]) then
            begin
               gSubexpPtr^.StartType;
               gSubexpPtr^.StartAttributes;
               if CurWord.Kind = sy_Not then
               begin
                  gSubexpPtr^.ProcessNegation;
                  ReadWord; @+
               end;
               GetAdjectiveCluster;
               case CurWord.Kind of
                  sy_LeftParanthesis,ModeSymbol,StructureSymbol,sy_Set:
                     begin
                        RadixTypeSubexpression;
                        gSubexpPtr^.CompleteAttributes;
                        gSubexpPtr^.CompleteType;
                        gSubexpPtr^.FinishQualifyingFormula;
                     end;
               othercases
               begin
                  gSubexpPtr^.CompleteAttributes;
                  gSubexpPtr^.FinishAttributiveFormula; @+
               end;
               endcases;
            end
            else
            begin
               gSubExpPtr^.InsertIncorrFormula;
               WrongWord(paTypeOrAttrExp); @+
            end;
         end

@ There is a comment in Polish, a single word (``Kolejnosc'') which
translates into English as ``Order''.

@d starts_with_term_token == Numeral,LeftCircumfixSymbol,sy_It,sy_LeftCurlyBracket,sy_LeftSquareBracket,
      sy_The,sy_Dolar,StructureSymbol 

@<Parse expressions (\texttt{parser.pas})@>=
procedure ViableFormula;
var lParenthCnt:integer;
label NotPrivate;
begin
   gExpPtr^.CreateSubexpression;
   OpenParenth(lParenthCnt);
   case CurWord.Kind of
      sy_For: UniversalFormula;
      sy_Ex: ExistentialFormula;
      { !!!!!!!!!!!!!!! Order }
      sy_Contradiction:
         begin
            gSubexpPtr^.ProcessContradiction;
            ReadWord; @+
         end;
      sy_Thesis:
         begin
            gSubexpPtr^.ProcessThesis;
            ReadWord; @+
         end;
      sy_Not:
         begin
            gSubexpPtr^.ProcessNot;
            ReadWord;
            ViableFormula;
            KillSubexpression;
            gSubexpPtr^.ProcessNegative;
         end;
      Identifier:
         if AheadWord.Kind = sy_LeftSquareBracket then
         @<Parse private formula@>
         else goto NotPrivate;
      starts_with_term_token:@t\1@> @|@/
         NotPrivate:
            begin
               gSubexpPtr^.StartAtomicFormula;
               { ??? TermSubexpression }
               GetClosedSubterm;
               CompleteArgument(lParenthCnt);
               CompleteAtomicFormula(lParenthCnt);
            end@t\2@>;
      InfixOperatorSymbol,PredicateSymbol,sy_Does,sy_Do,sy_Equal:
         begin
            gSubexpPtr^.StartAtomicFormula;
            CompleteAtomicFormula(lParenthCnt);
         end;
   othercases
   begin
      gSubexpPtr^.InsertIncorrFormula;
      WrongWord(paWrongFormulaBeg) @+
   end;
   endcases;
   @<Close parentheses for formula@>;
end;

@ @<Parse private formula@>=
         begin
            gSubexpPtr^.StartPrivateFormula;
            ReadWord;
            ReadWord;
            if CurWord.Kind <> sy_RightSquareBracket
            then GetArguments(MaxVisArgNbr);
            Accept(sy_RightSquareBracket,paRightSquareExp2);
            gSubexpPtr^.FinishPrivateFormula;
         end

@ @<Close parentheses for formula@>=
   while lParenthCnt > 0 do
   begin
      ConditionalTail;
      gSubexpPtr^.ProcessRightParenthesis;
      Accept(sy_RightParanthesis,paRightParenthExp4);
      dec(lParenthCnt);
      CloseParenth(lParenthCnt);
   end

@ \node{Precedence for logical connectives.}
We will now ``hardcode'' the precedence for logical connectives into
the Mizar Parser. Negations (``\texttt{not}'') binds tighter than
conjunction (``\texttt{\AM}''), which binds tighter than disjunction
(``\texttt{or}''), which binds tighter than implication
(``\texttt{implies}'' and ``\texttt{iff}'').

At this point, for the formula ``\texttt{A \AM\ B}'', the Parser has
parsed a formula (``\texttt{A}''), and we want to parse possible
conjunctions. The current token will be ``\texttt{\AM}''. If not, then
the Parser does nothing: it's ``done''.

We will parse conjunction as left associative --- so
``\texttt{A \AM\ B \AM\ C}'' parses as ``\texttt{(A \AM\ B) \AM\ C}''.

@<Parse expressions (\texttt{parser.pas})@>=
procedure ConjunctiveTail;
begin
   while (CurWord.Kind = sy_Ampersand) and (AheadWord.Kind <> sy_Ellipsis) do
   begin
      gSubexpPtr^.ProcessBinaryConnective;
      ReadWord;
      ViableFormula;
      KillSubexpression;
      gSubexpPtr^.FinishBinaryFormula;
   end;
end;

@ Mizar parses flexary conjunctions (``$\Phi[0]$ \texttt{\AM\ \dots\ \AM}
$\Phi[n]$'') as weaker than ``ordinary conjunction''.
For example
``$\Psi$ \texttt{\AM} $\Phi[0]$ \texttt{\AM\ \dots\ \AM} $\Phi[n]$''
parses as 
``($\Psi$ \texttt{\AM} $\Phi[0]$) \texttt{\AM\ \dots\ \AM} $\Phi[n]$''.

If the user accidentally forgets the ampersand after the ellipses
(``$\Phi[0]$ \texttt{\AM\ \dots} $\Phi[n]$''), a 402 error will be
raised.

@^Error, 402@>

@<Parse expressions (\texttt{parser.pas})@>=
procedure FlexConjunctiveTail;
begin
   ConjunctiveTail;
   if CurWord.Kind = sy_Ampersand then
   begin
      Assert(AheadWord.Kind=sy_Ellipsis);
      ReadWord; ReadWord;
      Accept(sy_Ampersand,402);
      gSubexpPtr^.ProcessFlexConjunction;
      ViableFormula;
      ConjunctiveTail;
      KillSubexpression;
      gSubexpPtr^.FinishFlexConjunction;
   end;
end;

@ Disjunction binds weaker than flexary conjunction (which binds
weaker than ordinary conjunction).

As for ordinary conjunction, Mizar parses multiple disjunctions as
left associative. So ``\texttt{A or B or C}'' parses as ``\texttt{(A or B) or C}''.

@<Parse expressions (\texttt{parser.pas})@>=
procedure DisjunctiveTail;
begin
   FlexConjunctiveTail;
   while (CurWord.Kind = sy_Or) and (AheadWord.Kind <> sy_Ellipsis) do
   begin
      gSubexpPtr^.ProcessBinaryConnective;
      ReadWord;
      ViableFormula;
      FlexConjunctiveTail;
      KillSubexpression;
      gSubexpPtr^.FinishBinaryFormula;
   end;
end;

@ Parsing a disjunction will have the Parser's current token be
``\texttt{or}'' only if the next token is an ellipsis (``\texttt{...}''),
which is precisely the signal for a flexary disjunction. When the
current token is not an ``\texttt{or}'', then the Parser does nothing
(its work is done).

When the user forgets an ``\texttt{or}'' after ellipsis (e.g., writing
``\texttt{A or ... C}''), a 401 error will be raised.

@^Error, 401@>

@<Parse expressions (\texttt{parser.pas})@>=
procedure FlexDisjunctiveTail;
begin DisjunctiveTail;
if CurWord.Kind = sy_Or then
begin
   Assert(AheadWord.Kind=sy_Ellipsis);
   ReadWord; ReadWord;
   Accept(sy_Or,401);
   gSubexpPtr^.ProcessFlexDisjunction;
   ViableFormula;
   DisjunctiveTail;
   KillSubexpression;
   gSubexpPtr^.FinishFlexDisjunction;
end;
end;

@ Mizar parses ``\texttt{implies}'' and ``\texttt{iff}'' with lower
precedence than ``\texttt{or}'', matching common Mathematical
practice. Working Mathematicians read ``\texttt{A or B implies C}'' 
as ``\texttt{(A or B) implies C}''. We impose this precedence with the
|FlexDisjunctiveTail| parsing the remaining disjunctions before
checking for ``\texttt{iff}'' or ``\texttt{implies}''.

Mizar accepts one ``topmost'' implication connective. So
``\texttt{A implies B implies C}'' would be illegal (a 336 error would
be raised). You would have to insert parentheses to make this
parseable by Mizar (i.e., ``\texttt{A implies (B implies C)}'').
This makes sense for implication, but there is a
compelling argument that ``\texttt{A iff B iff C}'' could be parsed as
``\texttt{(A iff B) \AM\ (B iff C)}'' --- that latter
formula \emph{could} be parsed properly by Mizar.

@^Error, 336@>

@<Parse expressions (\texttt{parser.pas})@>=
procedure ConditionalTail;
begin
   FlexDisjunctiveTail;
   case CurWord.Kind of
      sy_Implies,sy_Iff:
         begin
            gSubexpPtr^.ProcessBinaryConnective;
            ReadWord;
            ViableFormula;
            FlexDisjunctiveTail;
            KillSubexpression;
            gSubexpPtr^.FinishBinaryFormula;
            case CurWord.Kind of
               sy_Implies, sy_Iff: WrongWord(paUnexpConnective);
            endcases;
         end;
   endcases;
end;

@ \node{Formula subexpressions.} When the Parser needs a formula as a
subexpression for a larger expression --- like when it parses a
Fraenkel term (an expression), the Parser will need to parse
$$\LB\<Term>\ \<Qualifying-Segment>\hbox{ \texttt{:} }\<Formula-Subexpression>\RB$$
This will also serve as the ``workhorse'' for parsing a formula
expression. 

@<Parse expressions (\texttt{parser.pas})@>=
procedure FormulaSubexpression;
begin
   ViableFormula;
   ConditionalTail;
   KillSubexpression;
end;

@* [S] Communication with items.
When the Parser constructs the AST for a term, the workflow is as
follows:
\smallbreak
\enumerate
\item Allocate a new \\{extExpression} object, and update \\{gExprPtr}
to point at it.
\item Using the \\{gExprPtr} to allocate a new \\{extSubexp} object,
and update the \\{gSubexpPtr} to point at it.
\item The Parser will invoke methods for the \\{gSubexpPtr}'s
reference to build the AST. The result will be stored in a state
variable (like \\{gLastTerm} or \\{gLastType}).
\item There will be residual objects allocated, stored in the fields
of \\{gSubexpPtr} and \\{gExpPtr}. We need to clean those up, freeing
them, by invoking \\{KillExpression} and \\{KillSubexpression}.
\endenumerate
\smallbreak\noindent%
So each of these methods have the following template: allocate a new
expression object, update the \\{gExpPtr} to point to it, parse
something, then free the \\{gExpPtr} using the \\{KillExpression} procedure.

@<Communicate with items (\texttt{parser.pas})@>=
{{\it Communication with items}}

procedure TermExpression;
begin
   gItemPtr^.CreateExpression(exTerm);
   TermSubexpression;
   KillExpression;
end; @#

procedure TypeExpression;
begin
   gItemPtr^.CreateExpression(exType);
   TypeSubexpression;
   KillExpression;
end; @#

procedure FormulaExpression;
begin
   gItemPtr^.CreateExpression(exFormula);
   FormulaSubexpression;
   KillExpression;
end;

@* [S] Miscellaneous.
When the Parser is looking at a label, the \\{gItemPtr} will construct
the label. The Parser still needs to move past the ``\<identifier>\texttt{:}''
two tokens.

@<Process miscellany (\texttt{parser.pas})@>=
{{\it Miscellaneous}}

procedure ProcessLab;
begin
   gItemPtr^.ProcessLabel; {(\section\xref{extItemObj.ProcessLabel})}
   if (CurWord.Kind=Identifier) and (AheadWord.Kind=sy_Colon) then
   begin
      ReadWord;
      ReadWord @+
   end;
end;

@ Telling the \\{gItemPtr} state variable we are about to parse a
sentence just invokes the \\{StartSentence}
(\section\xref{extItemObj.StartSentence}) method, then the Parser
parses the formula, and the \\{gItemPtr} ``finishes'' the sentence
(which is an empty method).

@<Process miscellany (\texttt{parser.pas})@>=
procedure ProcessSentence;
begin
   gItemPtr^.StartSentence;
   FormulaExpression;
   gItemPtr^.FinishSentence;
end;

@ When the Parser expected a sentence but something unexpected
happened, specifically an unexpected statement has cross the Parser's
path. When that statement has encountered an unjustified ``\texttt{per cases}''.
We just create a new formula expression, and specifically an
``incorrect formula''.

@<Process miscellany (\texttt{parser.pas})@>=
procedure InCorrSentence;
begin
   gItemPtr^.StartSentence;
   gItemPtr^.CreateExpression(exFormula);
   gExpPtr^.CreateSubexpression;
   gSubexpPtr^.InsertIncorrFormula;
   KillSubexpression;
   KillExpression;
   gItemPtr^.FinishSentence;
end;

@ The Parser attempts to recover (or at least, report) an unexpected
item when expecting a statement. Specifically, a ``\texttt{per cases}''
appears when it should not.

@<Process miscellany (\texttt{parser.pas})@>=
procedure InCorrStatement;
begin
   gItemPtr^.ProcessLabel;
   gItemPtr^.StartRegularStatement;
   InCorrSentence;
end;

@ The Parser is looking at either
$$\hbox{\texttt{let} }\<Variables>\hbox{ \texttt{being} }\<Type>\hbox{ \texttt{such that} }\<Hypotheses>$$
or
$$\hbox{\texttt{assume that} }\<Hypotheses>$$
Specifically, the Parser has arrived at the ``\<Hypotheses>'' bit and
needs to parse it. The \<Hypotheses> generically looks like
$$\<Hypotheses> = [\<label>]\ \<Formula>\ \LB\hbox{ \texttt{and} }\<Hypotheses>\ \RB$$
That is to say, a bunch of (possibly labeled) formulas joined together
by ``\texttt{and}'' keywords.

@<Process miscellany (\texttt{parser.pas})@>=
procedure ProcessHypotheses;
begin
   repeat
      ProcessLab;
      ProcessSentence;
      gItemPtr^.FinishHypothesis;
   until not Occurs(sy_And)
end;

@ An assumption is either collective (using hypotheses) or singular (a
single, possibly labeled, formula).

@<Process miscellany (\texttt{parser.pas})@>=
procedure Assumption;
begin
   if CurWord.Kind = sy_That then
   begin
      gItemPtr^.StartCollectiveAssumption; 
      ReadWord;
      ProcessHypotheses
   end
   else
   begin
      ProcessLab;
      ProcessSentence;
      gItemPtr^.FinishHypothesis;
   end;
   gItemPtr^.FinishAssumption;
end;

@ Existential elimination in Mizar looks like
$$\hbox{\texttt{consider} }\<Fixed-variables>\hbox{ \texttt{such that} }\<Formula>$$
The \<Fixed-variables> is just a comma-separated list of segments.

\label{FixedVariables:parser.pas}
@<Process miscellany (\texttt{parser.pas})@>=
procedure FixedVariables;
begin
   gItemPtr^.StartFixedVariables;
   repeat
      @<Parse segment of fixed variables@>;
   until not Occurs(sy_Comma);
   gItemPtr^.FinishFixedVariables;
end;

@ And a ``fixed'' segment is just a comma-separated list of variables.
This is either implicitly qualified (i.e., they are all reserved
variables) or explicitly qualified (i.e., there is a
``\texttt{being}'' or ``\texttt{be}'', followed by a type). A 300
error will be raised if the comma-separated list of variables
encounters something other than an identifier.

@^Error, 300@>

@<Parse segment of fixed variables@>=
      gItemPtr^.StartFixedSegment;
      repeat
         gItemPtr^.ProcessFixedVariable;
         Accept(Identifier,paIdentExp4);
      until not Occurs(sy_Comma);
      gItemPtr^.ProcessBeing; {parse the type qualification}
      if Occurs(sy_Be) or Occurs(sy_Being) then TypeExpression;
      gItemPtr^.FinishFixedSegment

@ The Parser is trying to parse a ``\texttt{consider}'' statement or a
``\texttt{given}'' statement. The Parser will try to parse
$$\<Fixed-Variables>\hbox{ \texttt{such that} }\<Formula>\ \LB\hbox{ \texttt{and} }\<Formula>\ \RB$$
If the user forgot the ``\texttt{such}'' keyword, a 403 error will be
raised. If the user forgot the ``\texttt{that}'' keyword, a 350 error
will be raised.

@^Error, 350@>
@^Error, 403@>

@<Process miscellany (\texttt{parser.pas})@>=
procedure ProcessChoice;
begin
   FixedVariables;
   Accept(sy_Such,paSuchExp);
   Accept(sy_That,paThatExp2);
   repeat 
      gItemPtr^.StartCondition;
      ProcessLab;
      ProcessSentence;
      gItemPtr^.FinishCondition;
   until not Occurs(sy_And);
   gItemPtr^.FinishChoice;
end;

@ The Parser is looking at the ``\texttt{let}'' token. There are two
possible statements
$$\hbox{\texttt{let }}\<Fixed-variables>\hbox{\texttt{;}}$$
or possibly with assumptions
$$\hbox{\texttt{let }}\<Fixed-variables>\hbox{ \texttt{such that} }\<Hypotheses>\hbox{\texttt{;}}$$
If the user forgot ``\texttt{that}'' but included a ``\texttt{such}''
after the fixed-variables, a 350 error is raised.

@^Error, 350@>

@<Process miscellany (\texttt{parser.pas})@>=
procedure Generalization;
begin
   ReadWord;
   FixedVariables;
   if Occurs(sy_Such) then
   begin
      gItemPtr^.StartAssumption;
      Accept(sy_That,paThatExp1);
      ProcessHypotheses;
      gItemPtr^.FinishAssumption;
   end;
end;

@ The Parser is looking at the ``\texttt{given}'' token
currently. This is the same as ``\texttt{assume ex}
$\vec{x}$ \texttt{st} $\Phi[\vec{x}]$\texttt{; then consider}
$\vec{x}$ \texttt{such that} $\Phi[\vec{x}]$\texttt{;}''. 

@<Process miscellany (\texttt{parser.pas})@>=
procedure ExistentialAssumption;
begin
   gBlockPtr^.CreateItem(itExistentialAssumption);
   ReadWord;
   ProcessChoice;
end;

@ The Parser is looking at either ``\texttt{canceled;}'' or ``\texttt{canceled}
\<number>\texttt{;}''. 

@<Process miscellany (\texttt{parser.pas})@>=
procedure Canceled;
begin
   gBlockPtr^.CreateItem(itCanceled);
   ReadWord;
   if CurWord.Kind = Numeral then ReadWord;
   gItemPtr^.FinishTheorem;
end;

@* [S] Simple justifications.
The Parser is looking at ``\texttt{by}'' and now needs to parse the
list of references. If the user tries to use something other than a
label's identifier as a reference, then a 308 error will be raised.

@^Error, 308@>

@<Parse simple justifications (\texttt{parser.pas})@>=
{{\it Simple Justifications}}

procedure GetReferences;
begin
   gItemPtr^.StartReferences;
   repeat
      ReadWord;
      @<Parse single reference@>;
   until CurWord.Kind <> sy_Comma;
   gItemPtr^.FinishReferences;
end;

@ @<Parse single reference@>=
      case CurWord.Kind of
         MMLIdentifier:
            @<Parse library references@>;
         Identifier:
            begin
               gItemPtr^.ProcessPrivateReference;
               ReadWord @+
            end;
      othercases WrongWord(paWrongReferenceBeg);
      endcases

@ Mizar supports multiple references from the same article to
``piggieback'' off the same article ``anchor''. For example,
``\texttt{GROUP\_1:13,def 3,17}'' refers to theorems 13 and 17 and
definition 3 from the MML Article \texttt{GROUP\_1}.

If the user forgot to include the theorem or definition number ---
so they just wrote ``\<Article>'' instead of ``\<Article>\texttt{:}\<Number>''
or ``\<Article>\texttt{:def }\<Number>'' --- then Mizar flags this
with a 384 error.

@d no_longer_referencing_article == (CurWord.Kind <> sy_Comma) or@|
                     (AheadWord.Kind = Identifier) or (AheadWord.Kind = MMLIdentifier)

@<Parse library references@>=
            begin
               gItemPtr^.StartLibraryReferences;
               ReadWord;
               if CurWord.Kind = sy_Colon then
                  repeat
                     ReadWord;
                     gItemPtr^.ProcessDef;
                     if CurWord.Kind = ReferenceSort then
                     begin
                        if CurWord.Nr <> ord(syDef) then ErrImm(paDefExp);
                        ReadWord;
                     end;
                     gItemPtr^.ProcessTheoremNumber;
                     Accept(Numeral,paNumExp);
                  until no_longer_referencing_article
               else MissingWord(paColonExp4);
               gItemPtr^.FinishTheLibraryReferences;
            end

@ The Parser is currently looking at ``\texttt{from}'', which means a
reference to a scheme identifier will be given next (possibly followed
with a comma-separated list of references in parentheses).

If the user
tries to give something else (instead of an identifier of a scheme),
then a 308 error will be raised. Also, if the user forgot the closing
parentheses around the references for the scheme (e.g., ``\texttt{from MyScheme(A1,A2}''),
then 370 error will be raised.

@^Error, 308@>
@^Error, 370@>

@<Parse simple justifications (\texttt{parser.pas})@>=
procedure GetSchemeReference;
begin
   gItemPtr^.StartSchemeReference;
   ReadWord;
   case CurWord.Kind of
      MMLIdentifier:
         @<Parse reference to scheme from MML@>;
      Identifier:
         begin
            gItemPtr^.ProcessSchemeReference;
            ReadWord @+
         end;
   othercases WrongWord(paWrongReferenceBeg);
   endcases;
   if CurWord.Kind = sy_LeftParanthesis then
   begin
      GetReferences;
      Accept(sy_RightParanthesis,paRightParenthExp7)
   end;
   gItemPtr^.FinishSchemeReference;
end;

@ Mizar expects scheme references to the MML to be of the form
``\texttt{from} \<Article>\texttt{:sch }\<Number>''. If the user
forgot the ``\texttt{sch}'' (after the colon), a 313 error will be
raised. If the user supplies something other than a \emph{number} for
the scheme, a 307 error will be raised.

@^Error, 307@>
@^Error, 313@>

@<Parse reference to scheme from MML@>=
         begin
            gItemPtr^.StartSchemeLibraryReference;
            ReadWord;
            if CurWord.Kind = sy_Colon then
            begin
               ReadWord;
               gItemPtr^.ProcessSch;
               if CurWord.Kind = ReferenceSort then
               begin
                  if CurWord.Nr <> ord(sySch) then ErrImm(paSchExp);
                  ReadWord;
               end
               else ErrImm(paSchExp);
               gItemPtr^.ProcessSchemeNumber;
               Accept(Numeral,paNumExp);
            end
            else MissingWord(paColonExp4);
            gItemPtr^.FinishSchLibraryReferences;
         end

@ The Parser expects a simple justification --- i.e., either a
``\texttt{by}'' followed by some references, or ``\texttt{from}''
followed by a scheme reference. For some ``obvious'' inferences, no
justification may be needed.

@<Parse simple justifications (\texttt{parser.pas})@>=
procedure SimpleJustification;
begin
   gItemPtr^.StartSimpleJustification;
   case CurWord.Kind of
      sy_By: GetReferences;
      sy_Semicolon,sy_DotEquals: ;
      sy_From: GetSchemeReference;
   othercases WrongWord(paWrongJustificationBeg);
   endcases;
   gItemPtr^.FinishSimpleJustification;
end;

@* [S] Statements and Reasonings.
Pragmas have been enabled which tells Mizar to skip the proof. The
Parser simply stores a counter (initialized to 1), and increments it
every time a ``\texttt{proof}'' token has been encountered, but
decrements it every time an ``\texttt{end}'' token has been encountered.
When the counter has reached zero, the proof has ended, and the Parser
can stop skipping things.

There are, of course, other blocks which use ``\texttt{end}'' to
terminate it. For example, definitions. But if the Parser should
encounter such tokens, then things have gone so horribly awry, the
Parser should just quit here and now.

@<Parse statements and reasoning (\texttt{parser.pas})@>=
{{\it Statements   \AM\   Reasonings}}

procedure @? Reasoning; forward; @t\2@>@#

procedure IgnoreProof;
var lCounter: integer; ReasPos:Position;
begin
   gBlockPtr^.StartAtSignProof;
   ReasPos:=CurPos;
   ReadTokenProc;
   lCounter:=1;
   repeat
      case CurWord.Kind of
         sy_Proof,sy_Now,sy_Hereby,sy_Case,sy_Suppose: inc(lCounter);
         sy_End: dec(lCounter);
         sy_Reserve,sy_Scheme,sy_Theorem,sy_Definition,sy_Begin,sy_Notation,
         sy_Registration,EOT:
            begin
               AcceptEnd(ReasPos);
               exit
            end;
      endcases;
      ReadTokenProc;
   until lCounter=0;
   gBlockPtr^.FinishAtSignProof;
end;

@ Parsing either a ``\texttt{by}'' justification (or a
``\texttt{from}'' justification) or a nested
``\texttt{proof}'' block. If the Parser is looking at neither
situation, the \\{SimpleJustification} procedure will raise errors.

\label{Justification:parser.pas}

@d parse_proof == 
         if ProofPragma then Reasoning
         else IgnoreProof

@<Parse statements and reasoning (\texttt{parser.pas})@>=
procedure Justification;
begin
   gItemPtr^.StartJustification;
   case CurWord.Kind of
      sy_Proof: parse_proof;
   othercases SimpleJustification;
   endcases;
   gItemPtr^.FinishJustification;
end;

@ For private predicates (``\texttt{defpred}'') and private functors
(``\texttt{deffunc}''), there will be a list of comma-separated types
for the arguments of the private definition.

@d parse_comma_separated_types ==
      repeat
         TypeExpression;
         gItemPtr^.FinishLocusType
      until not Occurs(sy_Comma)
@<Parse statements and reasoning (\texttt{parser.pas})@>=
procedure ReadTypeList;
begin
   case CurWord.Kind of
      sy_RightSquareBracket,sy_RightParanthesis:;
   othercases parse_comma_separated_types;
   endcases;
end;

@ A \define{Private Item} is a statement (``item'') which introduces a
new constant local (``private'') to the block or article.

@d other_regular_statements == 
      Identifier,sy_Now,sy_For,sy_Ex,sy_Not,sy_Thesis,sy_LeftSquareBracket,
      sy_Contradiction,PredicateSymbol,sy_Does,sy_Do,sy_Equal,InfixOperatorSymbol,
      Numeral,LeftCircumfixSymbol,sy_LeftParanthesis,sy_It,sy_Dolar,
      StructureSymbol,sy_The,sy_LeftCurlyBracket,sy_Proof

@<Parse statements and reasoning (\texttt{parser.pas})@>=
procedure @? RegularStatement; forward@t\2@>; {(\section\xref{RegularStatement:parser.pas})} 

procedure PrivateItem;
begin
   gBlockPtr^.ProcessLink;
   if CurWord.Kind = sy_Then then ReadWord;
   case CurWord.Kind of
      sy_Deffunc:
         @<Parse a ``\texttt{deffunc}''@>;
      sy_Defpred:
         @<Parse a ``\texttt{defpred}''@>;
      sy_Set:
         @<Parse a ``\texttt{set}'' constant definition@>;
      sy_Reconsider:
         @<Parse a ``\texttt{reconsider}'' statement@>;
      sy_Consider:
         begin
            gBlockPtr^.CreateItem(itChoice);
            ReadWord;
            ProcessChoice;
            SimpleJustification;
         end;
      other_regular_statements:
         begin
            gBlockPtr^.CreateItem(itRegularStatement);
            RegularStatement; @+
         end;
   othercases
   begin
      gBlockPtr^.CreateItem(itIncorrItem);
      WrongWord(paWrongItemBeg); @+
   end;
   endcases;
end;

@ @<Parse a ``\texttt{deffunc}''@>=
         begin
            gBlockPtr^.CreateItem(itPrivFuncDefinition);
            ReadWord;
            gItemPtr^.StartPrivateDefiniendum;
            Accept(Identifier,paIdentExp6);
            Accept(sy_LeftParanthesis,paLeftParenthExp);
            ReadTypeList;
            Accept(sy_RightParanthesis,paRightParenthExp8);
            gItemPtr^.StartPrivateDefiniens;
            Accept(sy_Equal,paEqualityExp1);
            TermExpression;
            gItemPtr^.FinishPrivateFuncDefinienition;
         end

@ @<Parse a ``\texttt{defpred}''@>=
         begin
            gBlockPtr^.CreateItem(itPrivPredDefinition);
            ReadWord;
            gItemPtr^.StartPrivateDefiniendum;
            Accept(Identifier,paIdentExp7);
            Accept(sy_LeftSquareBracket,paLeftSquareExp);
            ReadTypeList;
            Accept(sy_RightSquareBracket,paRightSquareExp4);
            gItemPtr^.StartPrivateDefiniens;
            Accept(sy_Means,paMeansExp);
            FormulaExpression;
            gItemPtr^.FinishPrivatePredDefinienition;
         end

@ @<Parse a ``\texttt{set}'' constant definition@>=
         begin
            gBlockPtr^.CreateItem(itConstantDefinition);
            ReadWord;
            repeat
               gItemPtr^.StartPrivateConstant;
               Accept(Identifier,paIdentExp8);
               Accept(sy_Equal,paEqualityExp2);
               TermExpression;
               gItemPtr^.FinishPrivateConstant;
            until not Occurs(sy_Comma);
         end

@ @<Parse a ``\texttt{reconsider}'' statement@>=
         begin
            gBlockPtr^.CreateItem(itReconsider);
            ReadWord;
            repeat
               gItemPtr^.ProcessReconsideredVariable;
               Accept(Identifier,paIdentExp9);
               case CurWord.Kind of
                  sy_Equal:
                     begin
                        ReadWord;
                        TermExpression;
                        gItemPtr^.FinishReconsideredTerm;
                     end;
               else gItemPtr^.FinishDefaultTerm;
               end;
            until not Occurs(sy_Comma);
            gItemPtr^.StartNewType;
            Accept(sy_As,paAsExp);
            TypeExpression;
            gItemPtr^.FinishReconsidering;  
            SimpleJustification;
         end

@ The \\{SetParserPragma} toggles the state variables for skipping
proofs, and storing the pragma in the AST is handled by
the \\{gBlockPtr}'s method call.

\label{ProcessPragmas:parser}

@<Parse statements and reasoning (\texttt{parser.pas})@>=
procedure ProcessPragmas;
begin
   while CurWord.Kind = Pragma do
   begin
      SetParserPragma(CurWord.Spelling); {(\section\xref{SetParserPragma})}
      gBlockPtr^.ProcessPragma; {(\section\xref{extBlockObj.ProcessPragma})}
      ReadTokenProc;
   end;
end;

@ \node{Reasoning items.} The ``linear reasoning'' portion of the
parser corresponds to what ``Mizar in a Nutshell'' refers to as a
sequence of ``Reasoning Items''. Basically, everything exception
``\texttt{per cases}''.

@<Parse statements and reasoning (\texttt{parser.pas})@>=
procedure LinearReasoning;
begin
   while CurWord.Kind <> sy_End do
   begin
      StillCorrect:=true;
      ProcessPragmas;
      @<Parse statement of linear reasoning@>; @/
      Semicolon;
   end;
end;

@ Most statements are delegated to their own dedicated function.

@<Parse statement of linear reasoning@>=
      case CurWord.Kind of
         sy_Let:
            begin
               gBlockPtr^.CreateItem(itGeneralization);
               Generalization; @+
            end;
         sy_Given: ExistentialAssumption;
         sy_Assume:
            begin
               gBlockPtr^.CreateItem(itAssumption);
               ReadWord;
               Assumption; @+
            end;
         sy_Take:
            @<Parse ``\texttt{take}'' statement for linear reasoning@>;
         sy_Hereby:
            begin
               gBlockPtr^.CreateItem(itConclusion);
               Reasoning; @+
            end;
@t\4@>    @<Parse ``\texttt{thus}'' and ``\texttt{hence}'' for linear reasoning@>;
         sy_Per: exit;
         sy_Case,sy_Suppose: exit;
         sy_Reserve,sy_Scheme,sy_Theorem,sy_Definition,sy_Begin,sy_Notation,
         sy_Registration,EOT: exit;
         sy_Then:
            @<Parse ``\texttt{then}'' for linear reasoning@>;
      othercases
         PrivateItem;
      endcases

@ \node{Take statements.}
We recall the syntax for a ``\texttt{take}'' statement:
$$\hbox{\texttt{take} }(\<Term>\ \pipe\ \<Variable> = \<Term>)\ \LB\hbox{\texttt{","} }(\<Term>\ \pipe\ \<Variable> = \<Term>)\RB$$
That is, a comma-separated list of either (1) terms, or (2) a variable
equal to a term.

@<Parse ``\texttt{take}'' statement for linear reasoning@>=
            begin
               gBlockPtr^.CreateItem(itExemplification);
               ReadWord;
               repeat
                  if (CurWord.Kind=Identifier) and (AheadWord.Kind=sy_Equal) then
                  begin
                     gItemPtr^.ProcessExemplifyingVariable;
                     ReadWord;
                     ReadWord;
                     TermExpression;
                     gItemPtr^.FinishExemplifyingVariable;
                  end
                  else
                  begin
                     gItemPtr^.StartExemplifyingTerm;
                     TermExpression;
                     gItemPtr^.FinishExemplifyingTerm;
                  end;
               until not Occurs(sy_Comma);
            end

@ \node{Thus statements.} Both ``\texttt{thus}'' and
``\texttt{hence}'' (which is syntactic sugar for ``\texttt{then
thus}'') are parsed similarly. So it bears studying them in parallel.
The ``heavy lifting'' is handled by the \\{RegularStatement} for
parsing the formula. But the \\{gBlockPtr} state variable ``primes the pump''
by creating a ``conclusion'' statement.

@<Parse ``\texttt{thus}'' and ``\texttt{hence}'' for linear reasoning@>=
         sy_Hence:
            begin
               gBlockPtr^.ProcessLink;
               ReadWord;
               gBlockPtr^.CreateItem(itConclusion);
               RegularStatement;
            end;
         sy_Thus:
            begin
               ReadWord;
               gBlockPtr^.ProcessLink;
               if CurWord.Kind = sy_Then then ReadWord;
               gBlockPtr^.CreateItem(itConclusion);
               RegularStatement;
            end

@ \node{Parsing `then' linked statements.}

@<Parse ``\texttt{then}'' for linear reasoning@>=
            begin
               if AheadWord.Kind = sy_Per then
               begin
                  gBlockPtr^.ProcessLink;
                  ReadWord;
                  exit; @+
               end
               else
                  PrivateItem;
            end


@ \node{Non-block Reasoning.} The Parser has just encountered a
``\texttt{per cases}'' statement. Now it must parse
``\texttt{suppose}'' items.


@<Parse statements and reasoning (\texttt{parser.pas})@>=
procedure NonBlockReasoning;
var CasePos: Position; lCaseKind:TokenKind;
   @<Process ``\texttt{case}'' (local procedure)@>;

begin
   case CurWord.Kind of
      sy_Per,sy_Case,sy_Suppose:
         begin
            gBlockPtr^.CreateItem(itPerCases);
            @<Consume ``\texttt{per cases}'', raise an error if they're missing@>;
            if (CurWord.Kind <> sy_Case) and (CurWord.Kind <> sy_Suppose) then
            @<Try to synchronize after failing to find initial `\texttt{case}' or `\texttt{suppose}'@>;
            repeat
               @<Parse ``\texttt{suppose}'' or ``\texttt{case}'' block@>;
            until (Curword.Kind = sy_End);
         end;
   endcases;
end;

@ Each ``\texttt{case}'' or ``\texttt{suppose}'' block consists of
zero or more linear reasoning items, followed possibly by an optional
``non-block reasoning'' proof (i.e., another nested ``\texttt{per cases}''
proof by cases).

@<Process ``\texttt{case}'' (local procedure)@>=
   procedure ProcessCase;
   begin
      Assumption;
      Semicolon;
      LinearReasoning;
      if CurWord.Kind = sy_Per then
         NonBlockReasoning;
      KillBlock;
      AcceptEnd(CasePos);
      Semicolon;
   end

@ The Parser looks for ``\texttt{per cases}'' tokens, and some simple
justification for the statement. If ``\texttt{per}'' is missing, a 231
error is raised. If the ``\texttt{cases}'' is missing, a 351 error is raised.
When this code chunk is done, the Parser is looking at either a
``\texttt{suppose}'' token or a ``\texttt{case}'' token.

@^Error, 231@>
@^Error, 351@>

@<Consume ``\texttt{per cases}'', raise an error if they're missing@>=
            Accept(sy_Per,paPerExp);
            Accept(sy_Cases,paCasesExp);
            SimpleJustification; 
            Semicolon;
            lCaseKind:=CurWord.Kind

@ The Parser is expecting ``\texttt{suppose}'' or ``\texttt{case}''
after the ``\texttt{per cases}'' statement. But if the Parser fails to
find either of these tokens, it \emph{should} enter panic mode.

Like a person falling off a cliff reaches out for something to grab,
the Parser in panic mode seeks something to ``grab on to'' so the
Parser can ``soldier on''. The technical term for this situation is
that the Parser is trying to ``synchronize'' (usually people just talk
about ``synchronization'').

Mizar raises a 232 error.

@^Error, 232@>

@<Try to synchronize after failing to find initial `\texttt{case}' or `\texttt{suppose}'@>=
            begin
               MissingWord(paSupposeOrCaseExp);
               lCaseKind:=sy_Suppose;
               gBlockPtr^.CreateItem(itCaseBlock);
               gBlockPtr^.CreateBlock(blSuppose);
               gBlockPtr^.CreateItem(itSupposeHead);
               StillCorrect:=true;
               CasePos:=CurPos;
               ProcessCase;
            end

@ @<Parse ``\texttt{suppose}'' or ``\texttt{case}'' block@>=
               while (CurWord.Kind = sy_Case) or (CurWord.Kind = sy_Suppose) do
               @<Parse contents of ``\texttt{suppose}'' block@>;
               case Curword.Kind of
                  sy_Reserve,sy_Scheme,sy_Theorem,sy_Definition,sy_Begin,sy_Notation,
                  sy_Registration,EOT: exit;
                  sy_End: ;
               othercases
               @<Synchronize after missing `\texttt{suppose}' or `\texttt{case}' token@>;
               endcases

@ Parsing the contents of a ``\texttt{suppose}'' or ``\texttt{case}''
block requires creating a new block (for the, you know, block) and
creating a new item for the ``\texttt{suppose} \<Formula>'' or
``\texttt{case} \<Formula>'' statement.

If the user tries to ``mix and match'' the different kind of
suppositions (i.e., ``\texttt{case}'' and ``\texttt{suppose}''), then
a 58 error should be raised.

@:Error, 058}{Error, 58@>

@d create_supposition_block ==
                  if lCaseKind = sy_Case then gBlockPtr^.CreateBlock(blCase)
                  else gBlockPtr^.CreateBlock(blSuppose)
@d create_supposition_head ==
                  if lCaseKind = sy_Case then gBlockPtr^.CreateItem(itCaseHead)
                  else gBlockPtr^.CreateItem(itSupposeHead)
@<Parse contents of ``\texttt{suppose}'' block@>=
               begin
                  gBlockPtr^.CreateItem(itCaseBlock);
                  create_supposition_block;
                  CasePos:=CurPos;
                  StillCorrect:=true;
                  create_supposition_head;
                  if CurWord.Kind <> lCaseKind then ErrImm(58); 
                  ReadWord;
                  ProcessCase;
               end

@ @<Synchronize after missing `\texttt{suppose}' or `\texttt{case}' token@>=
               begin
                  MissingWord(paSupposeOrCaseExp);
                  gBlockPtr^.CreateItem(itCaseBlock);
                  create_supposition_block;
                  create_supposition_head;
                  StillCorrect:=true;
                  CasePos:=CurPos;
                  ProcessCase;
               end

@ \node{Reasoning.} The Parser is looking at ``\texttt{proof}'',
``\texttt{hereby}'', or ``\texttt{now}''. The syntax for Mizar says
that we should expect linear reasoning statements, followed by
non-block reasoning (i.e., at most
one ``\texttt{per cases}'' statement, and then ``\texttt{suppose}'' or
``\texttt{case}'' blocks).

@<Parse statements and reasoning (\texttt{parser.pas})@>=
procedure Reasoning;
var ReasPos: Position;
begin
   ReasPos:=CurPos;
   case CurWord.Kind of
      sy_Proof:
         begin
            gBlockPtr^.CreateBlock(blProof);
            ReadTokenProc; @+
         end;
      sy_Hereby:
         begin
            gBlockPtr^.CreateBlock(blHereby);
            ReadTokenProc; @+
         end;
      sy_Now:
         begin
            gBlockPtr^.CreateBlock(blDiffuse);
            ReadTokenProc; @+
         end;
   othercases
   begin
      gBlockPtr^.CreateBlock(blProof);
      WrongWord(paProofExp); @+
   end;
   endcases; @#
   LinearReasoning;
   NonBlockReasoning;
   KillBlock;
   AcceptEnd(ReasPos);
end;

@ \node{Regular statements.} A regular statement is one of the
following:
\enumerate
\item ``\texttt{now}'' followed by reasoning;
\item A sentence (i.e., possibly labeled formula) followed by a
  ``\texttt{proof}'' block;
\item Iterative equalities.
\endenumerate

\label{RegularStatement:parser.pas}

@<Parse statements and reasoning (\texttt{parser.pas})@>=
procedure RegularStatement;
begin
   ProcessLab;
   gItemPtr^.StartRegularStatement;
   case CurWord.Kind of
      sy_Now: Reasoning;
   othercases
   begin
      ProcessSentence;
      case CurWord.Kind of
         sy_Proof:
            @<Parse ``\texttt{proof}'' block@>;
      othercases
      begin
         gItemPtr^.StartJustification;
         SimpleJustification;
         gItemPtr^.FinishJustification;
         gItemPtr^.FinishCompactStatement;
         while CurWord.Kind = sy_DotEquals do
         @<Parse iterative equations@>;
      end;
      endcases;
   end;
   endcases;
end;

@ @<Parse ``\texttt{proof}'' block@>=
            begin
               gItemPtr^.StartJustification;
               if ProofPragma then Reasoning else IgnoreProof;
               gItemPtr^.FinishJustification;
            end

@ @<Parse iterative equations@>=
         begin
            gItemPtr^.StartIterativeStep;
            ReadWord;
            TermExpression;
            gItemPtr^.ProcessIterativeStep; 
            gItemPtr^.StartJustification;
            SimpleJustification;
            gItemPtr^.FinishJustification;
            gItemPtr^.FinishIterativeStep;
         end

@* [S] Patterns.
Visible arguments (compared to ``hidden arguments'') appear to the
left or right of a functor or predicate (or to the left of an
attribute, or to the right of a mode or
structure). The \\{gVisibleNbr} state variable is initialized to zero
when the Parser starts parsing visible arguments, and the Parser
increments it for each visible argument in the pattern.

If a non-identifier appears in a pattern, Mizar raises a 300 error. So
you cannot be clever and try to trick Mizar into thinking ``\texttt{0 + x}''
is a pattern.

@^Error, 300@>
\label{GetVisible:parser.pas}

@<Parse patterns (\texttt{parser.pas})@>=
{{\it Patterns}}

var gVisibleNbr: integer;

procedure GetVisible;
begin
   gItemPtr^.ProcessVisible; {(\section\xref{extItemObj.ProcessVisible})}
   inc(gVisibleNbr);
   Accept(Identifier,paIdentExp3);
end;

@ We will need to Parse a comma-separated list of identifiers when
determining a pattern.

@<Parse patterns (\texttt{parser.pas})@>=
procedure ReadVisible;
begin
   gItemPtr^.StartVisible;
   gVisibleNbr:=0;
   repeat
      GetVisible;
   until not Occurs(sy_Comma);
   gItemPtr^.FinishVisible; 
end;

@ There are two cases to consider when determining the pattern for a
mode: either the Parser is looking at ``\texttt{set}'' as a type,
or---the more interesting case---the Parser is looking at an
identifier which appears in a vocabulary file as a mode symbol. 

@<Parse patterns (\texttt{parser.pas})@>=
procedure GetModePattern;
var lModesymbol:integer;
begin
   gItemPtr^.StartModePattern; {(\section\xref{extItemObj.StartModePattern})}
   case CurWord.Kind of
      sy_Set:
         @<Parse pattern for ``\texttt{set}'' as a mode@>;
      ModeSymbol:
         @<Parse pattern for a mode symbols@>
   othercases WrongWord(paWrongModePatternBeg);
   endcases; @/
   gItemPtr^.FinishModePattern; {(\section\xref{extItemObj.FinishModePattern})}
end;

@ @<Parse pattern for ``\texttt{set}'' as a mode@>=
         begin
            if AheadWord.Kind = sy_Of then WrongWord(paWrongModePatternSet)
            else ReadWord;
         end

@ The ``\<Kind>\\{MaxArgs}'' entry is initialized to |$FF| before
|ReadVisible| is invoked, which is \PASCAL/ for $\H{FF}=255$. So if
the \\{ModeMaxArgs} entry for the mode symbol is (1) less than the
number of arguments parsed, or (2) uninitialized; then we should
update its entry with the \\{gVisibleNbr} state variable's current value.

@d get_index_compare_to_default(#) == [#] = $FF
@d entry_is_unitialized(#) == #.fList^get_index_compare_to_default

@<Parse pattern for a mode symbols@>=
         begin
            lModeSymbol:=CurWord.Nr;
            gVisibleNbr:=0;
            ReadWord;
            gItemPtr^.ProcessModePattern;
            if Occurs(sy_Of) then ReadVisible;
            if (ModeMaxArgs.fList^[lModeSymbol] < gVisibleNbr) or
                  (entry_is_uninitialized(ModeMaxArgs)(lModeSymbol)) then
               ModeMaxArgs.fList^[lModeSymbol] := gVisibleNbr;
         end

@ Parsing the visible arguments for a functor relies on this helper function.

@^Error, 370@>

@<Parse patterns (\texttt{parser.pas})@>=
procedure ReadParams;
begin
   if Occurs(sy_LeftParanthesis) then
   begin
      ReadVisible;
      Accept(sy_RightParanthesis,paRightParenthExp5) @+
   end
   else if CurWord.Kind = Identifier then
   begin
      gItemPtr^.StartVisible;
      GetVisible;
      gItemPtr^.FinishVisible; @+
   end;
end;

@ Attribute patterns allows for arguments \emph{only on the right} of
the attribute symbol, i.e., something like
$$\hbox{\texttt{attr} } \underbrace{\<Identifier>\hbox{ \texttt{is} }\<Arguments>\ \<Attribute-Name>}_{{\rm pattern}}\hbox{ \texttt{means}}\dots$$

\label{GetAttrPattern:parser.pas}


@^Error, 306@>
@^Error, 370@>

@<Parse patterns (\texttt{parser.pas})@>=
procedure GetAttrPattern;
begin
   gItemPtr^.StartAttributePattern;
   gVisibleNbr:=0;
   GetVisible;
   gItemPtr^.ProcessAttributePattern;
   Accept(sy_Is,paIsExp);
   if Occurs(sy_LeftParanthesis) then
   begin
      ReadVisible;
      Accept(sy_RightParanthesis,paRightParenthExp11) @+
   end
   else if CurWord.Kind = Identifier then ReadVisible;
   gItemPtr^.FinishAttributePattern;
   Accept(AttributeSymbol,paAttrExp2);
end;

@ Functor patterns generically look like:
$$\hbox{\texttt{func} }\underbrace{\<Arguments>\ \<Identifier>\ \<Arguments>}_{{\rm pattern}}\hbox{ \texttt{->}}\dots$$
or
$$\hbox{\texttt{func} }\underbrace{\<Left-Bracket>\ \<Arguments>\ \<Right-Bracket>}_{{\rm pattern}}\hbox{ \texttt{->}}\dots$$

\label{GetFuncPattern:parser.pas}

@<Parse patterns (\texttt{parser.pas})@>=
procedure GetFuncPattern;
begin
   gItemPtr^.StartFunctorPattern;
   case CurWord.Kind of
      Identifier,InfixOperatorSymbol,sy_LeftParanthesis:
         @<Parse infix functor pattern@>;
      LeftCircumfixSymbol,sy_LeftSquareBracket,sy_LeftCurlyBracket:
         @<Parse bracket functor pattern@>;
   othercases
   begin
      WrongWord(paWrongFunctorPatternBeg);
      gItemPtr^.FinishFunctorPattern; @+
   end;
   endcases;
end;

@ @<Parse infix functor pattern@>=
         begin
            ReadParams;
            gItemPtr^.ProcessFunctorSymbol; { (\section\xref{extItemObj.ProcessFunctorSymbol}) }
            Accept(InfixOperatorSymbol,paFunctExp2);
            ReadParams;
            gItemPtr^.FinishFunctorPattern;
         end

@ @<Parse bracket functor pattern@>=
         begin
            ReadWord;
            ReadVisible;
            gItemPtr^.FinishFunctorPattern;
            case Curword.Kind of
               sy_RightSquareBracket,sy_RightCurlyBracket,sy_RightParanthesis: ReadWord;
            othercases Accept(RightCircumfixSymbol,paRightBraExp2);
            endcases;
         end

@ Predicate patterns resemble infix functor patterns.

\label{GetPredPattern:parser.pas}
@<Parse patterns (\texttt{parser.pas})@>=
procedure GetPredPattern;
var lPredSymbol: integer;
begin
   gItemPtr^.StartPredicatePattern;
   if CurWord.Kind = Identifier then ReadVisible;
   gItemPtr^.ProcessPredicateSymbol;
   case CurWord.Kind of
      sy_Equal,PredicateSymbol:
         @<Parse predicate pattern@>;
   othercases WrongWord(paWrongPredPattern);
   endcases;
   gItemPtr^.FinishPredicatePattern;
end;

@ @<Parse predicate pattern@>=
         begin
            lPredSymbol:=CurWord.Nr;
            if CurWord.Kind =sy_Equal then lPredSymbol:=EqualitySym;
            gVisibleNbr:=0;
            ReadWord;
            if CurWord.Kind = Identifier then ReadVisible;
            if (PredMaxArgs.fList^[lPredSymbol] < gVisibleNbr) or
                  (entry_is_uninitialized(PredMaxArgs)(lPredSymbol)) then
               PredMaxArgs.fList^[lPredSymbol] := gVisibleNbr;
         end

@ The ``specification'' (appearing in a non-expandable mode and
functor definitions) refers to the ``\texttt{->} \<Type>'' portion
which gives the type for the functor or mode.

@<Parse patterns (\texttt{parser.pas})@>=
procedure Specification;
begin
   gItemPtr^.StartSpecification;
   Accept(sy_Arrow,paArrowExp1);
   TypeExpression;
   gItemPtr^.FinishSpecification;
end;

@ Parsing a structure pattern is a bit misleading. Unlike the previous
procedures, this will actually parse the entirety of a structure
definition:
$$\hbox{\texttt{struct }}\<Identifier>\hbox{ \texttt{(} }\<Types>\hbox{ \texttt{)}}\hbox{ \texttt{(\#} } \<Fields>\hbox{ \texttt{\#)}}$$

@<Parse patterns (\texttt{parser.pas})@>=
procedure GetStructPatterns;
var lStructureSymbol: integer;
begin
   gBlockPtr^.CreateItem(itDefStruct);
   ReadWord;
   @<Parse ancestors of structure, if there are any@>;
   @<Parse ``\texttt{over}'' and any structure arguments, if any@>;
   gItemPtr^.StartFields; @/
   @<Update max arguments for structure symbol, if needed@>;
   @<Parse the fields of the structure definition@>;
end;

@ @<Parse ancestors of structure, if there are any@>=
   if CurWord.Kind = sy_LeftParanthesis then
   begin
      repeat
         gItemPtr^.StartPrefix;
         ReadWord;
         TypeExpression;
         gItemPtr^.FinishPrefix;
      until CurWord.Kind <> sy_Comma;
      Accept(sy_RightParanthesis,paRightParenthExp6);
   end

@ @<Parse ``\texttt{over}'' and any structure arguments, if any@>=
   gItemPtr^.ProcessStructureSymbol;
   lStructureSymbol := $FF;
   if CurWord.Kind = StructureSymbol then lStructureSymbol:=CurWord.Nr;
   Accept(StructureSymbol,paStructExp1);
   if Occurs(sy_Over) then ReadVisible

@ @<Update max arguments for structure symbol, if needed@>=
   if lStructureSymbol <> $FF then
      if (StructModeMaxArgs.fList^[lStructureSymbol] < gVisibleNbr) or
            (entry_is_uninitialized(StructModeMaxArgs)(lStructureSymbol)) then
         StructModeMaxArgs.fList^[lStructureSymbol] := gVisibleNbr

@ @<Parse the fields of the structure definition@>=
   Accept(sy_StructLeftBracket,paLeftDoubleExp3);
   repeat
      @<Parse field for the structure definition@>;
   until not Occurs(sy_Comma);
   gItemPtr^.FinishFields;
   Accept(sy_StructRightBracket,paRightDoubleExp2)

@ @<Parse field for the structure definition@>=
      gItemPtr^.StartAggrPattSegment;
      repeat
         gItemPtr^.ProcessField;
         Accept(SelectorSymbol,paSelectExp1);
      until not Occurs(sy_Comma);
      Specification;
      gItemPtr^.FinishAggrPattSegment

@* [S] Definitions.
Non-expandable modes, i.e., modes of the form
$$\hbox{\texttt{mode} }\<Identifier>\hbox{ \texttt{of} }\<Arguments>\hbox{ \texttt{->} }\<Type>\hbox{ \texttt{means} }\<Formula>$$

@<Parse definitions (\texttt{parser.pas})@>=
{{\it Definitions}}

procedure ConstructionType;
begin
   gItemPtr^.StartConstructionType; {(\section\xref{extItemObj.StartConstructionType})}
   if CurWord.Kind = sy_Arrow then
   begin
      ReadWord;
      TypeExpression @+
   end;
   gItemPtr^.FinishConstructionType; {(\section\xref{extItemObj.FinishConstructionType})}
end;

@ Parsing correctness conditions amounts to looping through every
``\<Correctness> \<Justification>\texttt{;}'' statement, with a
fallback ``\texttt{correctness} \<Justification>\texttt{;}''
correctness condition.

There is a comment, ``o jaki tu item chodzi? definitional-item?'',
which Google translates from Polish as, ``What item are we talking
about here? Definitional-item?'' I have swapped this into the code snippet.

\label{Correctness:parser.pas}

@<Parse definitions (\texttt{parser.pas})@>=
procedure Correctness;
begin
   while CurWord.Kind = sy_CorrectnessCondition do
   begin
      StillCorrect:=true;
      gBlockPtr^.CreateItem(itCorrCond);
      ReadWord;
      Justification; 
      Semicolon;
   end;
   gItemPtr^.ProcessCorrectness; {(\section\xref{extItemObj.ProcessCorrectness}) What item are we talking about here? Definitional-item?}
   if CurWord.Kind = sy_Correctness then {``\texttt{correctness}'' catchall}
   begin
      StillCorrect:=true;
      gBlockPtr^.CreateItem(itCorrectness);
      ReadWord;
      Justification; 
      Semicolon;
   end;
end;
@

\label{Definition:parser.pas}
@<Parse definitions (\texttt{parser.pas})@>=
procedure Definition;
var lDefKind: TokenKind;
lDefiniensExpected: boolean;
begin
   lDefKind:=CurWord.Kind;
   lDefiniensExpected:=true;
   case CurWord.Kind of
      sy_Mode:
         @<Parse mode definition@>;
      sy_Attr:
         begin
            gBlockPtr^.CreateItem(itDefAttr);
            ReadWord;
            GetAttrPattern; @+
         end;
      sy_Struct:
         begin
            GetStructPatterns;
            lDefiniensExpected:=false; @+
         end;
      sy_Func:
         begin
            gBlockPtr^.CreateItem(itDefFunc);
            ReadWord;
            GetFuncPattern;
            ConstructionType;
         end;
      sy_Pred:
         begin
            gBlockPtr^.CreateItem(itDefPred);
            ReadWord;
            gItemPtr^.StartDefPredicate;
            GetPredPattern;
         end;
   endcases;
   if lDefiniensExpected then
      @<Parse definiens@>;
   Semicolon;
   Correctness;
   while (CurWord.Kind = sy_Property) do
   begin
      gBlockPtr^.CreateItem(itProperty);
      StillCorrect:=true;
      ReadWord;
      Justification;
      Semicolon;
   end;
   gBlockPtr^.FinishDefinition;
end;

@ @<Parse mode definition@>=
         begin
            gBlockPtr^.CreateItem(itDefMode);
            ReadWord;
            GetModePattern;
            case CurWord.Kind of
               sy_Is:
                  begin
                     gItemPtr^.StartExpansion;
                     ReadWord;
                     TypeExpression;
                     lDefiniensExpected:=false;
                  end;
            othercases ConstructionType;
            endcases;
         end

@ @<Parse definiens@>=
      case CurWord.Kind of
         sy_Means:
            @<Parse ``\texttt{means}'' definiens@>;
         sy_Equals:
            @<Parse ``\texttt{equals}'' definiens@>;
      endcases

@ @<Parse ``\texttt{means}'' definiens@>=
            begin
               gItemPtr^.ProcessMeans;
               ReadWord;
               if Occurs(sy_Colon) then
               begin
                  gItemPtr^.ProcessDefiniensLabel;
                  Accept(Identifier,paIdentExp10);
                  Accept(sy_Colon,paColonExp2);
               end
               else gItemPtr^.ProcessDefiniensLabel;
               gItemPtr^.StartDefiniens;
               FormulaExpression;
               if CurWord.Kind = sy_If then
               @<Parse ``means'' definition-by-cases@>@;
               else gItemPtr^.FinishOtherwise;
               gItemPtr^.FinishDefiniens;
            end

@ @<Parse ``means'' definition-by-cases@>=
               begin
                  gItemPtr^.StartGuard;
                  ReadWord;
                  FormulaExpression;
                  gItemPtr^.FinishGuard;
                  while Occurs(sy_Comma) do
                  begin
                     FormulaExpression;
                     gItemPtr^.StartGuard;
                     Accept(sy_If,paIfExp);
                     FormulaExpression;
                     gItemPtr^.FinishGuard;
                  end;
                  if CurWord.Kind = sy_Otherwise then
                  begin
                     gItemPtr^.StartOtherwise;
                     ReadWord;
                     FormulaExpression;
                     gItemPtr^.FinishOtherwise; @+
                  end;
               end

@ @<Parse ``\texttt{equals}'' definiens@>=
            if lDefKind <> sy_Func then
            begin
               WrongWord(paUnexpEquals); @+
            end
            else
            begin
               gItemPtr^.ProcessEquals;
               ReadWord;
               if Occurs(sy_Colon) then
               begin
                  gItemPtr^.ProcessDefiniensLabel;
                  Accept(Identifier,paIdentExp10);
                  Accept(sy_Colon,paColonExp2);
               end
               else gItemPtr^.ProcessDefiniensLabel;
               gItemPtr^.StartEquals;
               TermExpression;
               if CurWord.Kind = sy_If then
               @<Parse ``equals'' definition-by-cases@>
               else gItemPtr^.FinishOtherwise;
               gItemPtr^.FinishDefiniens;
            end

@ @<Parse ``equals'' definition-by-cases@>=
               begin
                  gItemPtr^.StartGuard;
                  ReadWord;
                  FormulaExpression;
                  gItemPtr^.FinishGuard;
                  while Occurs(sy_Comma) do
                  begin
                     TermExpression;
                     gItemPtr^.StartGuard;
                     Accept(sy_If,paIfExp);
                     FormulaExpression;
                     gItemPtr^.FinishGuard;
                  end;
                  if CurWord.Kind = sy_Otherwise then
                  begin
                     gItemPtr^.StartOtherwise;
                     ReadWord;
                     TermExpression;
                     gItemPtr^.FinishOtherwise;
                  end;
               end

@ When introducing a ``\texttt{synonym}'' or ``\texttt{antonym}'', the
Parser needs to determine \emph{what kind of thing} is being
introduced as a synonym or antonym.

\Ithink{This could probably be turned into an \&{case} statement, but
I am just transcribing the code as faithfully as possible.}

@d is_attr_pattern == (CurWord.Kind = Identifier) and (AheadWord.Kind = sy_Is)
@d is_infix_pattern == (CurWord.Kind in [LeftCircumfixSymbol,sy_LeftCurlyBracket,
                             sy_LeftSquareBracket,sy_LeftParanthesis,
                             InfixOperatorSymbol]) or
              ((CurWord.Kind = Identifier) and (AheadWord.Kind = InfixOperatorSymbol))
@d is_predicate_pattern == (CurWord.Kind = PredicateSymbol) or@|
              (CurWord.Kind =sy_Equal) or@|
              ((CurWord.Kind = Identifier) and
              (AheadWord.Kind in [sy_Comma,PredicateSymbol,sy_Equal]))
@d is_selector_pattern == (CurWord.Kind = sy_The) and (AheadWord.Kind = SelectorSymbol)
@d is_forgetful_functor_pattern == (CurWord.Kind = sy_The) and (AheadWord.Kind = StructureSymbol)

@<Parse definitions (\texttt{parser.pas})@>=
function CurrPatternKind: TokenKind;
begin
   if CurWord.Kind = ModeSymbol then
      CurrPatternKind:=ModeSymbol
   else if CurWord.Kind = StructureSymbol then
      CurrPatternKind:=StructureSymbol @t\2@>
   else if is_attr_pattern then
      CurrPatternKind:=AttributeSymbol @t\2@>
   else if is_infix_pattern then
      CurrPatternKind:=InfixOperatorSymbol @t\2@>
   else if is_predicate_pattern then
      CurrPatternKind:=PredicateSymbol @t\2@>
   else if is_selector_pattern then
      CurrPatternKind:=SelectorSymbol @t\2@>
   else if is_forgetful_functor_pattern then
      CurrPatternKind:=ForgetfulFunctor @t\2@>
   else CurrPatternKind:=sy_Error@t\1\1\1\1\1\1@>;
end;

@ The Parser is looking at the ``\texttt{synonym}'' token when this
procedure is invoked.


@<Parse definitions (\texttt{parser.pas})@>=
procedure Synonym;
begin
   ReadWord;
   case CurrPatternKind of
      ModeSymbol:
         begin {Mode synonym}
            gBlockPtr^.CreateItem(itModeNotation);
            GetModePattern;
            gItemPtr^.ProcessModeSynonym;
            Accept(sy_For, paForExp);
            GetModePattern;
         end;
      AttributeSymbol:
         begin {Attribute synonym}
            gBlockPtr^.CreateItem(itAttrSynonym);
            GetAttrPattern;
            gItemPtr^.ProcessAttrSynonym;
            Accept(sy_For, paForExp);
            GetAttrPattern;
         end;
      InfixOperatorSymbol:
         begin {Functor synonym}
            gBlockPtr^.CreateItem(itFuncNotation);
            GetFuncPattern;
            gItemPtr^.ProcessFuncSynonym;
            Accept(sy_For, paForExp);
            GetFuncPattern;
         end;
      PredicateSymbol:
         begin {Predicate synonym}
            gBlockPtr^.CreateItem(itPredSynonym);
            gItemPtr^.StartDefPredicate;
            GetPredPattern;
            gItemPtr^.ProcessPredSynonym;
            Accept(sy_For, paForExp);
            GetPredPattern;
         end
   othercases
   begin
      gBlockPtr^.CreateItem(itIncorrItem);
      ErrImm(paWrongPattBeg1); @+
   end;
   endcases;
end;

@ Antonyms only make sense for attributes and predicates. A 314 error is
raised for any other kind of antonym.

@^Error, 314@>

@<Parse definitions (\texttt{parser.pas})@>=
procedure Antonym;
begin
   ReadWord;
   case CurrPatternKind of
      Attributesymbol:
         begin {Attribute antonym}
            gBlockPtr^.CreateItem(itAttrAntonym);
            GetAttrPattern;
            gItemPtr^.ProcessAttrAntonym;
            Accept(sy_For, paForExp);
            GetAttrPattern;
         end;
      PredicateSymbol:
         begin {Predicate antonym}
            gBlockPtr^.CreateItem(itPredAntonym);
            gItemPtr^.StartDefPredicate;
            GetPredPattern;
            gItemPtr^.ProcessPredAntonym;
            Accept(sy_For, paForExp);
            GetPredPattern;
         end
   othercases
   begin
      gBlockPtr^.CreateItem(itIncorrItem);
      ErrImm(paWrongPattBeg2); @+
   end;
   endcases;
end;

@


@<Parse definitions (\texttt{parser.pas})@>=
procedure UnexpectedItem;
begin
   case CurWord.Kind of
      sy_Case,sy_Suppose,sy_Hereby:
         begin
            ErrImm(paWrongItemBeg);
            ReadWord;
            if CurWord.Kind  = sy_That then ReadWord;
            PrivateItem;
         end;
      sy_Per:
         begin
            gBlockPtr^.CreateItem(itIncorrItem);
            ErrImm(paWrongItemBeg);
            ReadWord;
            if CurWord.Kind  = sy_Cases then
            begin
               ReadWord;
               InCorrStatement;
               SimpleJustification; @+
            end;
         end;
   othercases
   begin
      ErrImm(paUnexpItemBeg);
      StillCorrect:=true;
      PrivateItem; @+
   end;
   endcases;
end;

@ The Parser is currently looking at the ``\texttt{definition}''
token, so it will construct a definition block AST.

@<Parse definitions (\texttt{parser.pas})@>=
procedure DefinitionalBlock;
var DefPos:Position;
begin
   gBlockPtr^.CreateItem(itDefinition);
   gBlockPtr^.CreateBlock(blDefinition);
   DefPos:=CurPos;
   ReadWord;
   while CurWord.Kind <> sy_End do
   @<Parse item in definition block@>;
   KillBlock;
   AcceptEnd(DefPos);
end;

@ @<Parse item in definition block@>=
   begin
      StillCorrect:=true;
      gBlockPtr^.ProcessRedefine;
      if Occurs(sy_Redefine) then
         @<Check we are redefining a mode, attribute, functor, or predicate@>;
      case CurWord.Kind of
         sy_Mode,sy_Attr,sy_Struct,sy_Func,sy_Pred:
            Definition;
         sy_Begin,EOT,sy_Reserve,sy_Scheme,sy_Theorem,
         sy_Definition,sy_Registration,sy_Notation: break;
         Pragma: ProcessPragmas;
      othercases
      begin
         @<Parse loci, assumptions, unexpected items in a definition block@>;@/
         Semicolon;
      end;
      endcases;
   end

@ @<Check we are redefining a mode, attribute, functor, or predicate@>=
         if not (CurWord.Kind in [sy_Mode,sy_Attr,sy_Func,sy_Pred]) then
            Error(PrevPos,paUnexpRedef)

@ @<Parse loci, assumptions, unexpected items in a definition block@>=
         case CurWord.Kind of
            sy_Let:
               begin
                  gBlockPtr^.CreateItem(itLociDeclaration);
                  Generalization; @+
               end;
            sy_Given: ExistentialAssumption;
            sy_Assume:
               begin
                  gBlockPtr^.CreateItem(itAssumption);
                  ReadWord;
                  Assumption; @+
               end;
            sy_Canceled: Canceled;
            sy_Case,sy_Suppose,sy_Per,sy_Hereby: UnexpectedItem;
         othercases PrivateItem;
         endcases

@ The Parser's current token is ``\texttt{notation}''.
Notation blocks are very similar in structure to definition
blocks. Unsurprisingly, the Parser's code has a similar structure as
parsing a definition block.


@<Parse definitions (\texttt{parser.pas})@>=
procedure NotationBlock;
var DefPos:Position;
begin
   gBlockPtr^.CreateItem(itDefinition);
   gBlockPtr^.CreateBlock(blNotation);
   DefPos:=CurPos;
   ReadWord;
   while CurWord.Kind <> sy_End do
   @<Parse item for notation block@>;
   KillBlock;
   AcceptEnd(DefPos);
end;

@ @<Parse item for notation block@>=
   begin
      StillCorrect:=true;
      case CurWord.Kind of
         sy_Begin,EOT,sy_Reserve,sy_Scheme,sy_Theorem,sy_Definition,
         sy_Registration,sy_Notation: break;
         Pragma: ProcessPragmas;
      othercases
      @<Parse semicolon-separated items in a notation block@>;
      endcases;
   end

@ @<Parse semicolon-separated items in a notation block@>=
      begin
         case CurWord.Kind of
            sy_Synonym: Synonym;
            sy_Antonym: Antonym;
            sy_Let:
               begin
                  gBlockPtr^.CreateItem(itLociDeclaration);
                  ReadWord;
                  FixedVariables; @+
               end;
         othercases UnexpectedItem;
         endcases; @/
         Semicolon;
      end
@

\label{ATTSubexpression}

@d ahead_is_type == (AheadWord.Kind in [sy_Set,ModeSymbol,StructureSymbol])
@d is_attr_token == (CurWord.Kind in [AttributeSymbol,sy_Non]) or@|
            (CurWord.Kind in (TermBegSys - [sy_LeftParanthesis,StructureSymbol])) or@|
            ((CurWord.Kind = sy_LeftParanthesis) and
                not(ahead_is_type)) or@|
            (CurWord.Kind =  StructureSymbol) and (AheadWord.Kind = sy_StructLeftBracket)

@<Parse definitions (\texttt{parser.pas})@>=
procedure ATTSubexpression(var aExpKind: ExpKind);
var lAttrExp: boolean;
begin
   aExpKind:=exNull;
   gSubexpPtr^.StartAttributes;
   while is_attr_token do
   begin
      gSubexpPtr^.ProcessNon;
      lAttrExp:=CurWord.Kind = sy_Non;
      if CurWord.Kind = sy_Non then ReadWord;
      @<Parse arguments for attribute expression@>;
      if CurWord.Kind = AttributeSymbol then
      begin
         aExpKind:=exAdjectiveCluster;
         gSubexpPtr^.ProcessAttribute;
         ReadWord; @+
      end
      else
      begin
         if lAttrExp or (aExpKind = exAdjectiveCluster) then {|aExpKind = exAdjectiveCluster| is never true}
         begin
            gSubexpPtr^.ProcessAttribute;
            SynErr(CurPos,paAttrExp3); @+
         end;
         break;
      end;
   end;
   gSubexpPtr^.CompleteAttributes;
end;

@ @<Parse arguments for attribute expression@>=
      if (CurWord.Kind in (TermBegSys - [StructureSymbol])) or@|
            (CurWord.Kind =  StructureSymbol) and (AheadWord.Kind = sy_StructLeftBracket)
      then
      begin
         if aExpKind = exNull then aExpKind:=exTerm;
         gSubexpPtr^.StartAttributeArguments;
         ProcessArguments;
         gSubexpPtr^.FinishAttributeArguments;
      end

@ \node{Registration clusters.}

\label{RegisterCluster:parser.pas}
@<Parse definitions (\texttt{parser.pas})@>=
procedure RegisterCluster;
var lExpKind: ExpKind;
begin
   gBlockPtr^.CreateItem(itCluster);
   ReadWord;
   if (CurWord.Kind = Identifier) and (AheadWord.Kind = sy_Arrow)
   then ErrImm(paFunctExp4);
   gItemPtr^.StartAttributes; {(\section\xref{extItemObj.StartAttributes})}
   gItemPtr^.CreateExpression(exAdjectiveCluster); {(\section\xref{extItemObj.CreateExpression})}
   gExpPtr^.CreateSubexpression;
   ATTSubexpression(lExpKind);
   case lExpKind of
      exTerm: gSubexpPtr^.CompleteClusterTerm;
      exNull,exAdjectiveCluster: gSubexpPtr^.CompleteAdjectiveCluster;
   endcases; @/
   KillSubexpression;
   KillExpression;
   case lExpKind of
      exTerm:
         @<Parse functor registration cluster@>;
      exNull,exAdjectiveCluster:
         case CurWord.Kind of
            sy_Arrow:
               @<Parse conditional registration cluster@>;
            sy_For:
               @<Parse existential registration cluster@>;
         othercases
         begin
            SynErr(CurPos,paForOrArrowExpected);
            gItemPtr^.FinishConsequent;
            gItemPtr^.CreateExpression(exType);
            gExpPtr^.CreateSubexpression;
            gSubexpPtr^.StartType;
            gSubexpPtr^.InsertIncorrType;
            gSubexpPtr^.CompleteType;
            gSubexpPtr^.CompleteClusterType;
            KillSubexpression;
            KillExpression;
            gItemPtr^.FinishClusterType;
         end;
         endcases;
   endcases;
   Semicolon;
   Correctness;
end;

@ @<Parse functor registration cluster@>=
         begin
            gItemPtr^.FinishClusterTerm;
            Accept(sy_Arrow,paArrowExp2);
            gItemPtr^.CreateExpression(exAdjectiveCluster);
            gExpPtr^.CreateSubexpression;
            gSubexpPtr^.StartAttributes;
            ATTSubexpression(lExpKind);
            if lExpKind <> exAdjectiveCluster then
            begin
               ErrImm(paAdjClusterExp) @+
            end;
            gSubexpPtr^.CompleteAdjectiveCluster;
            KillSubexpression;
            KillExpression;
            gItemPtr^.FinishConsequent;
            if CurWord.Kind = sy_For then
            begin
               ReadWord;
               gItemPtr^.CreateExpression(exType);
               gExpPtr^.CreateSubexpression;
               gSubexpPtr^.StartType;
               gSubexpPtr^.StartAttributes;
               GetAdjectiveCluster;
               RadixTypeSubexpression;
               gSubexpPtr^.CompleteAttributes;
               gSubexpPtr^.CompleteType;
               gSubexpPtr^.CompleteClusterType;
               KillSubexpression;
               KillExpression;
            end;
            gItemPtr^.FinishClusterType;
         end

@ @<Parse conditional registration cluster@>=
               begin
                  gItemPtr^.FinishAntecedent;
                  ReadWord;
                  gItemPtr^.CreateExpression(exAdjectiveCluster);
                  gExpPtr^.CreateSubexpression;
                  gSubexpPtr^.StartAttributes;
                  ATTSubexpression(lExpKind);
                  if lExpKind <> exAdjectiveCluster then
                  begin
                     ErrImm(paAdjClusterExp); @+
                  end;
                  gSubexpPtr^.CompleteAdjectiveCluster;
                  KillSubexpression;
                  KillExpression;
                  gItemPtr^.FinishConsequent;
                  Accept(sy_For,paForExp);
                  gItemPtr^.CreateExpression(exType);
                  gExpPtr^.CreateSubexpression;
                  gSubexpPtr^.StartType;
                  gSubexpPtr^.StartAttributes;
                  GetAdjectiveCluster;
                  RadixTypeSubexpression;
                  gSubexpPtr^.CompleteAttributes;
                  gSubexpPtr^.CompleteType;
                  gSubexpPtr^.CompleteClusterType;
                  KillSubexpression;
                  KillExpression;
                  gItemPtr^.FinishClusterType;
               end

@ @<Parse existential registration cluster@>=
               begin
                  gItemPtr^.FinishConsequent;
                  ReadWord;
                  gItemPtr^.CreateExpression(exType);
                  gExpPtr^.CreateSubexpression;
                  gSubexpPtr^.StartType;
                  gSubexpPtr^.StartAttributes;
                  GetAdjectiveCluster;
                  RadixTypeSubexpression;
                  gSubexpPtr^.CompleteAttributes;
                  gSubexpPtr^.CompleteType;
                  gSubexpPtr^.CompleteClusterType;
                  KillSubexpression;
                  KillExpression;
                  gItemPtr^.FinishClusterType;
               end

@ \node{Reduction registration.}

@<Parse definitions (\texttt{parser.pas})@>=
procedure Reduction;
var lExpKind: ExpKind;
begin
   gBlockPtr^.CreateItem(itReduction);
   ReadWord;
   if (CurWord.Kind = Identifier) and (AheadWord.Kind = sy_Arrow)
   then ErrImm(paFunctExp4);
   gItemPtr^.StartFuncReduction;
   TermExpression;
   gItemPtr^.ProcessFuncReduction;
   Accept(sy_To,paToExp);
   TermExpression;
   gItemPtr^.FinishFuncReduction;
   Semicolon;
   Correctness;
end;

@ \node{Identification registration.}

@<Parse definitions (\texttt{parser.pas})@>=
procedure Identification;
begin
   gBlockPtr^.CreateItem(itIdentify);
   ReadWord;
   {begin}
   gItemPtr^.StartFuncIdentify;
   GetFuncPattern;
   gItemPtr^.ProcessFuncIdentify;
   Accept(sy_With, paWithExp);
   GetFuncPattern;
   gItemPtr^.CompleteFuncIdentify;
   {  end;}
   if CurWord.Kind = sy_When then
   begin
      ReadWord;
      repeat
         gItemPtr^.ProcessLeftLocus;
         Accept(Identifier,paIdentExp3);
         Accept(sy_Equal,paEqualityExp1);
         gItemPtr^.ProcessRightLocus;
         Accept(Identifier,paIdentExp3);
      until not Occurs(sy_Comma);
   end;
   Semicolon;
   Correctness;
end;

@ \node{Property registration.}

@<Parse definitions (\texttt{parser.pas})@>=
procedure RegisterProperty;
begin
   gBlockPtr^.CreateItem(itPropertyRegistration);
   case PropertyKind(CurWord.Nr) of
      sySethood:
         begin
            ReadWord;
            Accept(sy_of, paOfExp);
            gItemPtr^.StartSethoodProperties;
            TypeExpression;
            gItemPtr^.FinishSethoodProperties;
            Justification;
         end;
   othercases
   begin
      SynErr(CurPos,paStillNotImplemented); @+
   end;
   endcases; @/
   Semicolon;
end;
@


@<Parse definitions (\texttt{parser.pas})@>=
procedure RegistrationBlock;
var DefPos:Position;
begin
   gBlockPtr^.CreateItem(itDefinition);
   gBlockPtr^.CreateBlock(blRegistration);
   DefPos:=CurPos;
   ReadWord;
   while CurWord.Kind <> sy_End do
   begin
      StillCorrect:=true;
      case CurWord.Kind of
         sy_Cluster: RegisterCluster;
         sy_Reduce: Reduction;
         sy_Identify: Identification;
         sy_Property: RegisterProperty;
         sy_Begin,EOT,sy_Reserve,sy_Scheme,sy_Theorem,sy_Definition,
         sy_Registration,sy_Notation: break;
         Pragma: ProcessPragmas;
      othercases
      begin
         case CurWord.Kind of
            sy_Let:
               begin
                  gBlockPtr^.CreateItem(itLociDeclaration);
                  ReadWord;
                  FixedVariables; @+
               end;
            sy_Canceled: Canceled;
            sy_Case,sy_Suppose,sy_Per,sy_Hereby: UnexpectedItem;
         othercases PrivateItem;
         endcases; @/
         Semicolon;
      end;
      endcases;
   end;
   KillBlock;
   AcceptEnd(DefPos);
end;

@ \node{Reservation.}

\label{Reservation:parser.pas}

@<Parse definitions (\texttt{parser.pas})@>=
procedure Reservation;
begin
   gBlockPtr^.CreateItem(itReservation);
   ReadWord;
   repeat
      gItemPtr^.StartReservationSegment;
      repeat
         gItemPtr^.ProcessReservedIdentifier;
         Accept(Identifier,paIdentExp11);
      until not Occurs(sy_Comma);
      Accept(sy_For,paForExp);
      gItemPtr^.CreateExpression(exResType);
      TypeSubexpression;
      KillExpression;
      gItemPtr^.FinishReservationSegment;
   until not Occurs(sy_Comma);
   gItemPtr^.FinishReservation;
end;

@ \node{Theorem.}


@<Parse definitions (\texttt{parser.pas})@>=
procedure Theorem;
begin
   gBlockPtr^.CreateItem(itTheorem);
   ReadWord;
   ProcessLab;
   gItemPtr^.StartTheoremBody;
   ProcessSentence;
   gItemPtr^.FinishTheoremBody;
   Justification;
   gItemPtr^.FinishTheorem;
end;

@ \node{Axiom.}

@<Parse definitions (\texttt{parser.pas})@>=
procedure Axiom;
begin
   gBlockPtr^.CreateItem(itAxiom);
   ReadWord;
   ProcessLab;
   gItemPtr^.StartTheoremBody;
   ProcessSentence;
   gItemPtr^.FinishTheoremBody;
   gItemPtr^.FinishTheorem;
end;

@* [S] Scheme blocks.

\label{SchemeBlock:parser.pas}

@<Parse scheme block (\texttt{parser.pas})@>=
{{\it Main (with Schemes)}}

procedure SchemeBlock;
var SchemePos: Position;
begin
   gBlockPtr^.CreateItem(itSchemeBlock);
   gBlockPtr^.CreateBlock(blPublicScheme);
   ReadWord;
   gBlockPtr^.CreateItem(itSchemeHead);
   gItemPtr^.ProcessSchemeName;
   SchemePos:=PrevPos;
   if CurWord.Kind = Identifier then ReadWord;
   @<Parse scheme parameters@>;
   Accept(sy_RightCurlyBracket,paRightCurledExp3);
   gItemPtr^.FinishSchemeHeading;
   Accept(sy_Colon,paColonExp3);
   FormulaExpression; {Scheme-conclusion}
   gItemPtr^.FinishSchemeThesis;
   @<Parse scheme premises@>;
   gItemPtr^.FinishSchemeDeclaration;
   @<Parse justification for scheme@>;
   KillBlock;
end;

@ @<Parse scheme parameters@>=
   Accept(sy_LeftCurlyBracket,paLeftCurledExp);
   repeat
      gItemPtr^.StartSchemeSegment;
      repeat
         gItemPtr^.ProcessSchemeVariable;
         Accept(Identifier,paIdentExp13);
      until not Occurs(sy_Comma);
      gItemPtr^.StartSchemeQualification;
      case CurWord.Kind of
         sy_LeftSquareBracket:
            begin
               ReadWord;
               ReadTypeList;
               gItemPtr^.FinishSchemeQualification;
               Accept(sy_RightSquareBracket,paRightSquareExp5);
            end;
         sy_LeftParanthesis:
            begin
               ReadWord;
               ReadTypeList;
               gItemPtr^.FinishSchemeQualification;
               Accept(sy_RightParanthesis,paRightParenthExp9);
               Specification;
            end;
      othercases
      begin
         ErrImm(paWrongSchemeVarQual);
         gItemPtr^.FinishSchemeQualification;
         Specification;
      end;
      endcases;
      gItemPtr^.FinishSchemeSegment;
   until not Occurs(sy_Comma)

@ @<Parse scheme premises@>=
   if CurWord.Kind = sy_Provided then
      repeat
         gItemPtr^.StartSchemePremise;
         ReadWord;
         ProcessLab;
         ProcessSentence;
         gItemPtr^.FinishSchemePremise;
      until CurWord.Kind <> sy_And

@ @<Parse justification for scheme@>=
   if CurWord.Kind = sy_Proof then
   begin
      KillItem; {only |KillItem| which is run outside of |Semicolon| procedure}
      if not ProofPragma then
      begin
         gBlockPtr^.StartSchemeDemonstration;
         IgnoreProof;
         gBlockPtr^.FinishSchemeDemonstration;
      end
      else
      begin
         StillCorrect:=true;
         Accept(sy_Proof,paProofExp);
         gBlockPtr^.StartSchemeDemonstration;
         LinearReasoning;
         if CurWord.Kind = sy_Per then NonBlockReasoning;
         AcceptEnd(SchemePos);
         gBlockPtr^.FinishSchemeDemonstration;
      end;
   end
   else
   begin
      Semicolon;
      if not ProofPragma then
      begin
         gBlockPtr^.StartSchemeDemonstration;
         IgnoreProof;
         gBlockPtr^.FinishSchemeDemonstration;
      end
      else
      begin
         StillCorrect:=true;
         if CurWord.Kind = sy_Proof then
         begin
            WrongWord(paProofExp);
            StillCorrect:=true;
            ReadWord;
         end;
         gBlockPtr^.StartSchemeDemonstration;
         LinearReasoning;
         if CurWord.Kind = sy_Per then NonBlockReasoning;
         AcceptEnd(SchemePos);
         gBlockPtr^.FinishSchemeDemonstration;
      end;
   end

@* [S] Main parse procedure.
The main \\{Parse} method essentially skips ahead to the first
``\texttt{begin}'', then skips ahead to the first top-level block
statement.

\label{parser.pas::Parse}

@d skip_to_begin == @+ ReadTokenProc;
  while (CurWord.Kind <> sy_Begin) and (CurWord.Kind <> EOT) do ReadTokenProc

@<Main parse method (\texttt{parser.pas})@>=
procedure Parse;
begin
   skip_to_begin; {Skips ahead until EOT or finds `begin`}
   if CurWord.Kind = EOT
   then ErrImm(213)
   else 
   @<Parse proper text@>; {|CurrWord.Kind = sy_Begin|} @#
   KillBlock;
end;

@ Parsing the ``text proper'' checks that we have encountered a
``\texttt{begin}'' keyword, then parses the block statements in the
article's contents.

Note that
\\{ProcessBegin}  (\section\xref{extBlockObj.ProcessBegin})
and
\\{StartProperText} (\section\xref{extBlockObj.StartProperText})
are both implemented in the extended block class. 

@<Parse proper text@>=
   begin
      gBlockPtr^.StartProperText;
      gBlockPtr^.ProcessBegin;
      Accept(sy_Begin,213);
      while CurWord.Kind <> EOT do
      @<Parse next block@>;
   end

@ When parsing the next top-level block in a Mizar article, we tell
Mizar's parser we are not in ``panic mode''. Then we test for
unexpected ``\texttt{end}'' tokens. If we can recover a
``\texttt{begin}'' token, just start the loop over again.

If we encounter an ``end of text'' token, then we should terminate the
loop.

Otherwise, we dispatch the parser's control depending on the kind of
token we encounter.

@<Parse next block@>=
      begin
         @<Parse pragmas and begins@>;
         StillCorrect:=true; {we are not in panic mode}
         if CurWord.Kind = sy_End then
         begin
            @<Skip all \texttt{end} tokens, report errors@>;
            if CurWord.Kind = sy_Begin then continue;
         end;
         if CurWord.Kind = EOT then break; @#
         case CurWord.Kind of
            sy_Scheme: SchemeBlock;
            sy_Definition: DefinitionalBlock;
            sy_Notation: NotationBlock;
            sy_Registration: RegistrationBlock;
            sy_Reserve: Reservation;
            sy_Theorem: Theorem;
            sy_Axiom: Axiom;
            sy_Canceled: Canceled;
            sy_Case,sy_Suppose, sy_Per,sy_Hereby: UnexpectedItem;
         othercases PrivateItem;
         endcases; @#
         Semicolon; {block is expected to end in a semicolon}
      end

@ The \\{ProcessPragmas} (\section\xref{ProcessPragmas:parser})
consumes a token when the current token is a pragma. So we effectively
have a loop where we consume all the pragmas and the
``\texttt{begin}'' keywords until we find something else.

@<Parse pragmas and begins@>=
         while CurWord.Kind in [sy_Begin,Pragma] do
         begin
            ProcessPragmas;
            if CurWord.Kind = sy_Begin then
            begin
               gBlockPtr^.ProcessBegin;
               ReadTokenProc;
            end;
         end

@ In the unfortunate event that the parser has stumbled across an
``\texttt{end}'' token, skip all the ``\texttt{end}'' and semicolon
tokens and report errors.

@<Skip all \texttt{end} tokens, report errors@>=
            repeat
               ErrImm(216);
               ReadTokenProc;
               if CurWord.Kind = sy_Semicolon then ReadTokenProc;
            until CurWord.Kind <> sy_End

@* [] Index.