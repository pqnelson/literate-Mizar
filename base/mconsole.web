
@* [F] Mizar Console.
The Mizar Console unit is used for interacting with the command line.
Specifically, this module will be used for printing error messages,
reporting progress, and parsing command-line arguments for
configuration options.

@<mconsole.pas@>=
@<GNU License@>

unit mconsole;

interface
@<Report results to command line@>@;

@<Constants for common error messages reported to console@>@;

@<Interface for accommodator command line options@>@;

@<Interface for |MakeEnv| command line options@>@;

@<Interface for transfer-specific command line options@>@;

@<Interface for other command line options@>@;

implementation
@|@#
@<Import units for \texttt{mconsole.pas}@>
@#
@<Implementation for mconsole.pas@>

@t\2@>end

@ We import two modules, \\{pcmizver} and \\{mizenv},

@<Import units for \texttt{mconsole.pas}@>=
uses pcmizver,mizenv;

@ We want to have a method which allows us to flag an error
(\\{fErrNbr}) on a given line of the article being processed. But the
user may request Mizar to silence these messages. We can facilitate
this by 

@<|DisplayLine| global constant@>=
const@+DisplayLine:@+procedure(fLine,fErrNbr: integer) = NoDisplayLine; @t\2@>

@ Now, we have accommodator specific options.

@<Interface for accommodator command line options@>=
{Accommodator specific options:}

var
 SignatureProcessing, {unused}
 TheoremListsProcessing, {unused}
 SchemeListsProcessing, {unused}
 InsertHiddenFiles, {Include \.{HIDDEN} automatically?}
 FormatsProcessing:Boolean;


var {Registrations-related configuration for Accommodator}
 ClustersProcessing,IdentifyProcessing,ReductionProcessing,PropertiesProcessing: Boolean;

var {The environ-specifical Accommodator options}
 VocabulariesProcessing, {Accommodator will run \\{ProcessVocabularies}}
 NotationsProcessing, {Accommodator processes \.{notations} directive}
 ConstructorsProcessing, {Will the Accommodator determine which constructor to use for identifier?}
 DefinitionsProcessing,EqualitiesProcessing,ExpansionsProcessing, {Definition environs}
 TheoremsProcessing,SchemesProcessing: Boolean;

@ Among the state variables introduced in the \texttt{mconsole} unit,
there is one for handling \.{SIGINT}, \.{SIGQUIT}, and \.{SIGTERM} signals. \Ithink{The other \UNIX/
signals should probably be supported, as well.}

@<Interface for other command line options@>=
{Other options:}

var
 CtrlCPressed : Boolean = false; {\.{SIGINT}, \.{SIGQUIT}, or \.{SIGTERM} signal received?}
 LongLines : Boolean = false; {Allow lines longer than 80 characters}
 QuietMode : Boolean = false; {Don't print anything to the console?}
 StopOnError: Boolean = false; @#

 FinishingPass: Boolean = false;
 ParserOnly : Boolean = false; {No analyzing or checking}
 AnalyzerOnly : Boolean = false; {Analyze, but no parsing or checking}
 CheckerOnly : Boolean = false; {Check, but do not re-analyze or re-parse}
 SwitchOffUnifier: Boolean = false; @#

 AxiomsAllowed: Boolean = false;

@ \endinterface
The implementation begins by initializing the Accommodator specific options.

@ @<Interface for accommodator command line options@>=
procedure @? InitAccOptions;

@ @<Implementation for mconsole.pas@>=
procedure InitAccOptions;
begin
 InsertHiddenFiles:=true;
 VocabulariesProcessing:=true;
 FormatsProcessing:=true;
 NotationsProcessing:=true;
 SignatureProcessing:=true;
 ConstructorsProcessing:=true;
 ClustersProcessing:=true;
 IdentifyProcessing:=true;
 ReductionProcessing:=true;
 PropertiesProcessing:=true;
 DefinitionsProcessing:=true;
 EqualitiesProcessing:=true;
 ExpansionsProcessing:=true;
 TheoremsProcessing:=true;
 SchemesProcessing:=true;
 TheoremListsProcessing:=false;
 SchemeListsProcessing:=false;
end;

@ Similarly, we want to be able to \emph{reset} the configuration for
the accommodator to the default (initial) values. This is a private
helper function for other things in the \texttt{mconsole}.

@ @<Implementation for mconsole.pas@>=
procedure ResetAccOptions;
begin
 InsertHiddenFiles:=true;
 VocabulariesProcessing:=false;
 FormatsProcessing:=false;
 NotationsProcessing:=false;
 SignatureProcessing:=false;
 ConstructorsProcessing:=false;
 ClustersProcessing:=false;
 IdentifyProcessing:=false;
 ReductionProcessing:=false;
 PropertiesProcessing:=false;
 DefinitionsProcessing:=false;
 EqualitiesProcessing:=false;
 ExpansionsProcessing:=false;
 TheoremsProcessing:=false;
 SchemesProcessing:=false;
 TheoremListsProcessing:=false;
 SchemeListsProcessing:=false;
end;

@ \node{Accommodator options.}%
We will get options for the accommodator passed in from the command
line. Broadly, these are:

\item{$\bullet$} \texttt{-v} resets the accommodator options, and then toggles
|VocabulariesProcessing| to true

\item{$\bullet$} \texttt{-f}, \texttt{-p} resets the accommodator
options, and then toggles |VocabulariesProcessing| to true (so far
like \texttt{-v}), and then toggles |FormatsProcessing| to true.

\item{$\bullet$} \texttt{-P} resets the accommodator options, and then toggles
|VocabulariesProcessing| to true (so far like \texttt{-v}), and then
toggles |FormatsProcessing| to true (so far like \texttt{-f}
and \texttt{-p}), then toggles |TheoremListsProcessing| and
|SchemeListsProcessing| to both be true.

\item{$\bullet$} \texttt{-e} will do everything \texttt{-f} does, and
then toggles |ConstructorsProcessing|, |SignatureProcessing|,\hfill\break
|ClustersProcessing|, and |NotationsProcessing| to all be true.

\item{$\bullet$} \texttt{-h} will set |InsertHiddenFalse| to false
(presumably preventing Mizar from loading the ``hidden'' article,
i.e., the primitive notions
of ``\texttt{object}'', ``\texttt{<>}'', ``\texttt{in}'', and ``\texttt{strict}'' will
not be loaded).

\item{$\bullet$} \texttt{-l} will toggle |LongLines| to true (allowing
lines with more than 80 characters)

\item{$\bullet$} \texttt{-q} will toggle |QuietMode| to true

\item{$\bullet$} \texttt{-s} will toggle |StopOnError| to true

\medbreak
Note this processes \emph{all} command line options \emph{in order}.
So \texttt{-e -v} will produce the same results as \texttt{-v} alone.

@<Interface for accommodator command line options@>=
procedure @? GetAccOptions;

@ @<Implementation for mconsole.pas@>=
procedure GetAccOptions;
 var i,j: integer;
begin
 InitAccOptions;
 for j:=1 to ParamCount do
  if ParamStr(j)[1]='-' then
   for i:=2 to length(ParamStr(j)) do
    case ParamStr(j)[i] of
     'v': begin ResetAccOptions; VocabulariesProcessing:=true end;
     'f','p':
      begin
       ResetAccOptions;
       VocabulariesProcessing:=true;
       FormatsProcessing:=true;
      end;
     'P':
      begin
       ResetAccOptions;
       VocabulariesProcessing:=true;
       FormatsProcessing:=true;
       TheoremListsProcessing:=true;
       SchemeListsProcessing:=true;
      end;
     'e':
      begin
       ResetAccOptions;
       VocabulariesProcessing:=true;
       FormatsProcessing:=true;
       ConstructorsProcessing:=true;
       SignatureProcessing:=true;
       ClustersProcessing:=true;
       NotationsProcessing:=true;
      end;
     'h': begin InsertHiddenFiles:=false; @+ end;
     'l': LongLines:=true;
     'q': QuietMode:=true;
     's': StopOnError:=true;
    endcases;
end;

@ Similarly, we have |MakeEnv| specific options parsed from the
command line flags.


@ @<Interface for |MakeEnv| command line options@>=
{MakeEnv specific options:}

var Accomodation : Boolean = false;
    NewAccom : Boolean = false;

procedure @? GetMEOptions;

@ @<Implementation for mconsole.pas@>=
procedure GetMEOptions;
 var i,j: integer;
begin
 for j:=1 to ParamCount do
  if ParamStr(j)[1]='-' then
   for i:=2 to length(ParamStr(j)) do
    case ParamStr(j)[i] of
     'n': NewAccom:=true;
     'a': Accomodation:=true;
     'l': LongLines:=true;
     'q': QuietMode:=true;
     's': StopOnError:=true;
    endcases;
end;

@ The ``other'' options.

Notably, there is a feature to allow axioms,@^Axioms@> which is completely
undocumented (and probably for good reason!). The axioms must appear
in ``\texttt{.axm}'' files.

@<Interface for other command line options@>=
procedure @? GetOptions;

@ @<Implementation for mconsole.pas@>=
procedure GetOptions;
 var i,j: integer;
begin
 for j:=1 to ParamCount do
  if ParamStr(j)[1]='-' then
   for i:=2 to length(ParamStr(j)) do
    case ParamStr(j)[i] of
     'q': QuietMode:=true;
     'p': ParserOnly:=true;
     'a': AnalyzerOnly:=true;
     'c': CheckerOnly:=true;
     'l': LongLines:=true;
     's': StopOnError:=true;
     'u': SwitchOffUnifier:=true;
     'x': AxiomsAllowed:=true;
      othercases break;
    endcases;
 if ArticleExt = '.axm' then
   AxiomsAllowed:=true;
end;

@ Transfer specific options.

@<Interface for transfer-specific command line options@>=
{Transfer specific options:}

var PublicLibr: Boolean; {use ``\texttt{prel/}\<Article-name>\texttt{/}'' subdirectory?}

procedure @? GetTransfOptions;

@ @<Implementation for mconsole.pas@>=
procedure GetTransfOptions;
 var lOption: string;
begin
 PublicLibr:=false;
 if ParamCount>=2 then
  begin lOption:=ParamStr(2);
   if (length(lOption) = 2) and (lOption[1] in ['/','-']) then
    PublicLibr:=UpCase(lOption[2]) = 'P';
  end
end;

@ We have a number of functions useful for ``drawing'', i.e.,
reporting progress and results (and so on).


@<Report results to command line@>= 
procedure @? InitDisplayLine(const aComment: string); @t\2@>
procedure @? NoDisplayLine(fLine,fErrNbr: integer); @t\2@> @#

@t\4@>@<|DisplayLine| global constant@>@; @#

@ The \\{gComment} is used only within this module. Mizar stores the
name of the pass (parser, MSM, analyzer, checker) in \\{gComment},
which is used in a helper function to print the progress to the console.

@<Implementation for mconsole.pas@>=
var gComment: string = ''; {The pass currently being run}
@#
disable_io_checking;
@#
procedure NoDisplayLine(fLine,fErrNbr: integer);
begin
end;
@#
procedure InitDisplayLine(const aComment: string);
begin
 gComment:=aComment;
 WriteLn;
 write(aComment);
 DisplayLine:=DisplayLineInCurPos
end;

@ @<Report results to command line@>= 
procedure @? DrawMizarScreen(const aApplicationName: string); @t\2@>
procedure @? DrawArticleName(const fName: string); @t\2@> @#

procedure @? DrawStr(const aStr: string); @t\2@>
procedure @? FinishDrawing;

@ @<Implementation for mconsole.pas@>=
procedure DrawStr(const aStr: string);
begin write(aStr) @+ end;
@#
procedure FinishDrawing;
begin WriteLn; end;
@#
procedure DrawTPass(const fPassName: string);
begin write(fPassName) @+ end;
@#
procedure DrawMizarScreen(const aApplicationName: string);
begin
 WriteLn(aApplicationName,', ',PCMizarVersionStr,' (',PlatformNameStr,')');
 WriteLn(Copyright);
end;

@ The \\{Noise} parameter rings the bell three times (the |^G| is
Caret notation ``Ctrl+G'', which is \ASCII/ code 10 \.{BEL}). For
non-Windows systems, this will write three \.{BEL} characters to the
standard output stream. Windows will do nothing.

@<Report results to command line@>=
procedure @? EmptyParameterList; @t\2@>
procedure @? Noise;

@ @<Implementation for mconsole.pas@>=
procedure Noise; @t\2@>
begin @|@/
  if_not_def(WIN32)
  write(^G^G^G); @+
  endif;
end;
@#
procedure EmptyParameterList;
begin
 Noise;
 WriteLn; WriteLn('****  Empty Parameter List ? ****');
 halt(2);
end;

@ When the user asks Mizar to verify an article, Mizar will begin by
writing to the standard output stream ``Processing: \<Article name>''.

@<Implementation for mconsole.pas@>=
procedure DrawArticleName(const fName: string);
begin
 WriteLn('Processing: ',fName); @+
end;

@ @<Report results to command line@>=
procedure @? DrawPass(const aName: string); @t\2@>
procedure @? DrawTime(const aTime: string); @t\2@>
procedure @? DrawVerifierExit(const aTime: string);

@ @<Implementation for mconsole.pas@>=
procedure DrawPass(const aName: string);
begin
 WriteLn;
 write(aName); @+
end;
@#
procedure DrawTime(const aTime: string);
begin
 write(aTime); @+
end;
@#
procedure DrawVerifierExit(const aTime: string);
begin
 WriteLn;
 WriteLn('Time of mizaring:',aTime);
end;

@ On non-Windows machines, |^M| is used in \\{write} to add a carriage
return. Windows machines will require |#13| instead. This is because
|^M| is ``Ctrl+M'' which has \ASCII/ code 77-64=13 (see, it's the same
as |#13|).

% https://stackoverflow.com/a/50188627

@<Report results to command line@>=
procedure @? DisplayLineInCurPos(fLine,fErrNbr: integer);

@<Implementation for mconsole.pas@>=
procedure DisplayLineInCurPos(fLine,fErrNbr: integer);
begin
 if (not CtrlCPressed) and (not QuietMode)then
  begin
   write(^M+gComment+' [',fLine:4);
   if fErrNbr>0 then write(' *',fErrNbr);  
   write(']' );
  end; 
 if FinishingPass then
  begin
   write(' [',fLine:4);
   if fErrNbr>0 then write(' *',fErrNbr);  
   write(']' );
  end; 
end;

@ When Mizar needs to notify the user that a critical error has
occurred, \\{DrawMessage} will be used for communicating it. By
``critical error'', I mean things like Mizar cannot open the file, or
there was a stack overflow, or the hard drive exploded.

\label{mconsole:drawmessage}

@<Report results to command line@>=
procedure @? DrawMessage(const Msg1,Msg2: string);

@ @<Implementation for mconsole.pas@>=
procedure DrawMessage(const Msg1,Msg2: string);
 var Lh: byte;
begin
  Noise;
  WriteLn;
  write('**** ',Msg1);
  Lh:=length(Msg1);
  if length(Msg2)>Lh then Lh:=length(Msg2);
  if Lh > length(Msg1) then write(' ':Lh-length(Msg1));
  WriteLn(' ****');
  if Msg2<>'' then
   begin write('**** ',Msg2);
     if Lh > length(Msg2) then write(' ':Lh-length(Msg2));
     WriteLn(' ****');
   end;
end;

@ The \texttt{monitor.pas} file uses \\{BugInProcessor} when reporting
errors. It's a logging function for severe situations.

@<Report results to command line@>=
procedure @? BugInProcessor;

@ @<Implementation for mconsole.pas@>=
procedure BugInProcessor;
begin
  DrawMessage('Internal Error',''); @+
end;

@ When \\{reset} (or \\{rewrite}) fails, Mizar will cease. We should
specifically report the situation to the user, because they can
address the situation whereas we cannot.

\label{mconsole:drawioresult}
@<Report results to command line@>=
procedure @? DrawIOResult(const FileName: string; @+ I:byte);

@ @<Implementation for mconsole.pas@>=
procedure DrawIOResult(const FileName: string;@+ I:byte);
begin
 if I in [2..6,12,100] then
   begin
     if I=12 then I:=7 else if I=100 then I:=8;
     DrawMessage(ErrMsg[I],'Can''t open '' '+FileName+' ''')
   end
  else DrawMessage('Can''t open '' '+FileName+' ''','');
 halt(1);
end;

@ We also have a constant for error messages commonly encountered.

@<Constants for common error messages reported to console@>=
const
  ErrMsg: array[1..6] of string[20] = @/
       ('', @/
        'File not found', @/
        'Path not found', @/
        'Too many open files', @/
        'Disk read error', @/
        'Disk write error'
       );


@ @<Report results to command line@>=
procedure @? DrawErrorsMsg(aErrorNbr: integer);

@ @<Implementation for mconsole.pas@>=
procedure DrawErrorsMSg(aErrorNbr: integer);
begin
  if aErrorNbr > 0 then
  begin
    WriteLn;
    if aErrorNbr = 1 then
      WriteLn('**** 1 error detected')
    else
      WriteLn('**** ', aErrorNbr, ' errors detected');
  end;
end;
