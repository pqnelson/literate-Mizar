
@* [F] Arbitrary precision arithmetic.
Specifically, arbitrary precision arithmetic on \emph{integers}
and \emph{rational complex} numbers. integers are represented as
Strings of digits.

Note:
\enumerate
\item The naming convention dictates all functions suffixed with |_XXX|
presuppose the arguments are positive.
\item Also there are \emph{no checks} whether the parameters
contain only digits (and an optional sign ``-'').
\item Further, |DEBUGNUM| is a conditional variable that can be used (with
|DEBUG|) for testing. We can easily turn this into a macro.

(I think
 we could even introduce a macro |log_num(#) == debug_num(WriteLn(#))|\dots)
\endenumerate

@d debug_num(#) == @{@&$IFDEF DEBUGNUM@} @+ # @{@&$ENDIF@}

@<numbers.pas@>=
  @<GNU License@>

unit numbers;

interface @|@/
@<Basic arithmetic operations declarations@>@;

type @<Types for arbitrary-precision arithmetic@>@;

const @<Zero and units for arbitrary-precision@>@;

@<Rational arithmetic declarations@>@;

@<Predicate declarations for arbitrary-precision arithmetic@>@;

@<Declare public complex-valued arbitrary precision arithmetic@>@;

@<Declare public comparison operators for arbitrary-precision numbers@>@;

implementation @|@/

uses mizenv @/
if_def(CH_REPORT)@+,req_info,prephan,builtin @+ endif
 mdebug@+,info @+ end_mdebug; @#

@<Trim leading zeros from arbitrary-precision integers@>@;

@<Check if arbitrary-precision integers are zero@>@;

@<Absolute value for an arbitrary-precision number@>@;

@<Test if one arbitrary-precision number is less than or equal to another@>@;

@<Arithmetic for arbitrary-precision integers@>@;

@<Arbitrary-precision rational arithmetic@>@;

@<Complex-rational arbitrary-precision arithmetic@> @t\2@>@;

end.

@* [S] Arbitrary-precision integers.
We will use ``schoolbook arithmetic'', representing an arbitrary
precision integer as a string of digits, possibly leading with an
optional sign. We will ``normalize'' the representation by the
constraint: if the leading digit is zero, then the number is zero. So
we will need to trim superfluous leading zeros.

We will also adopt the convention that the empty string is a synonym
for zero.

@ If we are given single character string consisting of zero or the
empty string, then we are done.

If we are given anything else, we find the first index (from the left)
of a nonzero character. Then we create a copy of the substring
starting from the first nonzero digit to the rest of the string.

This will break if given a string of zeroes like |a = '00'|, in the
sense that the empty string will be returned.

@<Trim leading zeros from arbitrary-precision integers@>=
function trimlz(a : string) : string;
var i : integer;
begin
   if (a='0') or (a='') then trimlz:=a else
   begin
      i:=0;
      repeat
         i:=i+1;
         if a[i]<>'0' then break;
      until i=length(a);
      trimlz:=copy(a,i,length(a));
   end;
end;

@ First, we check if $a$ starts with ``$-0$''. If so, replace $a$ with
$0$. Then we do the same thing with $b$.

We invoke \\{trimlz} on $a$ and store the result in |a1|. If $\\{a1}\I a$,
then we update $a\K\\{a1}$.

Then we do likewise on $b$.

@<Check if arbitrary-precision integers are zero@>=
procedure checkzero(var a,b: string);
var a1,b1 : string;
begin
   @<Convert ``$-0$'' into zero@>;
   @<Trim leading zeros from numerator and denominator@>;
end;

@ @<Convert ``$-0$'' into zero@>=
   if copy(a,1,2)='-0' then
   begin 
      debug_num(WriteLn(infofile,'a=-0')); @/
      a:='0';
   end;
   if copy(b,1,2)='-0' then
   begin 
      debug_num(WriteLn(infofile,'b=-0')); @/
      b:='0';
   end

@ @<Trim leading zeros from numerator and denominator@>=
   a1:=trimlz(a);
   if a1<>a then
   begin 
      debug_num(WriteLn(infofile,'ZEROS1:',a)); @/
      a:=a1;
   end;
   b1:=trimlz(b);
   if b1<>b then
   begin 
      debug_num(WriteLn(infofile,'ZEROS2:',b)); @/
      b:=b1;
   end

@ Since arbitrary precision numbers (as Strings) are negative if they
begin with a leading ``-'' character, it is easy to obtain the
absolute value (just delete the minus sign). This assumes there are
``double negatives'' like |'--5'|; the ``absolute value'' of |'--5'|
would yield |'-5'|, which should be a bug.

@^Bug@>

@<Basic arithmetic operations declarations@>=
function @? Abs(a: string ): string;

@ @<Absolute value for an arbitrary-precision number@>=
function Abs(a: string ): string;
begin
   if length(a)>0 then if a[1]='-' then delete(a,1,1);
   Abs:=a;
end;

@ When checking $a\leq b$ for two non-negative integers, written as
Strings (without leading zeros) you can check if the length of $a$ is
less than the length of $b$.

If the length of $b$ is less than the length of $a$, then $b<a$.

When the length of the two Strings are equal, use lexicographic
ordering to determine which is less.

@<Test if one arbitrary-precision number is less than or equal to another@>=
function _leq(a,b: string): boolean; {compare two positive integers}
var i,x,y,z:integer;
begin
   debug_num(WriteLn(infofile,'_leq(',a,',',b,')'));@/
   checkzero(a,b);
   if length(a)<length(b) then _leq:=true
   else if length(a)>length(b) then _leq:=false
   else
   @<Compare two positive integers with same number of digits@>;
end;

@ @<Compare two positive integers with same number of digits@>=
   begin
      for i:=1 to length(a) do
      begin
         val(a[i],x,z); val(b[i],y,z);
         if x>y then begin _leq:=false; exit; end;
         if x<y then begin _leq:=true; exit; end;
      end;
      _leq:=true;
   end

@ Now the \emph{general} case is when $a$ and $b$ are
arbitrary-precision \emph{integers}. If $a$ starts with a minus sign
and $b$ starts with a minus sign, then test if $a\geq b$.

When $a$ does not start with a minus sign, but $b$ \emph{does} start
with a minus sign, then we're done: $b<a$.

When neither $a$ nor $b$ starts with a minus sign, then we use
$\\{\_leq(a,b)}$ to determine the result.

@<Test if one arbitrary-precision number is less than or equal to another@>=
function leq(a,b: string): Boolean;
begin
   debug_num(WriteLn(infofile,'leq(',a,',',b,')')); @/
   checkzero(a,b);
   if a=b then leq:=true else
   begin
      if (a[1]='-') and (b[1]<>'-') then leq:=true;
      if (a[1]='-') and (b[1]='-') then leq:=not _leq(abs(a),abs(b));
      if (a[1]<>'-') and (b[1]='-') then leq:=false;
      if (a[1]<>'-') and (b[1]<>'-') then leq:=_leq(a,b);
   end;
end;

@ Testing if $a\geq b$ is simply testing if $b\leq a$ after
normalizing the Strings. Mizar implements this by $(a>b)\lor(a=b)$,
since $\neg(a\leq b)$ is identical to $a>b$.

@<Test if one arbitrary-precision number is less than or equal to another@>=
function geq(a,b: string): Boolean;
begin
   debug_num(WriteLn(infofile,'geq(',a,',',b,')')); @/
   checkzero(a,b); @/
   geq:=(not leq(a,b)) or (a=b);
end;

@ Similarly, we may check if $a<b$ by testing $a\neq b$ and $a\leq b$.

@<Test if one arbitrary-precision number is less than or equal to another@>=
function le(a,b: string): Boolean;
begin
   debug_num(WriteLn(infofile,'le(',a,',',b,')')); @/
   checkzero(a,b);
   le:=(a<>b) and (leq(a,b));
end; @#

function gt(a,b: string): Boolean;
begin
   debug_num(WriteLn(infofile,'gt(',a,',',b,')')); @/
   checkzero(a,b);
   gt:= not leq(a,b);
end;

@* [s] Arithmetic operations.
Now we get to some interesting bits.

We have \\{\_Add} for the addition of two non-negative integers. The
basic strategy is to go digit-by-digit, use the \PASCAL/-provided
integer arithmetic, manually ``carrying'' 1 if necessary.

The basic strategy is to initialize \\{a1} to be the larger of the two
numbers, and \\{b1} to the smaller of the two numbers. Then generically
we will have
$${{\displaystyle{{}\atop{+}}{a_{n}\atop{}}{\dots\atop{}}{a_{m+1}\atop{}}{a_{m}\atop b_{m}}{a_{m-1}\atop b_{m-1}} {\dots\atop\dots}{a_{1}\atop b_{1}}}\over{}}\eqno(\modno.1)$$
We will separate this out into two sums. First we compute
$${\displaystyle{{{}\atop{+}}{{}\atop{}}{a_{m}\atop b_{m}}{a_{m-1}\atop b_{m-1}} {\dots\atop\dots}{a_{1}\atop b_{1}}}\over{\hphantom{+}c_{m+1}\;r_{m}\;r_{m-1}\cdots\; r_{1}}}\eqno(\modno.2)$$
Then we will compute
$${\displaystyle{{}\atop{+}}{a_{n}\atop{}}{\dots\atop{}}{a_{m+1}\atop{c_{m+1}}}}\over{r_{n+1}\;r_{n}\;\dots\;r_{m+1}}\eqno(\modno.3)$$
The result is assembled from the digits $r_{n+1}r_{n}\cdots r_{1}$.

\edef\addmodno{\modno}

@<Arithmetic for arbitrary-precision integers@>=
function _Add(a,b :String):string;
var c,x,y,z,v : integer; i:integer; a1,b1,s,r : string;
begin
   @<Copy $a$ and $b$ into \\{a1}, \\{b1} ensuring \\{a1} is a longer string@>;
   r:='';
   c:=0;
   begin
      @<Add \\{a1} and \\{b1} as in step 1, Eq (\addmodno.2)@>;
      @<Carry the $c_{m+1}$ as in step 2, Eq (\addmodno.3)@>;
   end;
   _Add:=trimlz(r);
end;

@ @<Copy $a$ and $b$ into \\{a1}, \\{b1} ensuring \\{a1} is a longer string@>=
   a1:=a; b1:=b;
   debug_num(WriteLn(infofile,'_Add(',a1,',',b1,')'));
   checkzero(a1,b1);
   if length(a1)<length(b1) then
   begin
      s:=b1;
      b1:=a1;
      a1:=s;
   end

@ @<Add \\{a1} and \\{b1} as in step 1, Eq (\addmodno.2)@>=
      for i:=0 to length(b1)-1 do {step 1, Eq (\addmodno.2)}
      begin
	     val(a1[length(a1)-i],x,z);
	     val(b1[length(b1)-i],y,z);
	     if x+y+c>9 then
         begin
            v:=(x+y+c)-10;
            c:=1;
         end
         else
         begin
            v:=x+y+c;
            c:=0;
         end;
	     Str(v,s);
	     r:=s+r;
      end

@ @<Carry the $c_{m+1}$ as in step 2, Eq (\addmodno.3)@>=
      for i:=length(b1) to length(a1)-1 do {step 2, Eq (\addmodno.3)}
      begin
	     val(a1[length(a1)-i],x,z);
	     if x+c>9 then
         begin
            v:=(x+c)-10; c:=1;
         end
         else
         begin
            v:=x+c; c:=0;
         end;
	     Str(v,s);
	     r:=s+r;
      end;
      if c=1 then r:='1'+r

@ Subtraction is a bit trickier, because of the ``borrowing''
operation.

Also note that \\{\_Sub(a,b)} will start by computing
$a_{1}\gets\max(a,b)$ and $b_{1}\gets\min(a,b)$, then return $a_{1}-b_{1}$.
This means the result is always non-negative.

@<Arithmetic for arbitrary-precision integers@>=
function _Sub(a,b :string): string;
var x,y,z,v : integer; i: integer; a1,b1,s,r: string; @/
@t\2@>
   @<``Borrow 1'' procedure for |_Sub|@>@;   

begin
   a1:=a; b1:=b; @/
   debug_num(WriteLn(infofile,'_Sub(',a1,',',b1,')')); @/
   checkzero(a1,b1);
   @<Swap \\{a1} and \\{b1} if $\\{b1}\leq\\{a1}$@>;
   r:=''; @t\1@>
   begin @t\1@>@/
      for i:=0 to length(b1)-1 do
      @<Subtract the $i^{\rm th}$ digit of \\{b1} from \\{a1}@>;
      for i:=length(a1)-length(b1) downto 1 do {nothing left to subtract}
      begin
         r:=a1[i]+r; @+ @t\2@> @+
      end; {so copy remaining digits of minuend}
   end; @t\2@> @/
   _Sub:=trimlz(r); @t\2@>
end;


@ This is a private ``helper function'' for subtraction.

@<``Borrow 1'' procedure for |_Sub|@>=
procedure Borrow(k: integer);
   var xx,zz: integer; sx: string;
   begin
      val(a1[k-1],xx,zz);
      if xx>=1 then begin xx:=xx-1; Str(xx,sx); a1[k-1]:=sx[1]; end
      else begin a1[k-1]:='9'; borrow(k-1); end;
   end;

@ @<Swap \\{a1} and \\{b1} if $\\{b1}\leq\\{a1}$@>=
   if not _leq(b1,a1) then
   begin
      s:=b1;
      b1:=a1;
      a1:=s;
   end

@ We compute $v = x-y$ where $x\K (\\{a1})_{i}$ (possibly borrowing
from the next digit of \\{a1}) and $y\K(\\{b1})_{i}$.
We store this as the next digit in the result $r$.

@<Subtract the $i^{\rm th}$ digit of \\{b1} from \\{a1}@>= 
      begin
         val(a1[length(a1)-i],x,z);
         val(b1[length(b1)-i],y,z);
         if x<y then
         begin
            borrow(length(a1)-i);
            x:=x+10; @+
         end;
         v:=x-y;
         Str(v,s);
         r:=s+r;
      end

@ \node{Multiplication.}%
Multiplication of $a$ by $b$ works digit-by-digit, in the sense that
for each digit $b_{j}$ of $b$, we need to multiply $a$ by $b_{j}$. The
function \\{\_Mul1} does this.

@<Arithmetic for arbitrary-precision integers@>=
function _Mul1(a: string; y: integer ): string;
var c,x,z,v: integer; i:integer; s,r: string;
begin 
   debug_num(WriteLn(infofile,'_Mul1(',a,',',y,')')); @/
   r:='';
   c:=0;
   for i:=0 to length(a)-1 do
   @<Multiply $i^{\rm th}$ digit of $a$ by $y$@>;
   if c<>0 then
   begin
      Str(c,s);
      r:=s+r;
   end;
   _mul1:=trimlz(r);
end;

@ @<Multiply $i^{\rm th}$ digit of $a$ by $y$@>=
   begin
      val(a[length(a)-i],x,z);
      if x*y+c>9 then
      begin
         v:=(x*y+c) mod 10;
         c:=(x*y+c) div 10;
      end
      else
      begin
         v:=x*y+c;
         c:=0;
      end;
      Str(v,s);
      r:=s+r;
   end

@ Then multiplication proper amounts to decomposing $b$ into its
decimal expansion $\sum_{k}b_{k}10^{k}$ and computing $(a\times b_{k})10^{k}$.

@<Arithmetic for arbitrary-precision integers@>=
function _Mul(a,b: string): string;
var y,z: integer; i,j: integer; a1,b1,s,r: string;
begin @/
   @<Copy $a$ into \\{a1} and $b$ into \\{b1}, ensuring \\{b1} is a shorter string@>;
   r:='0';
   for i:=0 to length(b1)-1 do
   @<Multiply $i^{\rm th}$ digit of \\{b1} to \\{a1} and add it to \\{r}@>;
   _Mul:=trimlz(r);
end;

@ @<Copy $a$ into \\{a1} and $b$ into \\{b1}, ensuring \\{b1} is a shorter string@>=
   a1:=a;b1:=b; @/
   debug_num(WriteLn(infofile,'_Mul(',a1,',',b1,')')); @/
   checkzero(a1,b1);
   if length(a1)<length(b1) then begin s:=b1; b1:=a1; a1:=s; @+ end

@ @<Multiply $i^{\rm th}$ digit of \\{b1} to \\{a1} and add it to \\{r}@>=
   begin
      val(b1[length(b1)-i],y,z);
      s:=_mul1(a1,y);
      for j:=0 to i-1 do s:=s+'0';
      r:=_Add(r,s);
   end

@ \node{Division.}%
The basic design is similar to multiplication. We will try to divide
$a$ by $b$ (which is zero whenever $b>a$).
When $b\leq a$, then $a/b$ is the largest digit $i\in\LB\,1,2,\dots,9\,\RB$
such that $bi\leq a$.

There appears to be an implicit assumption that $a<10b$, and both
$a\geq0$ and $b\geq0$ are non-negative integers.

\Ithink{There is no leading zero to $r$, so the \\{trimlz}($r$)
statement is completely superfluous.}

@<Arithmetic for arbitrary-precision integers@>=
function _Div1(a,b: string) : string;
var i: integer; r: string;
begin
   debug_num(WriteLn(infofile,'_Div1(',a,',',b,')')); @/
   checkzero(a,b);
   if not _leq(b,a) then _div1:='0' {$a/b=0$ when $b>a$}
   else
      for i:=9 downto 1 do
      begin
         Str(i,r);
         if _leq(_mul(b,r),a) then
         begin
            _div1:=trimlz(r);
            exit;
         end;
      end;
end;

@ Calculate $q$ such that $a=bq+r$ for some $0\leq r<b$, assuming
$a\geq0$ and $b\geq0$.

@<Basic arithmetic operations declarations@>=
function @? _Div(a,b: string): string;

@ @<Arithmetic for arbitrary-precision integers@>=
function _Div(a,b: string): string;
var z,c,i: integer; s,r,rs : string; b_GPC: Boolean; @/
@<Get the next digit for dividing arbitrary-precision integers@>@;
begin 
   debug_num(WriteLn(infofile,'_Div(',a,',',b,')')); @/
   checkzero(a,b);
   if a=b then _div:='1'
   else if not _leq(b,a) then _div:='0' @t\2@>
   else
   @<Long division of $a$ by $b$@>;
end;

@ We take the leading digits of $a$ and treat them as a new integer
$s=a_{1}\cdots a_{z}$.
We only take as many digits necessary to make $b\leq s$ but with
$a_{1}\cdots a_{z-1}<b$. Then we compute \\{rs} such that
$s=b\times\\{rs}+r$ for some $0\leq r<b$. We update $s\K s - \\{rs}\times b$
and move to the next digit of $a$ (updating $s$) using the \\{gets} function.
This reflects ``long division'' as taught in gradeschool.

@<Long division of $a$ by $b$@>=
   begin
      s:=''; r:=''; z:=1;
      for i:=1 to length(b) do s:=s+a[i]; {copy leading digits of $a$ into $s$}
      @<Ensure $b\leq s$ by adding another digit of $a$, initialize $z$@>;
      {$z\K\\{length}(s)$}
      repeat
         rs:=_div1(s,b);
         r:=r+rs;
         gets;
         b_GPC:= _leq(b,s);
      until not b_GPC;
      _div:=trimlz(r);
   end

@ @<Ensure $b\leq s$ by adding another digit of $a$, initialize $z$@>=
      if _leq(b,s) then z:=length(b)
      else
      begin
         s:=s+a[length(b)+1];
         z:=length(b)+1; @+
      end

@ We just need to ``get the next digit'' of $a$, if available, and
append it to $s$.

@d remaining_digits_are_zero==(trimlz(copy(a,z+c,length(a)))='0')
@<Get the next digit for dividing arbitrary-precision integers@>=
procedure gets;
var j : integer;
begin
   c:=1;
   s:=_Sub(s,_mul(rs,b)); {i.e., $s\K s\mathbin{\&{mod}}b$}
   if (s='0') and remaining_digits_are_zero then
   @<Copy remainder of $a$ into $s$, and terminate the function@>;
   if z+1<=length(a) then
   @<Append next digit of $a$ onto $s$, incrementing $c$@>;
   while (not _leq(b,s)) and (z+c<=length(a)) do
   @<Append next digit of $a$ onto $s$, incrementing $c$@>;
   z:=z+c-1;
end; {gets}

@ @<Copy remainder of $a$ into $s$, and terminate the function@>=
   begin
      debug_num(WriteLn(infofile,'Rewriting zeros:',copy(a,z+c,length(a)))); @/
      r:=r+copy(a,z+c,length(a)); exit;
   end

@ @<Append next digit of $a$ onto $s$, incrementing $c$@>=
   begin
      s:=s+a[z+c];
      inc(c);
      if (not _leq(b,s)) then r:=r+'0'; {shortcut: division will add a zero digit anyways}
   end

@ \node{Modulo.} We can compute $a\mathbin{\&{mod}}b$ by observing if
$a < b$ then we should obtain $a$. Otherwise, we should compute
$q\K a\mathbin{\&{div}} b$, then $a - qb$ is $a\mathbin{\&{mod}}b$.

@<Basic arithmetic operations declarations@>=
function @? _Mod(a,b: string): string;

@ @<Arithmetic for arbitrary-precision integers@>=
function _Mod(a,b : string): string;
var r : string;
begin @/
   debug_num(WriteLn(infofile,'_Mod(',a,',',b,')')); @/
   checkzero(a,b);
   if le(a,b) then r:=a
   else r:=_Sub(a,_Mul(b,_Div(a,b)));
   _Mod:=trimlz(r); @/
   debug_num(WriteLn(infofile,'End _Mod:',r)); @/
end;

@ \node{Greatest common divisor.} \label{numbers:gcd}
We can compute $\gcd(a,b)$ first by setting $a_{1}\gets\abs{a}$ and
$b_{1}\gets\abs{b}$ (since $\gcd(a,b)=\gcd(\abs{a},\abs{b})$. Then we
handle the special cases: 
\enumerate
\item $a_{1}=1$ or $b_{1}=1$, then $\gcd(a_{1},b_{1})=1$
\item $a_{1}=0$ and $b_{1}\neq0$, then $\gcd(a_{1},b_{1})=b_{1}$
\item $a_{1}\neq0$ and $b_{1}=0$, then $\gcd(a_{1},b_{1})=a_{1}$
\item $a_{1}=b_{1}$, then $\gcd(a_{1},b_{1})=a_{1}$
\endenumerate

\medbreak
\noindent Otherwise, we end up in the default case, which is handled
by the \&{while} loop.

@d assign_gcd_and_jump(#) == begin r:=#; goto ex; @+ end

@<Basic arithmetic operations declarations@>=
function @? GCD(a,b: string): string; {*Note: always returns a positive value}

@ @<Arithmetic for arbitrary-precision integers@>=
function GCD(a,b: string): string;
label ex;
var a1,b1,p,r: string;
begin
   a1:=a; b1:=b; @/
   debug_num(WriteLn(infofile,'GCD(',a1,',',b1,')')); @/
   checkzero(a1,b1);
   a1:=abs(a1); b1:=abs(b1);
   if (a1='1') or (b1='1') then assign_gcd_and_jump('1');
   if (a1='0') and (b1<>'0') then assign_gcd_and_jump(b1);
   if (b1='0') and (a1<>'0') then assign_gcd_and_jump(a1);
   if a1=b1 then assign_gcd_and_jump(a1);
   while gt(b1,'0') do {$0 < \\{b1}$}
   begin p:=b1; b1:= _Mod(a1,b1); a1:=p @+ end;
   r:=a1;
   ex:
      GCD:=r; @/
   debug_num(WriteLn(infofile,'End GCD:',r)); @/
end;

@ \node{Least common multiple.} We recall $\lcm(a,b)=\abs{ab}/\gcd(\abs{a},\abs{b})$.

@<Basic arithmetic operations declarations@>=
function @? LCM(a,b: string): string; {*Note: always returns a positive value}

@ @<Arithmetic for arbitrary-precision integers@>=
function LCM(a,b: string): string;
var a1,b1,r: string;
begin
   a1:=a;
   b1:=b; @/
   debug_num(WriteLn(infofile,'LCM(',a1,',',b1,')')); @/
   checkzero(a1,b1);
   a1:=abs(a1);
   b1:=abs(b1);
   r:=DivA(Mul(a1,b1),GCD(a1,b1));
   LCM:=r; @/
   debug_num(WriteLn(infofile,'End LCM:',r)); @/
end;

@ \node{Addition.} This is a bit obfuscated with the reliance of \&{goto} \\{ex},
but the basic idea is (recalling that \\{\_Sub(a,b)} calculates
$\max(a,b)-\min(a,b)$ for $a\geq0$ and $b\geq0$):
\enumerate
\item If $a<0$ and $b<0$, then $a+b=-(\abs{a}+\abs{b})$
\item Else if $a\geq0$ and $b\geq0$, then $a+b$ is computed using \\{\_Add}
\item Else if $a<0$ and $b\geq0$, then we have two cases
\itemitem{(i)} If $\abs{a}\geq b$, compute $a+b=-(\abs{a}-b)$
\itemitem{(ii)} Otherwise, $a+b=b-\abs{a}$
\item Else if $a\geq0$ and $b<0$, then $a+b=a-\abs{b}$
\item Otherwise, when $a\geq0$ and $b\geq0$, $a+b$ is computed
using \\{\_Add}.
\endenumerate

@<Basic arithmetic operations declarations@>=
function @? Add(a,b: string): string;

@ @<Arithmetic for arbitrary-precision integers@>=
function Add(a,b: string ): string;
label ex; var r: string;
begin
   debug_num(WriteLn(infofile,'Add(',a,',',b,')')); @/
   checkzero(a,b);
   if (a[1]='-') and (b[1]='-') then
   @<Add two negative integers, and \&{goto} \\{ex}@>;
   if (a[1]<>'-') and (b[1]<>'-') then
   begin
      r:=_Add(a,b);
      goto ex; @+
   end;
   if (a[1]='-') and (b[1]<>'-') then
   @<Calculate $(-a)+b=b-a$ and \&{goto} \\{ex}@>;
   if (a[1]<>'-') and (b[1]='-') then
   @<Calculate $a+(-b)=a-b$ and \&{goto} \\{ex}@>;
   ex:
      Add:=r; @/
   debug_num(WriteLn(infofile,'End Add:',r)); @/
end;

@ @<Add two negative integers, and \&{goto} \\{ex}@>=
   begin
      r:='-'+_Add(abs(a),abs(b));
      if r='-0' then r:='0';
      goto ex;
   end

@ @<Calculate $(-a)+b=b-a$ and \&{goto} \\{ex}@>=
      if gt(abs(a),b) then
      begin
         r:='-'+_Sub(abs(a),b);
         if r='-0' then r:='0';
         goto ex;
      end
      else begin
         r:=_Sub(abs(a),b);
         goto ex; @+
      end

@ @<Calculate $a+(-b)=a-b$ and \&{goto} \\{ex}@>=
      if gt(abs(b),a) then
      begin
         r:='-'+_Sub(abs(b),a);
         if r='-0' then r:='0';
         goto ex;
      end
      else begin
         r:=_Sub(abs(b),a);
         goto ex; @+
      end

@ \node{Subtraction.} Now, given two arbitrary precision integers, we
can compute their difference. Again, \&{goto} \\{ex} obfuscates the flow
here, but the basic logic is:
\enumerate
\item If $a<0$ and $b\geq0$, then $a-b=-(\abs{a}+b)$
\item Else if $a\geq0$ and $b<0$, then $a-b=a+\abs{b}$
\item Else if $a<0$ and $b<0$, then we have two cases
\itemitem{(i)} If $\abs{a}>\abs{b}$, then $a-b=-(\abs{a}-\abs{b})$
\itemitem{(ii)} Otherwise $\abs{a}\leq\abs{b}$, so $a-b=\abs{a}-\abs{b}$
\item Else if $a\geq0$ and $b\geq0$, then we have two cases
\itemitem{(i)} If $b>a$, then $a-b=-(b-a)$
\itemitem{(ii)} Otherwise compute $a-b$ using \\{\_Sub(a,b)}
\endenumerate

\medbreak\noindent Testing if $x<0$ is done by checking $\sgn(x)=-1$, and
$x\geq0$ tests if $\sgn(x)\neq-1$.

@<Basic arithmetic operations declarations@>=
function @? Sub(a,b: string): string;

@ @<Arithmetic for arbitrary-precision integers@>=
function Sub(a,b: string): string;
label ex; var r: string;
begin
   debug_num(WriteLn(infofile,'Sub(',a,',',b,')')); @/
   checkzero(a,b);
   if (a[1]='-') and (b[1]<>'-') then
   @<Calculate $(-a)-b=-(a+b)$ and \&{goto} \\{ex}@>;
   if (a[1]<>'-') and (b[1]='-') then begin r:=_Add(a,abs(b)); goto ex; @+ end;
   if (a[1]='-') and (b[1]='-') then
   @<Calculate $(-a)-(-b)$ and \&{goto} \\{ex}@>;
   if (a[1]<>'-') and (b[1]<>'-') then
   @<Calculate difference of two positive integers@>;
   ex:
      Sub:=r; @/
   debug_num(WriteLn(infofile,'End Sub:',r)); @/
end;

@ @<Calculate $(-a)-b=-(a+b)$ and \&{goto} \\{ex}@>=
   begin
      r:='-'+_Add(abs(a),b);
      if r='-0' then r:='0';
      goto ex;
   end

@ @<Calculate $(-a)-(-b)$ and \&{goto} \\{ex}@>=
      if gt(abs(a),abs(b)) then
      begin
         r:='-'+_Sub(abs(a),abs(b));
         if r='-0' then r:='0';
         goto ex;
      end
      else begin r:=_Sub(abs(a),abs(b)); goto ex; @+ end

@ @<Calculate difference of two positive integers@>=
      if gt(b,a) then
      begin
         r:='-'+_Sub(b,a);
         if r='-0' then r:='0';
         goto ex;
      end
      else begin r:=_Sub(a,b); goto ex; @+ end

@ \node{Multiplication of arbitrary-precision integers.}
We calculate the product of $a$ with $b$ by handling the case where
$\sgn(a)\neq\sgn(b)$ as $ab=-\abs{a}\cdot\abs{b}$. Otherwise we can
just rely on the \\{\_Mul(a,b)} to do our work.

@<Basic arithmetic operations declarations@>=
function @? Mul(a,b: string): string;

@ @<Arithmetic for arbitrary-precision integers@>=
function Mul(a,b: string ): string;
label ex; var r: string;
begin
   debug_num(WriteLn(infofile,'Mul(',a,',',b,')')); @/
   checkzero(a,b);
   if ((a[1]='-') and (b[1]<>'-')) or ((a[1]<>'-') and (b[1]='-')) then
   begin
      r:='-'+_Mul(abs(a),abs(b));
      if r='-0' then r:='0';
   end
   else r:=_Mul(abs(a),abs(b));
   ex:
      Mul:=r; @/
   debug_num(WriteLn(infofile,'End Mul:',r)); @/
end;

@ \node{DivA.} This is the division for arbitrary-precision
integers. Like multiplication, we handle the case $\sgn(a)\neq\sgn(b)$
by computing $a/b = -\abs{a}/\abs{b}$.

@<Basic arithmetic operations declarations@>=
function @? DivA(a,b: string): string; {*Note: divides absolute values and preserves the sign of the division}

@ @<Arithmetic for arbitrary-precision integers@>=
function DivA(a,b: string ): string;
label ex; var r: string;
begin
   debug_num(WriteLn(infofile,'DivA(',a,',',b,')')); @/
   checkzero(a,b);
   if ((a[1]='-') and (b[1]<>'-')) or ((a[1]<>'-') and (b[1]='-')) then
   begin
      r:='-'+_Div(abs(a),abs(b));
      if r='-0' then r:='0';
   end
   else r:=_Div(abs(a),abs(b));
   ex:
      DivA:=r; @/
   debug_num(WriteLn(infofile,'End DivA:',r)); @/
end;

@ \node{Testing for primality.}
We can test if a given arbitrary-precision integer is prime or not.
Specifically, we restrict attention to \emph{positive} integers.

The \&{while} loop calculates \\{Mul(i,i)} because Fermat observed we only
need to check numbers \emph{up to} $\lceil\sqrt{x}\rceil$ as prime
factors of $x$. But this calulation is a bit costly. This could be
approximated by taking the length of the underlying String $n=\abs{s}$
and looking at the leading $\lceil n/2\rceil$ digits $s_{\rm lead}$.
It's not hard to see that the number $x_{\rm lead}$ described
by $s_{\rm lead}$ satisfies $x_{\rm lead}^{2}\geq x$.

@<Basic arithmetic operations declarations@>=
function @? IsPrime(a: string): Boolean;

@ @<Arithmetic for arbitrary-precision integers@>=
function IsPrime(a: string): Boolean;
var i: string;
r: Boolean;
begin
   if leq('2',a) then 
   begin
      r:=true;
      i:='2';
      while leq(Mul(i,i),a) do
      begin
         if GCD(a,i)=i then
         begin
            r:=false;
            break; @+
         end;
         i:=Add(i,'1');
      end;
   end
   else r:=false;
   IsPrime:=r;
end;

@ \node{Divides relation.}
We can check if ``$x$ divides $y$'' by testing if $\gcd(x,y)=\abs{x}$.

@<Basic arithmetic operations declarations@>=
function @? Divides(a,b: String): boolean;

@ @<Arithmetic for arbitrary-precision integers@>=
function Divides(a,b: string): Boolean;
var r: Boolean;
begin
    r:=GCD(a,b)=abs(a);
    Divides:=r;
end;

@* [S] Arbitrary-precision rational arithmetic.
Rational numbers are a pair of arbitrary precision integers
(represented as a String). The convention is that the denominator is
a \emph{strictly positive} integer.

@<Types for arbitrary-precision arithmetic@>=
   Rational = record Num,Den : string end;

@ ``Zero'' and ``one'' are frequently used rational numbers, so we
should define them as constants.

@<Zero and units for arbitrary-precision@>=
   RZero:Rational = (Num:'0'; Den:'1');
   ROne:Rational  = (Num:'1'; Den:'1');

@ \node{Rational arithmetic.} Now we begin the rational arithmetic
``in earnest''. The first thing to do is provide a way to compute the
reduced form for a fraction, i.e.,
$$\frac{n}{d} = \frac{n/\gcd(n,d)}{d/\gcd(n,d)}$$

@<Rational arithmetic declarations@>=
procedure @? RationalReduce(var r: Rational);

@ @<Arbitrary-precision rational arithmetic@>=
procedure RationalReduce(var r: Rational);
var lGcd:String;
begin
   lGcd := gcd(r.Num,r.Den);
   r.Num := diva(r.Num,lGcd);
   r.Den := diva(r.Den,lGcd);
end;

@ \node{Rational addition.}
We recall
$$ \frac{a}{b} + \frac{c}{d} = \frac{ad+bc}{bd} $$
We should return the reduced form of the result.

@<Rational arithmetic declarations@>=
function @? RationalAdd(const r1,r2: Rational): Rational;

@ @<Arbitrary-precision rational arithmetic@>=
function RationalAdd(const r1,r2: Rational): Rational;
var lRes: Rational;
begin
   lRes.Num := Add(Mul(r1.Num,r2.Den),Mul(r1.Den,r2.Num));
   lRes.Den := Mul(r1.Den,r2.Den);
   RationalReduce(lRes);
   RationalAdd:=lRes;
end;

@ \node{Rational subtraction.} Similar to addition, but the numerator
is $ad-bc$.

@<Rational arithmetic declarations@>=
function @? RationalSub(const r1,r2: Rational): Rational;

@ @<Arbitrary-precision rational arithmetic@>=
function RationalSub(const r1,r2: Rational): Rational;
var lRes: Rational;
begin
   lRes.Num := Sub(Mul(r1.Num,r2.Den),Mul(r1.Den,r2.Num));
   lRes.Den := Mul(r1.Den,r2.Den);
   RationalReduce(lRes);
   RationalSub:= lRes;
end;

@ Negating a rational number amounts to multiplying the numerator by
$-1$.

@<Rational arithmetic declarations@>=
function @? RationalNeg(const r1: Rational): Rational;

@ @<Arbitrary-precision rational arithmetic@>=
function RationalNeg(const r1: Rational): Rational;
var lRes: Rational;
begin
   lRes.Num:= Mul('-1',r1.Num);
   lRes.Den:= r1.Den;
   RationalNeg := lRes;
end;

@ \node{Multiplying rational numbers.}
This uses the school-book formula
$$\frac{a}{b}\times\frac{c}{d}=\frac{ac}{bd}$$

@<Rational arithmetic declarations@>=
function @? RationalMult(const r1,r2: Rational): Rational;

@ @<Arbitrary-precision rational arithmetic@>=
function RationalMult(const r1,r2: Rational): Rational;
var lRes: Rational;
begin
   lRes.Num := Mul(r1.Num,r2.Num);
   lRes.Den := Mul(r1.Den,r2.Den);
   RationalReduce(lRes);
   RationalMult:= lRes;
end;

@ \node{Inverting a rational number.}
This is easy, provided the numerator is nonzero. The convention is to
make the numerator carry the sign of the number (so $n/d$ has
$n\in\ZZ$ while $d\in\NN$).

When the rational number \emph{is} zero, we simply take $0^{-1}=0$ (as
is conventional among proof assistants).

@<Rational arithmetic declarations@>=
function @? RationalInv(const r: Rational): Rational;

@ @<Arbitrary-precision rational arithmetic@>=
function RationalInv(const r: Rational): Rational;
var lRes: Rational;
begin
   if r.Num <> '0' then
   begin
      if le(r.Num,'0') then
         lRes.Num := Mul('-1',r.Den)
      else lRes.Num := r.Den;
      lRes.Den := Abs(r.Num);
   end
   else lRes := RZero;
   RationalInv:= lRes;
end;

@ \node{Dividing rational numbers.}
We see that $r_{1}/r_{2}=r_{1}\times(r_{2}^{-1})$. That's the trick.

@<Rational arithmetic declarations@>=
function @? RationalDiv(const r1,r2: Rational): Rational;

@ @<Arbitrary-precision rational arithmetic@>=
function RationalDiv(const r1,r2: Rational): Rational;
begin
   RationalDiv := RationalMult(r1,RationalInv(r2));
end;

@ \node{Equality of rational numbers.}
Two rational numbers $n_{1}/d_{1}$ and $n_{2}/d_{2}$ are equal if
$n_{1}=n_{2}$ and $d_{1}=d_{2}$. This assumes that both rational
numbers are in reduced form.


@<Rational arithmetic declarations@>=
function @? RationalEq(const r1,r2: Rational): boolean;

@ @<Arbitrary-precision rational arithmetic@>=
function RationalEq(const r1,r2: Rational): boolean;
begin
   RationalEq := (r1.Num = r2.Num) and (r1.Den = r2.Den);
end;

@ \node{Testing inequality of rational numbers.}\label{numbers:rationalgt}
We have $n_{1}/d_{1} \leq n_{2}/d_{2}$ if $n_{1}d_{2}\leq n_{2}d_{1}$.

Similarly, we have $n_{1}/d_{1}>n_{2}/d_{1}$ is just the negation
of $n_{1}/d_{1} \leq n_{2}/d_{2}$.

@<Rational arithmetic declarations@>=
function @? RationalLE(const r1,r2: Rational): boolean; @t\2@>
function @? RationalGT(const r1,r2: Rational): boolean;

@ @<Arbitrary-precision rational arithmetic@>=
function RationalLE(const r1,r2: Rational): boolean;
begin
   RationalLE := leq(Mul(r1.Num,r2.Den),Mul(r1.Den,r2.Num));
end;

function RationalGT(const r1,r2: Rational): boolean;
begin
   RationalGT := not RationalLE(r1,r2);
end;

@* [S] Rational complex numbers.
We now begin with $\QQ+{\rm i}\QQ\subset\CC$, the subset of
complex-numbers where the real and imaginary parts are rational
numbers.

That is to say, rational complex numbers are represented by a pair of
rational numbers in Cartesian form $z = p + {\rm i} q$.

@<Types for arbitrary-precision arithmetic@>=
   RComplex = record  Re,Im: Rational end;

@ @<Zero and units for arbitrary-precision@>=
   CZero: RComplex     = (Re:(Num:'0'; Den:'1'); Im:(Num:'0'; Den:'1'));
   COne: RComplex      = (Re:(Num:'1'; Den:'1'); Im:(Num:'0'; Den:'1'));
   CMinusOne: RComplex = (Re:(Num:'-1'; Den:'1'); Im:(Num:'0'; Den:'1'));
   CImUnit: RComplex   = (Re:(Num:'0'; Den:'1'); Im:(Num:'1'; Den:'1'));

@ We want to know when these numbers describe integers (i.e., the
imaginary part is zero and the denominator of the real part is 1) and
natural numbers (i.e., when furthermore the numerator of the real part
is non-negative).

@<Predicate declarations for arbitrary-precision arithmetic@>=
function @? IsIntegerNumber(const z: RComplex): Boolean; @t\2@>
function @? IsNaturalNumber(const z: RComplex): Boolean; @t\2@>
function @? IsPrimeNumber(const z: RComplex): Boolean; @t\2@> @#

@ @<Complex-rational arbitrary-precision arithmetic@>=
function IsIntegerNumber(const z: RComplex): Boolean;
begin
   IsIntegerNumber := (z.Im.Num = '0') and (z.Re.Den = '1'); @+
end;@#

function IsNaturalNumber(const z: RComplex): Boolean;
begin
   IsNaturalNumber := (z.Im.Num = '0') and (z.Re.Den = '1') and (geq(z.Re.Num,'0')); @+
end;@#

function IsPrimeNumber(const z: RComplex): boolean;
begin
    if IsNaturalNumber(z) and IsPrime(z.Re.Num) then IsPrimeNumber := true
    else IsPrimeNumber := false;
end;

@ \node{Equality of complex numbers.}
This amounts to checking if the real and imaginary parts are equal to
each other as rational numbers.

@<Predicate declarations for arbitrary-precision arithmetic@>=
function @? AreEqComplex(const z1,z2: RComplex): Boolean; @t\2@>
function @? IsEqWithInt(const z: RComplex; @t\hskip10.3333pc@> n: longint): Boolean;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function AreEqComplex(const z1,z2: RComplex): Boolean;
begin
   AreEqComplex := RationalEq(z1.Re,z2.Re) and RationalEq(z1.Im,z2.Im); @+
end;@#

function IsEqWithInt(const z: RComplex; @t\hskip10.3333pc@> n: longint): Boolean;
var s : string;
begin
   Str(n,s);
   IsEqWithInt := (z.Im.Num = '0') and (z.Re.Num = s) and (z.Re.Den = '1'); @+
end;

@ \node{``Inequalities''.}\label{numbers:isrationalle}
We ``induce'' the binary relations $<$ and $\geq$
on the subset $\{q+{\rm i}0\mid q\in\QQ\}\subset\CC$.
Again, what we said earlier about \\{RationalGT} being badly named holds
for \\{IsRationalGT} being badly named as well.

@<Predicate declarations for arbitrary-precision arithmetic@>=
function @? IsRationalLE(const z1,z2 : RComplex): Boolean; @t\2@>
function @? IsRationalGT(const z1,z2 : RComplex): Boolean;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function IsRationalLE(const z1,z2 : RComplex): Boolean;
begin
   IsRationalLE := (z1.Im.Num = '0') and (z2.Im.Num = '0') and RationalLE(z1.Re,z2.Re); @+
end; @#

function IsRationalGT(const z1,z2 : RComplex): Boolean;
begin
   IsRationalGT := (z1.Im.Num = '0') and (z2.Im.Num = '0') and RationalGT(z1.Re,z2.Re); @+
end;

@* [s] Arithmetic operations.
\node{Converting integers to complex numbers.} We have a function to
convert an integer $x\in\ZZ$ to be the complex number $(x/1) + {\rm i}(0/1)\in\CC$.

@<Declare public complex-valued arbitrary precision arithmetic@>=
function @? IntToComplex(x: integer): RComplex;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function IntToComplex(x: integer): RComplex;
var lRes: RComplex;
begin
   lRes:=COne;
   lRes.Re.Num:=IntToStr(x);
   IntToComplex:= lRes;
end;

@ \node{Adding complex numbers.}
We compute the sum of $(x_{1}+{\rm i}y_{1})$
and $x_{2} + {\rm i}y_{2}$ to be $(x_{1}+x_{2})+{\rm i}(y_{1}+y_{2})$.

@<Declare public complex-valued arbitrary precision arithmetic@>=
function @? ComplexAdd (const z1,z2: RComplex): RComplex;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function ComplexAdd(const z1,z2 : RComplex): RComplex;
var lRes: RComplex; @t\2@>
begin
   lRes.Re := RationalAdd(z1.Re,z2.Re);
   lRes.Im := RationalAdd(z1.Im,z2.Im);
   if_def(CH_REPORT) @t\enspace @>
   CHReport.Out_NumReq3(rqRealAdd, z1, z2, lRes); @+
   endif@; @/
   ComplexAdd:= lRes;
end;

@ \node{Subtracting complex numbers.}
We find the difference of complex numbers componentwise.

@<Declare public complex-valued arbitrary precision arithmetic@>=
function @? ComplexSub(const z1,z2: RComplex): RComplex;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function ComplexSub(const z1,z2: RComplex): RComplex;
var lRes: RComplex;
begin
   lRes.Re := RationalSub(z1.Re,z2.Re);
   lRes.Im := RationalSub(z1.Im,z2.Im); @/
   if_def(CH_REPORT) @t\enspace @>
   CHReport.Out_NumReq3(rqRealDiff, z1, z2, lRes); @+
   end_if@; @/
   ComplexSub:= lRes;
end;

@ \node{Negating complex numbers.} We negate a complex number $-z$ by
negating its real and imaginary parts.

@<Declare public complex-valued arbitrary precision arithmetic@>=
function @? ComplexNeg (const z: RComplex): RComplex;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function ComplexNeg(const z: RComplex): RComplex;
var lRes:RComplex;
begin
   lRes.Re := RationalNeg(z.Re);
   lRes.Im := RationalNeg(z.Im); @/
   if_def(CH_REPORT) @t\enspace @>
   CHReport.Out_NumReq2(rqRealNeg, z, lRes); @+
   end_if@;@/
   ComplexNeg:=lRes;
end;

@ \node{Multiplying complex numbers.}
We use the usual formula
$$(x_{1}+{\rm i}y_{1})(x_{2}+{\rm i}y_{2}) = (x_{1}x_{2}-y_{1}y_{2})+{\rm i}(x_{1}y_{2}+y_{1}x_{2}).$$

@<Declare public complex-valued arbitrary precision arithmetic@>=
function @? ComplexMult(const z1,z2: RComplex): RComplex;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function ComplexMult(const z1,z2 : RComplex): RComplex;
var lRes:RComplex;
begin
   if IsEqWithInt(z1, -1) then ComplexMult:= ComplexNeg(z2)
   else if IsEqWithInt(z2, -1) then ComplexMult:= ComplexNeg(z1)
   else
   @<Calculate the usual multiplication of complex numbers@>;
end;

@ @<Calculate the usual multiplication of complex numbers@>=
   begin
      lRes.Re := RationalSub(RationalMult(z1.Re,z2.Re),RationalMult(z1.Im,z2.Im));
      lRes.Im := RationalAdd(RationalMult(z1.Re,z2.Im),RationalMult(z1.Im,z2.Re));
      ComplexMult:=lRes; @/
      if_def(CH_REPORT) @t\enspace @>
      CHReport.Out_NumReq3(rqRealMult, z1, z2, lRes); @+
      end_if@;
   end

@ \node{Dividing complex numbers.} We recall
$$\frac{x_{1} + {\rm i}y_{1}}{x_{2} + {\rm i}y_{2}} = \frac{(x_{1} + {\rm i}y_{1})(x_{2} - {\rm i}y_{2})}{x_{2}^{2} + y_{2}^{2}}$$
This is the case for nonzero $z_{2}\neq0$. When we try to divide
$z_{1}/0$, we return $0$.

@<Declare public complex-valued arbitrary precision arithmetic@>=
function @? ComplexDiv(const z1,z2: RComplex): RComplex;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function ComplexDiv(const z1,z2: RComplex) : RComplex;
var lDenom : Rational;
   lRes:RComplex;
begin
   lRes:=CZero;
   with z2 do
      lDenom := RationalAdd(RationalMult(Re,Re),RationalMult(Im,Im));
   if lDenom.Num <> '0' then
   @<Calculate quotient for nonzero divisor@>;
   ComplexDiv:=lRes;
end;

@ @<Calculate quotient for nonzero divisor@>=
   begin @|@/
      lRes.Re := RationalDiv(RationalAdd(RationalMult(z1.Re,z2.Re),
                                         RationalMult(z1.Im,z2.Im)),
                          @t\hskip7.5pc@>   lDenom); @/
      lRes.Im := RationalDiv(RationalSub(RationalMult(z1.Im,z2.Re),
                                         RationalMult(z1.Re,z2.Im)),
                          @t\hskip7.5pc@>   lDenom); @/

      if_def(CH_REPORT) @t\enspace @>
      CHReport.Out_NumReq3(rqRealDiv, z1, z2, lRes); @+
      end_if@;
   end

@ \node{Inverting complex numbers.}
We can now calculate $z^{-1}$ as just $1/z$.

@<Declare public complex-valued arbitrary precision arithmetic@>=
function @? ComplexInv(const z: RComplex): RComplex;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function ComplexInv(const z: RComplex): RComplex;
begin
   ComplexInv:=ComplexDiv(COne,z); @+
end;

@ \node{Norm of complex numbers.} The ``norm'' or \emph{modulus} for a
complex number is just the sum of the square of its components (well,
the squareroot of this sum).

@<Declare public complex-valued arbitrary precision arithmetic@>=
function @? ComplexNorm(const z: RComplex): Rational;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function ComplexNorm(const z: RComplex): Rational;
begin
   ComplexNorm:=RationalAdd(RationalMult(Z.Re,Z.Re),RationalMult(Z.Im,Z.Im)); @+
end;

@* [S] Comparison functions.
The remainder of \texttt{numbers.pas} defines functions which compares
numbers. These must return a value in the set $\{-1,0,+1\}$ as
a \PASCAL/ \\{integer}.

@<Declare public comparison operators for arbitrary-precision numbers@>=
function @? CompareInt(X1,X2: longint): integer; @t\2@>
function @? CompareIntStr(X1,X2: string): integer;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function CompareInt(X1, X2: longint): integer;
begin
   if X1 = X2 then CompareInt := 0
   else if X1 > X2 then CompareInt := 1
   else CompareInt := -1;
end; @#

function CompareIntStr(X1, X2: string): integer;
begin
   if X1 = X2 then CompareIntStr := 0
   else if gt(X1,X2) then CompareIntStr := 1
   else CompareIntStr := -1;
end;

@ There is also a function to ``compare'' complex numbers. This treats
a complex number
$$ z = \frac{n_{1}}{d_{1}} + {\rm i}\frac{n_{2}}{d_{2}}$$
as a tuple $(n_{1},d_{1},n_{2},d_{2})$ then uses lexicographic
ordering based on the components.

@<Declare public comparison operators for arbitrary-precision numbers@>=
function @? CompareComplex(const z1,z2: RComplex): integer;

@ @<Complex-rational arbitrary-precision arithmetic@>=
function CompareComplex(const z1,z2: RComplex): integer;
var lInt: integer;
begin
   lInt:=CompareIntStr(z1.Re.Num,z2.Re.Num);
   if lInt <> 0 then begin CompareComplex:=lInt; exit @+ end;
   lInt:=CompareIntStr(z1.Re.Den,z2.Re.Den);
   if lInt <> 0 then begin CompareComplex:=lInt; exit @+ end;
   lInt:=CompareIntStr(z1.Im.Num,z2.Im.Num);
   if lInt <> 0 then begin CompareComplex:=lInt; exit @+ end;
   CompareComplex:=CompareIntStr(z1.Im.Den,z2.Im.Den);
end;
