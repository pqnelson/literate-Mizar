
@* [F] Arbitrary precision arithmetic.
Specifically, arbitrary precision arithmetic on \emph{integers}
and \emph{rational complex} numbers. integers are represented as
Strings of digits.

Note:
\enumerate
\item The naming convention dictates all functions suffixed with |_XXX|
presuppose the arguments are positive.
\item Also there are \emph{no checks} whether the parameters
contain only digits (and an optional sign ``-'').
\item Further, |DEBUGNUM| is a conditional variable that can be used (with
|DEBUG|) for testing.
\endenumerate

@<numbers.pas@>=
  @<GNU License@>

unit numbers;

interface @|@/
@<Basic arithmetic operations declarations@>@;

@<Types for arbitrary-precision arithmetic@>@;

@<Zero and units for arbitrary-precision@>@;

@<Rational arithmetic declarations@>@;

@<Predicate declarations for arbitrary-precision arithmetic@>@;

@<Declare public complex-valued arbitrary precision arithmetic@>@;

@<Declare public comparison operators for arbitrary-precision numbers@>@;

implementation @|@/

uses mizenv @/
@{@&$IFDEF CH_REPORT@}@+,req_info,prephan,builtin @{@&$ENDIF@} 
 mdebug@+,info @+ end_mdebug; @t\2@> @|@# 

@<Trim leading zeros from arbitrary-precision integers@>@;

@<Check if arbitrary-precision integers are zero@>@;

@<Absolute value for an arbitrary-precision number@>@;

@<Test if one arbitrary-precision number is less than or equal to another@>@;

@<Arithmetic for arbitrary-precision integers@>@;

@<Arbitrary-precision rational arithmetic@>@;

@<Complex-rational arbitrary-precision arithmetic@>@;

@ @<Basic arithmetic operations declarations@>=
function @? Add(a,b: String): String; @t\2@>
function @? Sub(a,b: String): String; @t\2@>
function @? Mul(a,b: String): String; @t\2@>
function @? Diva(a,b: String): String; @t\2@> {*Note: divides absolute values and preserves the sign of the division}
function @? _Div(a,b: String): String; @t\2@>
function @? _Mod(a,b: String): String; @t\2@>
function @? GCD(a,b: String): String; @t\2@> {*Note: always returns a positive value}
function @? LCM(a,b: String): String; @t\2@> {*Note: always returns a positive value}
function @? Abs(a :String ): String; @t\2@>
function @? IsPrime(a: String): boolean; @t\2@>
function @? Divides(a,b: String): boolean;

@ Rational numbers are a pair of arbitrary precision integers
(represented as a String).

Rational complex numbers are represented by a pair of rational numbers
in Cartesian form $z = p + {\rm i} q$.

@<Types for arbitrary-precision arithmetic@>=
type
   Rational = record Num,Den : String end;
   RComplex = record  Re,Im: Rational end;

@ @<Zero and units for arbitrary-precision@>=
const
   RZero:Rational = (Num:'0'; Den:'1');
   ROne:Rational  = (Num:'1'; Den:'1');
   CZero: RComplex     = (Re:(Num:'0'; Den:'1'); Im:(Num:'0'; Den:'1'));
   COne: RComplex      = (Re:(Num:'1'; Den:'1'); Im:(Num:'0'; Den:'1'));
   CMinusOne: RComplex = (Re:(Num:'-1'; Den:'1'); Im:(Num:'0'; Den:'1'));
   CImUnit: RComplex   = (Re:(Num:'0'; Den:'1'); Im:(Num:'1'; Den:'1'));

@ @<Rational arithmetic declarations@>=
procedure @? RationalReduce(var r: Rational); @t\2@>
function @? RationalAdd(const r1,r2: Rational): Rational; @t\2@>
function @? RationalSub(const r1,r2: Rational): Rational; @t\2@>
function @? RationalNeg(const r1: Rational): Rational; @t\2@>
function @? RationalMult(const r1,r2: Rational): Rational; @t\2@>
function @? RationalInv(const r: Rational): Rational; @t\2@>
function @? RationalDiv(const r1,r2: Rational): Rational; @t\2@>
function @? RationalEq(const r1,r2: Rational): boolean; @t\2@>
function @? RationalLE(const r1,r2: Rational): boolean; @t\2@>
function @? RationalGT(const r1,r2: Rational): boolean;

@ @<Predicate declarations for arbitrary-precision arithmetic@>=
function @? IsintegerNumber(const z: RComplex): boolean; @t\2@>
function @? IsNaturalNumber(const z: RComplex): boolean; @t\2@>
function @? IsPrimeNumber(const z: RComplex): boolean; @t\2@> @#

function @? AreEqComplex(const z1,z2: RComplex): boolean; @t\2@>
function @? IsEqWithInt(const z: RComplex; @t\hskip11.25pc@> n: longint): boolean; @t\2@>
function @? IsRationalLE(const z1,z2 : RComplex): boolean; @t\2@>
function @? IsRationalGT(const z1,z2 : RComplex): boolean;

@ @<Declare public complex-valued arbitrary precision arithmetic@>=
function @? IntToComplex(x: integer): RComplex; @t\2@>
function @? ComplexAdd (const z1,z2: RComplex): RComplex; @t\2@>
function @? ComplexSub(const z1,z2: RComplex): RComplex; @t\2@>
function @? ComplexNeg (const z: RComplex): RComplex; @t\2@>
function @? ComplexMult(const z1,z2: RComplex): RComplex; @t\2@>
function @? ComplexInv(const z: RComplex): RComplex; @t\2@>
function @? ComplexDiv(const z1,z2: RComplex): RComplex; @t\2@>
function @? ComplexNorm(const z: RComplex): Rational;

@ @<Declare public comparison operators for arbitrary-precision numbers@>=
function @? CompareInt(X1,X2: Longint): integer; @t\2@>
function @? CompareIntStr(X1,X2: String): integer; @t\2@>
function @? CompareComplex(const z1,z2: RComplex): integer;

@ If we are given single character String consisting of zero or the
empty String, then we are done.

If we are given anything else, we find the first index (from the left)
of a nonzero character. Then we create a copy of the subString
starting from the first nonzero digit to the rest of the String.

@<Trim leading zeros from arbitrary-precision integers@>=
function trimlz(a : String) : String;
var i : integer;
begin
   if (a='0') or (a='') then trimlz:=a else
   begin
   i:=0;
   repeat
   i:=i+1;
   if a[i]<>'0' then break;
   until i=length(a);
   trimlz:=copy(a,i,length(a));
   end;
end;

@ First, we check if $a$ starts with ``$-0$''. If so, replace $a$ with
$0$. Then we do the same thing with $b$.

We invoke \\{trimlz} on $a$ and store the result in |a1|. If $\\{a1}\I a$,
then we update $a\K\\{a1}$.

Then we do likewise on $b$.

@<Check if arbitrary-precision integers are zero@>=
procedure checkzero(var a,b :String);
var a1,b1 : String;
begin
   if copy(a,1,2)='-0' then
   begin @|@/
      @{@&$IFDEF DEBUGNUM@}
      WriteLn(infofile,'a=-0'); @/
      @{@&$ENDIF@}
      a:='0';
   end;
   if copy(b,1,2)='-0' then
   begin @|@/
      @{@&$IFDEF DEBUGNUM@}
      WriteLn(infofile,'b=-0'); @/
      @{@&$ENDIF@} @/
      b:='0';
   end;
   a1:=trimlz(a); if a1<>a then
   begin @|@/
      @{@&$IFDEF DEBUGNUM@}
      WriteLn(infofile,'ZEROS1:',a); @/
      @{@&$ENDIF@}
      a:=a1;
   end;
   b1:=trimlz(b); if b1<>b then
   begin @|@/
      @{@&$IFDEF DEBUGNUM@}
      WriteLn(infofile,'ZEROS2:',b); @/
      @{@&$ENDIF@}
      b:=b1;
   end;
end;

@ Since arbitrary precision numbers (as Strings) are negative if they
begin with a leading ``-'' character, it is easy to obtain the
absolute value (just delete the minus sign).

@<Absolute value for an arbitrary-precision number@>=
function Abs(a :String ):String;
begin
   if length(a)>0 then if a[1]='-' then delete(a,1,1);
   Abs:=a;
end;
@ When checking $a\leq b$ for two non-negative integers, written as
Strings (without leading zeros) you can check if the length of $a$ is
less than the length of $b$.

If the length of $b$ is less than the length of $a$, then $b<a$.

When the length of the two Strings are equal, use lexicographic
ordering to determine which is less.

@<Test if one arbitrary-precision number is less than or equal to another@>=
function _leq(a,b :String): boolean;
var i,x,y,z:integer;
begin
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'_leq(',a,',',b,')');@/
   @{@&$ENDIF@}
   checkzero(a,b);
   if length(a)<length(b) then _leq:=true
   else if length(a)>length(b) then _leq:=false
   else begin
      for i:=1 to length(a) do
      begin
         val(a[i],x,z); val(b[i],y,z);
         if x>y then begin _leq:=false; exit; end;
         if x<y then begin _leq:=true; exit; end;
      end;
      _leq:=true;
   end;
end;

@ Now the \emph{general} case is when $a$ and $b$ are
arbitrary-precision \emph{integers}. If $a$ starts with a minus sign
and $b$ starts with a minus sign, then test if $a\geq b$.

When $a$ does not start with a minus sign, but $b$ \emph{does} start
with a minus sign, then we're done: $b<a$.

When neither $a$ nor $b$ starts with a minus sign, then we use
$\\{\_leq(a,b)}$ to determine the result.

@p
function leq(a,b :String):boolean;
begin
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'leq(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   if a=b then leq:=true else
      begin
	 if (a[1]='-') and (b[1]<>'-') then leq:=true;
	 if (a[1]='-') and (b[1]='-') then leq:=not _leq(abs(a),abs(b));
	 if (a[1]<>'-') and (b[1]='-') then leq:=false;
	 if (a[1]<>'-') and (b[1]<>'-') then leq:=_leq(a,b);
      end;
end;

@ Testing if $a\geq b$ is simply testing if $b\leq a$ after
normalizing the Strings.

@p
function geq(a,b :String):boolean;
begin
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'geq(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b); @/
   geq:=(not leq(a,b)) or (a=b);
end;

@ Similarly, we may check if $a<b$ by testing $a\neq b$ and $a\leq b$.

@p
function le(a,b :String):boolean;
begin
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'le(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   le:=(a<>b) and (leq(a,b));
end; @#

function gt(a,b :String):boolean;
begin
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'gt(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   gt:= not leq(a,b);
end;

@ \node{Arithmetic operations.}%
Now we get to some interesting bits.

We have \\{\_Add} for the addition of two non-negative integers. The
basic strategy is to go digit-by-digit, use the \PASCAL/-provided
integer arithmetic, manually ``carrying'' 1 if necessary.

The basic strategy is to initialize \\{a1} to be the larger of the two
numbers, and \\{b1} to the smaller of the two numbers. Then generically
we will have
$${{\displaystyle{{}\atop{+}}{a_{n}\atop{}}{\dots\atop{}}{a_{m+1}\atop{}}{a_{m}\atop b_{m}}{a_{m-1}\atop b_{m-1}} {\dots\atop\dots}{a_{1}\atop b_{1}}}\over{}}\eqno(\modno.1)$$
We will separate this out into two sums. First we compute
$${\displaystyle{{{}\atop{+}}{{}\atop{}}{a_{m}\atop b_{m}}{a_{m-1}\atop b_{m-1}} {\dots\atop\dots}{a_{1}\atop b_{1}}}\over{\hphantom{+}c_{m+1}\;r_{m}\;r_{m-1}\cdots\; r_{1}}}\eqno(\modno.2)$$
Then we will compute
$${\displaystyle{{}\atop{+}}{a_{n}\atop{}}{\dots\atop{}}{a_{m+1}\atop{c_{m+1}}}}\over{r_{n+1}\;r_{n}\;\dots\;r_{m+1}}\eqno(\modno.3)$$
The result is assembled from the digits $r_{n+1}r_{n}\cdots r_{1}$.

@<Arithmetic for arbitrary-precision integers@>=
function _Add(a,b :String):String;
var c,x,y,z,v : integer;i:integer; a1,b1,s,r : String;
begin
   a1:=a; b1:=b; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'_Add(',a1,',',b1,')'); @/
   @{@&$ENDIF@}
   checkzero(a1,b1);
   if length(a1)<length(b1) then begin s:=b1; b1:=a1; a1:=s; @+ end;
   r:='';
   c:=0;
   begin
      for i:=0 to length(b1)-1 do {step 1, Eq (\modno.2)}
      begin
	 val(a1[length(a1)-i],x,z);
	 val(b1[length(b1)-i],y,z);
	 if x+y+c>9 then begin v:=(x+y+c)-10; c:=1; end else begin v:=x+y+c; c:=0; end;
	 Str(v,s);
	 r:=s+r;
      end;
      for i:=length(b1) to length(a1)-1 do {step 2, Eq (\modno.3)}
      begin
	 val(a1[length(a1)-i],x,z);
	 if x+c>9 then begin v:=(x+c)-10; c:=1; end else begin v:=x+c; c:=0; end;
	 Str(v,s);
	 r:=s+r;
      end;
      if c=1 then r:='1'+r; @+ end; @/
   _Add:=trimlz(r);
end;

@ Subtraction is a bit trickier, because of the ``borrowing''
operation.

Also note that \\{\_Sub(a,b)} will start by computing
$a_{1}\gets\max(a,b)$ and $b_{1}\gets\min(a,b)$, then return $a_{1}-b_{1}$.

@p 
function _Sub(a,b :String):String;
var x,y,z,v : integer;i:integer; a1,b1,s,r : String; @/

   @<Borrow 1 for |Sub_|@>@;   

begin
   a1:=a; b1:=b; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'_Sub(',a1,',',b1,')'); @/
   @{@&$ENDIF@}
   checkzero(a1,b1);
   if not _leq(b1,a1) then @+ begin s:=b1; b1:=a1; a1:=s; @+ end;
   r:=''; @t\1@>
   begin @t\1@>@/
      for i:=0 to length(b1)-1 do
      begin
         val(a1[length(a1)-i],x,z);
         val(b1[length(b1)-i],y,z);
         if x<y then
         begin
            borrow(length(a1)-i);
            x:=x+10; @+
         end;
         v:=x-y;
         Str(v,s);
         r:=s+r;
      end;
      for i:=length(a1)-length(b1) downto 1 do
      begin
         r:=a1[i]+r; @+ @t\2@> @+
      end;
   end; @t\2@> @/
   _Sub:=trimlz(r); @t\2@>
end;

@ This is a private ``helper function'' for subtraction.

@<Borrow 1 for |Sub_|@>=
procedure Borrow(k :integer);
   var xx,zz : integer;sx:String;
   begin
      val(a1[k-1],xx,zz);
      if xx>=1 then begin xx:=xx-1; Str(xx,sx); a1[k-1]:=sx[1]; end
      else begin a1[k-1]:='9'; borrow(k-1); end;
   end;

@ \node{Multiplication.}%
Multiplication of $a$ by $b$ works digit-by-digit, in the sense that
for each digit $b_{i}$ of $b$, we need to multiply $a$ by $b_{i}$. The
function \\{\_Mul1} does this.

@<Arithmetic for arbitrary-precision integers@>=
function _Mul1(a:String ;y :integer ):String;
var c,x,z,v : integer;i:integer; s,r : String;
begin  @t\1@>@/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'_Mul1(',a,',',y,')'); @/
   @{@&$ENDIF@}
   r:='';
   c:=0;
   begin   @t\1@>@/
      for i:=0 to length(a)-1 do
      begin
        val(a[length(a)-i],x,z);
        if x*y+c>9 then begin v:=(x*y+c) mod 10; c:=(x*y+c) div 10; @+ end
        else begin v:=x*y+c; c:=0; @+ end;
        Str(v,s);
        r:=s+r;
      end;
      if c<>0 then
      begin
        Str(c,s);
        r:=s+r; @+
      end; @t\2@>
   end;  @/
   _mul1:=trimlz(r); @t\2@>
end;

@ Then multiplication proper amounts to decomposing $b$ into its
decimal expansion $\sum_{k}b_{k}10^{k}$ and computing $(a\times b_{k})10^{k}$.

@p
function _Mul(a,b :String):String;
var y,z : integer;i,j:integer; a1,b1,s,r : String;
begin @t\1@> @/
   a1:=a;b1:=b; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'_Mul(',a1,',',b1,')'); @/
   @{@&$ENDIF@}
   checkzero(a1,b1);
   if length(a1)<length(b1) then begin s:=b1; b1:=a1; a1:=s; @+ end;
   r:='0';
   for i:=0 to length(b1)-1 do
   begin
      val(b1[length(b1)-i],y,z);
      s:=_mul1(a1,y);
      for j:=0 to i-1 do s:=s+'0';
      r:=_Add(r,s);
   end;
   _Mul:=trimlz(r);  @t\2@>
end;

@ \node{Division.}%
The basic design is similar to multiplication. We will try to divide
$a$ by $b\times 10^{k}$ (which is zero whenever $b\times10^{k}>a$).

@p
function _Div1(a,b : String) : String;
var i : integer; r : String;
begin @|@/
   @{@&$IFDEF DEBUGNUM@} 
   WriteLn(infofile,'_Div1(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   if not _leq(b,a) then _div1:='0'
   else
      for i:=9 downto 1 do
      begin
         Str(i,r);
         if _leq(_mul(b,r),a) then
         begin
            _div1:=trimlz(r);
            exit; @+
         end;
      end;
end;

@ @p
function _Div(a,b : String):String;
var z,c,i:integer; s,r,rs : String;b_GPC:boolean; @/
@<Get the next digit for dividing arbitrary-precision integers@>@;
begin @t\1@> @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'_Div(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   if a=b then _div:='1'
   else if not _leq(b,a) then _div:='0' @t\2@>
   else
   begin
      s:='';r:='';z:=1;
      for i:=1 to length(b) do s:=s+a[i];
      if not _leq(b,s) then
      begin
         s:=s+a[length(b)+1];
         z:=length(b)+1; @+
      end
      else
      begin
         z:=length(b); @+
      end;
      repeat
         rs:=_div1(s,b);
         r:=r+rs;
         gets;
         b_GPC:= _leq(b,s);
      until not b_GPC;
      _div:=trimlz(r); @t\2@>
   end; @t\1@>
end;

@ @<Get the next digit for dividing arbitrary-precision integers@>=
procedure gets;
var j : integer;
begin
   c:=1;
   s:=_Sub(s,_mul(rs,b));
   if (s='0') and (trimlz(copy(a,z+c,length(a)))='0') then
   begin
      @{@&$IFDEF DEBUGNUM@}
      WriteLn(infofile,'Rewriting zeros:',copy(a,z+c,length(a))); @/
      @{@&$ENDIF@}
      r:=r+copy(a,z+c,length(a)); exit;
   end;
   if z+1<=length(a) then
   begin
      s:=s+a[z+1]; inc(c);
      if (not _leq(b,s)) then r:=r+'0';
   end;
   while (not _leq(b,s)) and (z+c<=length(a)) do
   begin
      s:=s+a[z+c];
      inc(c);
      if (not _leq(b,s)) then r:=r+'0';
   end;
   z:=z+c-1;
end; {gets}

@ \node{Modulo.} We can compute $a\mathbin{\&{mod}}b$ by observing if
$a < b$ then we should obtain $a$. Otherwise, we should compute
$r\K a\mathbin{\&{div}} b$, then $a - rb$ is $a\mathbin{\&{mod}}b$.

@<Arithmetic for arbitrary-precision integers@>=
function _Mod(a,b : String): String;
var r : String;
begin @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'_Mod(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   if le(a,b) then r:=a
   else r:=_Sub(a,_mul(b,_div(a,b)));
   _Mod:=trimlz(r); @/
   @{@&$IFDEF DEBUGNUM@}
    WriteLn(infofile,'End _Mod:',r); @/
   @{@&$ENDIF@}
end;

@ \node{Greatest common divisor.} \label{numbers:gcd}
We can compute $\gcd(a,b)$ first by setting $a_{1}\gets\abs{a}$ and
$b_{1}\gets\abs{b}$ (since $\gcd(a,b)=\gcd(\abs{a},\abs{b})$. Then we
handle the special cases: 
\enumerate
\item $a_{1}=1$ or $b_{1}=1$, then $\gcd(a_{1},b_{1})=1$
\item $a_{1}=0$ and $b_{1}\neq0$, then $\gcd(a_{1},b_{1})=b_{1}$
\item $a_{1}\neq0$ and $b_{1}=0$, then $\gcd(a_{1},b_{1})=a_{1}$
\item $a_{1}=b_{1}$, then $\gcd(a_{1},b_{1})=a_{1}$
\endenumerate

\medbreak
\noindent Otherwise, we end up in the default case, which is handled
by the \&{while} loop.

@p
function GCD(a,b:String):String;
label ex;var a1,b1,p,r:String;
begin
   a1:=a; b1:=b; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'GCD(',a1,',',b1,')'); @/
   @{@&$ENDIF@}
   checkzero(a1,b1);
   a1:=abs(a1); b1:=abs(b1);
   if (a1='1') or (b1='1') then begin r:='1'; goto ex; @+ end;
   if (a1='0') and (b1<>'0') then begin r:=b1; goto ex; @+ end;
   if (b1='0') and (a1<>'0') then begin r:=a1; goto ex; @+ end;
   if a1=b1 then begin GCD:=a1; r:=a1; goto ex; @+ end;
   while gt(b1,'0') do begin p:=b1; b1:= _mod(a1,b1); a1:=p @+ end;
   r:=a1;
   ex:
      GCD:=r; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'End GCD:',r); @/
   @{@&$ENDIF@}
end;

@ \node{Least common multiple.} We recall $\lcm(a,b)=\abs{ab}/\gcd(\abs{a},\abs{b})$.

@p
function LCM(a,b:String):String;
var a1,b1,r:String;
begin
   a1:=a; b1:=b; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'LCM(',a1,',',b1,')'); @/
   @{@&$ENDIF@}
   checkzero(a1,b1);
   a1:=abs(a1); b1:=abs(b1);
   r:=Diva(Mul(a1,b1),GCD(a1,b1));
   LCM:=r; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'End LCM:',r); @/
   @{@&$ENDIF@}
end;

@ \node{Addition.} This is a bit obfuscated with the reliance of \&{goto} \\{ex},
but the basic idea is (recalling that \\{\_Sub(a,b)} calculates
$\max(a,b)-\min(a,b)$ for $a\geq0$ and $b\geq0$):
\enumerate
\item If $a<0$ and $b<0$, then $a+b=-(\abs{a}+\abs{b})$
\item Else if $a\geq0$ and $b\geq0$, then $a+b$ is computed using \\{\_Add}
\item Else if $a<0$ and $b\geq0$, then we have two cases
\itemitem{(i)} If $\abs{a}\geq b$, compute $a+b=-(\abs{a}-b)$
\itemitem{(ii)} Otherwise, $a+b=b-\abs{a}$
\item Else if $a\geq0$ and $b<0$, then $a+b=a-\abs{b}$
\item Otherwise, when $a\geq0$ and $b\geq0$, $a+b$ is computed
using \\{\_Add}.
\endenumerate

@p
function Add(a,b :String ):String;
label ex; var r : String;
begin
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'Add(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   if (a[1]='-') and (b[1]='-') then begin r:='-'+_Add(abs(a),abs(b)); if r='-0' then r:='0'; goto ex; end;
   if (a[1]<>'-') and (b[1]<>'-') then begin r:=_Add(a,b); goto ex; @+ end;
   if (a[1]='-') and (b[1]<>'-') then
      if gt(abs(a),b) then begin r:='-'+_Sub(abs(a),b); if r='-0' then r:='0'; goto ex; end
      else begin r:=_Sub(abs(a),b); goto ex; @+ end;
   if (a[1]<>'-') and (b[1]='-') then
      if gt(abs(b),a) then begin r:='-'+_Sub(abs(b),a); if r='-0' then r:='0'; goto ex; end
      else begin r:=_Sub(abs(b),a); goto ex; @+ end;
   ex:
      Add:=r; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'End Add:',r); @/
   @{@&$ENDIF@}
end;

@ \node{Subtraction.} Now, given two arbitrary precision integers, we
can compute their difference. Again, \&{goto} \\{ex} obfuscates the flow
here, but the basic logic is:
\enumerate
\item If $a<0$ and $b\geq0$, then $a-b=-(\abs{a}+b)$
\item Else if $a\geq0$ and $b<0$, then $a-b=a+\abs{b}$
\item Else if $a<0$ and $b<0$, then we have two cases
\itemitem{(i)} If $\abs{a}>\abs{b}$, then $a-b=-(\abs{a}-\abs{b})$
\itemitem{(ii)} Otherwise $\abs{a}\leq\abs{b}$, so $a-b=\abs{a}-\abs{b}$
\item Else if $a\geq0$ and $b\geq0$, then we have two cases
\itemitem{(i)} If $b>a$, then $a-b=-(b-a)$
\itemitem{(ii)} Otherwise compute $a-b$ using \\{\_Sub(a,b)}
\endenumerate

\medbreak\noindent Testing if $x<0$ is done by checking $\sgn(x)=-1$, and
$x\geq0$ tests if $\sgn(x)\neq-1$.

@p
function Sub(a,b :String ):String;
label ex; var r : String;
begin
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'Sub(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   if (a[1]='-') and (b[1]<>'-') then
   begin
      r:='-'+_Add(abs(a),b);
      if r='-0' then r:='0';
      goto ex;
   end;
   if (a[1]<>'-') and (b[1]='-') then begin r:=_Add(a,abs(b)); goto ex; @+ end;
   if (a[1]='-') and (b[1]='-') then
      if gt(abs(a),abs(b)) then
      begin
         r:='-'+_Sub(abs(a),abs(b));
         if r='-0' then r:='0';
         goto ex;
      end
      else begin r:=_Sub(abs(a),abs(b)); goto ex; @+ end;
   if (a[1]<>'-') and (b[1]<>'-') then
      if gt(b,a) then
      begin
         r:='-'+_Sub(b,a);
         if r='-0' then r:='0';
         goto ex;
      end
      else begin r:=_Sub(a,b); goto ex; @+ end;
   ex:
      Sub:=r; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'End Sub:',r); @/
   @{@&$ENDIF@}
end;

@ \node{Multiplication of arbitrary-precision integers.}
We calculate the product of $a$ with $b$ by handling the case where
$\sgn(a)\neq\sgn(b)$ as $ab=-\abs{a}\cdot\abs{b}$. Otherwise we can
just rely on the \\{\_Mul(a,b)} to do our work.

@p
function Mul(a,b :String ):String;
label ex; var r : String;
begin
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'Mul(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   if ((a[1]='-') and (b[1]<>'-')) or ((a[1]<>'-') and (b[1]='-')) then
   begin
      r:='-'+_Mul(abs(a),abs(b));
      if r='-0' then r:='0';
   end
   else r:=_Mul(abs(a),abs(b));
   ex:
      Mul:=r; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'End Mul:',r); @/
   @{@&$ENDIF@}
end;

@ \node{DivA.} This is the division for arbitrary-precision
integers. Like multiplication, we handle the case $\sgn(a)\neq\sgn(b)$
by computing $a/b = -\abs{a}/\abs{b}$.

@p
function DivA(a,b :String ):String;
label ex; var r : String;
begin
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'DivA(',a,',',b,')'); @/
   @{@&$ENDIF@}
   checkzero(a,b);
   if ((a[1]='-') and (b[1]<>'-')) or ((a[1]<>'-') and (b[1]='-')) then
   begin
      r:='-'+_Div(abs(a),abs(b));
      if r='-0' then r:='0';
   end
   else r:=_Div(abs(a),abs(b));
   ex:
      DivA:=r; @/
   @{@&$IFDEF DEBUGNUM@}
   WriteLn(infofile,'End DivA:',r); @/
   @{@&$ENDIF@}
end;

@ \node{Testing for primality.}
We can test if a given arbitrary-precision integer is prime or not.
Specifically, we restrict attention to \emph{positive} integers.

The \&{while} loop calculates \\{Mul(i,i)} because Fermat observed we only
need to check numbers \emph{up to} $\lceil\sqrt{x}\rceil$ as prime
factors of $x$. But this calulation is a bit costly. This could be
approximated by taking the length of the underlying String $n=\abs{s}$
and looking at the leading $\lceil n/2\rceil$ digits $s_{\rm lead}$.
It's not hard to see that the number $x_{\rm lead}$ described
by $s_{\rm lead}$ satisfies $x_{\rm lead}^{2}\geq x$.

@p
function IsPrime(a: String): boolean;
var i: String;
r: boolean;
begin
   if leq('2',a) then 
   begin
      r:=true;
      i:='2';
      while leq(Mul(i,i),a) do
      begin
         if GCD(a,i)=i then
         begin
            r:=false;
            break; @+
         end;
         i:=Add(i,'1');
      end;
   end
   else r:=false;
   IsPrime:=r;
end;

@ \node{Divides relation.}
We can check if ``$x$ divides $y$'' by testing if $\gcd(x,y)=\abs{x}$.

@p
function Divides(a,b: String): boolean;
var r: boolean;
begin
    r:=GCD(a,b)=abs(a);
    Divides:=r;
end;

@ \node{Rational arithmetic.} Now we begin the rational arithmetic
``in earnest''. The first thing to do is provide a way to compute the
reduced form for a fraction, i.e.,
$$\frac{n}{d} = \frac{n/\gcd(n,d)}{d/\gcd(n,d)}$$

@<Arbitrary-precision rational arithmetic@>=
procedure RationalReduce(var r: Rational);
var lGcd:String;
begin
   lGcd := gcd(r.Num,r.Den);
   r.Num := diva(r.Num,lGcd);
   r.Den := diva(r.Den,lGcd);
end;

@ \node{Rational addition.}
We recall
$$ \frac{a}{b} + \frac{c}{d} = \frac{ad+bc}{bd} $$

@p
function RationalAdd(const r1,r2: Rational): Rational;
var lRes: Rational;
begin
   lRes.Num := Add(Mul(r1.Num,r2.Den),Mul(r1.Den,r2.Num));
   lRes.Den := Mul(r1.Den,r2.Den);
   RationalReduce(lRes);
   RationalAdd:=lRes;
end;

@ \node{Rational subtraction.} Similar to addition, but the numerator
is $ad-bc$.

@p
function RationalSub(const r1,r2: Rational): Rational;
var lRes: Rational;
begin
   lRes.Num := Sub(Mul(r1.Num,r2.Den),Mul(r1.Den,r2.Num));
   lRes.Den := Mul(r1.Den,r2.Den);
   RationalReduce(lRes);
   RationalSub:= lRes;
end;

@ Negating a rational number amounts to multiplying the numerator by
$-1$.

@p
function RationalNeg(const r1: Rational): Rational;
var lRes: Rational;
begin
   lRes.Num:= Mul('-1',r1.Num);
   lRes.Den:= r1.Den;
   RationalNeg := lRes;
end;

@ \node{Multiplying rational numbers.}
This uses the school-book formula
$$\frac{a}{b}\times\frac{c}{d}=\frac{ac}{bd}$$

@p
function RationalMult(const r1,r2: Rational): Rational;
var lRes: Rational;
begin
   lRes.Num := Mul(r1.Num,r2.Num);
   lRes.Den := Mul(r1.Den,r2.Den);
   RationalReduce(lRes);
   RationalMult:= lRes;
end;

@ \node{Inverting a rational number.}
This is easy, provided the numerator is nonzero. The convention is to
make the numerator carry the sign of the number (so $n/d$ has
$n\in\ZZ$ while $d\in\NN$).

When the rational number \emph{is} zero, we simply take $0^{-1}=0$ (as
is conventional among proof assistants).

@p
function RationalInv(const r: Rational): Rational;
var lRes: Rational;
begin
   if r.Num <> '0' then
   begin
      if le(r.Num,'0') then
         lRes.Num := Mul('-1',r.Den)
      else lRes.Num := r.Den;
      lRes.Den := Abs(r.Num);
   end
   else lRes := RZero;
   RationalInv:= lRes;
end;

@ \node{Dividing rational numbers.}
We see that $r_{1}/r_{2}=r_{1}\times(r_{2}^{-1})$. That's the trick.

@p
function RationalDiv(const r1,r2: Rational): Rational;
begin
   RationalDiv := RationalMult(r1,RationalInv(r2));
end;

@ \node{Equality of rational numbers.}
Two rational numbers $n_{1}/d_{1}$ and $n_{2}/d_{2}$ are equal if
$n_{1}=n_{2}$ and $d_{1}=d_{2}$. This assumes that both rational
numbers are in reduced form.

@p
function RationalEq(const r1,r2: Rational): boolean;
begin
   RationalEq := (r1.Num = r2.Num) and (r1.Den = r2.Den);
end;

@ \node{Testing inequality of rational numbers.}\label{numbers:rationalgt}
We have $n_{1}/d_{1} < n_{2}/d_{2}$ if $n_{1}d_{2}<n_{2}d_{1}$.

Similarly, we have $n_{1}/d_{1}\geq n_{2}/d_{1}$ is just the negation
of $n_{1}/d_{1} < n_{2}/d_{2}$. \textbf{But:} this is misleadingly
called \\{RationalGT} instead of \\{RationalGEQ}.

@p
function RationalLE(const r1,r2: Rational): boolean;
begin
   RationalLE := leq(Mul(r1.Num,r2.Den),Mul(r1.Den,r2.Num));
end;

function RationalGT(const r1,r2: Rational): boolean;
begin
   RationalGT := not RationalLE(r1,r2);
end;

@ \node{Rational complex arbitrary-precision arithmetic.}
We now begin with $\QQ+{\rm i}\QQ\subset\CC$, the subset of
complex-numbers where the real and imaginary parts are rational
numbers.

We want to know when these numbers describe integers (i.e., the
imaginary part is zero and the denominator of the real part is 1) and
natural numbers (i.e., when furthermore the numerator of the real part
is non-negative).

@<Complex-rational arbitrary-precision arithmetic@>=
function IsintegerNumber(const z: RComplex): boolean;
begin
   IsintegerNumber := (z.Im.Num = '0') and (z.Re.Den = '1'); @+
end;@#

function IsNaturalNumber(const z: RComplex): boolean;
begin
   IsNaturalNumber := (z.Im.Num = '0') and (z.Re.Den = '1') and (geq(z.Re.Num,'0')); @+
end;@#

function IsPrimeNumber(const z: RComplex): boolean;
begin
    if IsNaturalNumber(z) and IsPrime(z.Re.Num) then IsPrimeNumber := true
    else IsPrimeNumber := false;
end;

@ \node{Equality of complex numbers.}
This amounts to checking if the real and imaginary parts are equal to
each other as rational numbers.

@p
function AreEqComplex(const z1,z2: RComplex): boolean;
begin
   AreEqComplex := RationalEq(z1.Re,z2.Re) and RationalEq(z1.Im,z2.Im); @+
end;@#

function IsEqWithInt(const z: RComplex; @t\hskip10.3333pc@> n: longint): boolean;
var s : String;
begin
   Str(n,s);
   IsEqWithInt := (z.Im.Num = '0') and (z.Re.Num = s) and (z.Re.Den = '1'); @+
end;

@ \node{``Inequalities''.}\label{numbers:isrationalle}
We ``induce'' the binary relations $<$ and $\geq$
on the subset $\{q+{\rm i}0\mid q\in\QQ\}\subset\CC$.
Again, what we said earlier about \\{RationalGT} being badly named holds
for \\{IsRationalGT} being badly named as well.

@p
function IsRationalLE(const z1,z2 : RComplex): boolean;
begin
   IsRationalLE := (z1.Im.Num = '0') and (z2.Im.Num = '0') and RationalLE(z1.Re,z2.Re); @+
end; @#

function IsRationalGT(const z1,z2 : RComplex): boolean;
begin
   IsRationalGT := (z1.Im.Num = '0') and (z2.Im.Num = '0') and RationalGT(z1.Re,z2.Re); @+
end;

@ \node{Converting integers to complex numbers.} We have a function to
convert an integer $x\in\ZZ$ to be the complex number $(x/1) + {\rm i}(0/1)\in\CC$.

@p
function IntToComplex(x: integer): RComplex;
var lRes:RComplex;
begin
   lRes:=COne;
   lRes.Re.Num:=IntToStr(x);
   IntToComplex:= lRes;
end;

@ \node{Adding complex numbers.}
We compute the sum of $(x_{1}+{\rm i}y_{1})$
and $x_{2} + {\rm i}y_{2}$ to be $(x_{1}+x_{2})+{\rm i}(y_{1}+y_{2})$.

@p
function ComplexAdd(const z1,z2 : RComplex): RComplex;
var lRes:RComplex;
begin
   lRes.Re := RationalAdd(z1.Re,z2.Re);
   lRes.Im := RationalAdd(z1.Im,z2.Im); @/
   @{@&$IFDEF CH_REPORT@}
   CHReport.Out_NumReq3(rqRealAdd, z1, z2, lRes); @/
   @{@&$ENDIF@} 
   ComplexAdd:= lRes;
end;

@ \node{Subtracting complex numbers.}
We find the difference of complex numbers componentwise.

@p
function ComplexSub(const z1,z2: RComplex): RComplex;
var lRes:RComplex;
begin
   lRes.Re := RationalSub(z1.Re,z2.Re);
   lRes.Im := RationalSub(z1.Im,z2.Im); @/
   @{@&$IFDEF CH_REPORT@}
   CHReport.Out_NumReq3(rqRealDiff, z1, z2, lRes); @/
   @{@&$ENDIF@}  
   ComplexSub:= lRes;
end;

@ \node{Negating complex numbers.} We negate a complex number $-z$ by
negating its real and imaginary parts.

@p
function ComplexNeg(const z: RComplex): RComplex;
var lRes:RComplex;
begin
   lRes.Re := RationalNeg(z.Re);
   lRes.Im := RationalNeg(z.Im); @/
   @{@&$IFDEF CH_REPORT@}
   CHReport.Out_NumReq2(rqRealNeg, z, lRes); @/
   @{@&$ENDIF@}  
   ComplexNeg:=lRes;
end;

@ \node{Multiplying complex numbers.}
We use the usual formula
$$(x_{1}+{\rm i}y_{1})(x_{2}+{\rm i}y_{2}) = (x_{1}x_{2}-y_{1}y_{2})+{\rm i}(x_{1}y_{2}+y_{1}x_{2}).$$

@p
function ComplexMult(const z1,z2 : RComplex): RComplex;
var lRes:RComplex;
begin
   if IsEqWithInt(z1, -1) then ComplexMult:= ComplexNeg(z2)
   else if IsEqWithInt(z2, -1) then ComplexMult:= ComplexNeg(z1)
   else
   begin
      lRes.Re := RationalSub(RationalMult(z1.Re,z2.Re),RationalMult(z1.Im,z2.Im));
      lRes.Im := RationalAdd(RationalMult(z1.Re,z2.Im),RationalMult(z1.Im,z2.Re));
      ComplexMult:=lRes; @/
      @{@&$IFDEF CH_REPORT@}
      CHReport.Out_NumReq3(rqRealMult, z1, z2, lRes); @/
      @{@&$ENDIF@}  
   end;
end;

@ \node{Dividing complex numbers.} We recall
$$\frac{x_{1} + {\rm i}y_{1}}{x_{2} + {\rm i}y_{2}} = \frac{(x_{1} + {\rm i}y_{1})(x_{2} - {\rm i}y_{2})}{x_{2}^{2} + y_{2}^{2}}$$
This is the case for nonzero $z_{2}\neq0$. When we try to divide
$z_{1}/0$, we return $0$.

@p
function ComplexDiv(const z1,z2: RComplex) : RComplex;
var lDenom : Rational;
   lRes:RComplex;
begin
   lRes:=CZero;
   with z2 do
      lDenom := RationalAdd(RationalMult(Re,Re),RationalMult(Im,Im));
   if lDenom.Num <> '0' then
   begin @|@/
      lRes.Re := RationalDiv(RationalAdd(RationalMult(z1.Re,z2.Re),
                                         RationalMult(z1.Im,z2.Im)),
                          @t\hskip7.5pc@>   lDenom); @/
      lRes.Im := RationalDiv(RationalSub(RationalMult(z1.Im,z2.Re),
                                         RationalMult(z1.Re,z2.Im)),
                          @t\hskip7.5pc@>   lDenom); @/
      @{@&$IFDEF CH_REPORT@}
      CHReport.Out_NumReq3(rqRealDiv, z1, z2, lRes); @/
      @{@&$ENDIF@}     
   end;
   ComplexDiv:=lRes;
end;

@ \node{Inverting complex numbers.}
We can now calculate $z^{-1}$ as just $1/z$.

@p
function ComplexInv(const z: RComplex): RComplex;
begin
   ComplexInv:=ComplexDiv(COne,z); @+
end;

@ \node{Norm of complex numbers.} The ``norm'' or \emph{modulus} for a
complex number is just the sum of the square of its components (well,
the squareroot of this sum).

@p
function ComplexNorm(const z: RComplex): Rational;
begin
   ComplexNorm:=RationalAdd(RationalMult(Z.Re,Z.Re),RationalMult(Z.Im,Z.Im)); @+
end;

@ \node{Comparison functions.}
The remainder of \texttt{numbers.pas} defines functions which compares
numbers. These must return a value in the set $\{-1,0,+1\}$ as
a \PASCAL/ \\{integer}.

@p
function CompareInt(X1, X2: Longint): integer;
begin
   if X1 = X2 then CompareInt := 0
   else if X1 > X2 then CompareInt := 1
   else CompareInt := -1;
end; @#

function CompareIntStr(X1, X2: String): integer;
begin
   if X1 = X2 then CompareIntStr := 0
   else if gt(X1,X2) then CompareIntStr := 1
   else CompareIntStr := -1;
end;

@ There is also a function to ``compare'' complex numbers. This treats
a complex number
$$ z = \frac{n_{1}}{d_{1}} + {\rm i}\frac{n_{2}}{d_{2}}$$
as a tuple $(n_{1},d_{1},n_{2},d_{2})$ then uses lexicographic
ordering based on the components.

@p
function CompareComplex(const z1,z2: RComplex): integer;
var lInt: integer;
begin
   lInt:=CompareIntStr(z1.Re.Num,z2.Re.Num);
   if lInt <> 0 then begin CompareComplex:=lInt; exit @+ end;
   lInt:=CompareIntStr(z1.Re.Den,z2.Re.Den);
   if lInt <> 0 then begin CompareComplex:=lInt; exit @+ end;
   lInt:=CompareIntStr(z1.Im.Num,z2.Im.Num);
   if lInt <> 0 then begin CompareComplex:=lInt; exit @+ end;
   CompareComplex:=CompareIntStr(z1.Im.Den,z2.Im.Den);
end;
