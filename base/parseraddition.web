
@* [F] Detour: Parser additions.
This chapter is a ``detour'' because we are ``going out of [compiler] order'' to
discuss \texttt{parseradditions.pas}. Why? Well, because the file provides
subclasses to those introduced in the abstract syntax unit, and are
necessary for understanding the \texttt{parser.pas} unit.

One of the difficulties with this file is that there are 37 global
variables declared here, and 46 module-wide variables, declared
here. It's hard to juggle that knowledge! These ``global'' variables
really describe the state of the Parser, and do not seem to be used
anywhere else.

For what it's worth, this appears to be conventional among compilers
in the 1990s to use global variables to control the state of the
compiler. For example David Hanson and Christopher Fraser's
\emph{A Retargetable C Compiler: Design and Implementation}
(Addison-Wesley, 1995) has quite a few global variables. If we were
starting from scratch, it would be more idiomatic to put the state in
a \\{Parser} class instance, and we could then use this to unit test
the parser. This would become conventional more than a decade after
Hanson and Fraser's book was published.

\Ithink{It would probably be wise to refactor the design to isolate
these variables inside a \texttt{Parser} class, so they are not
randomly distributed throughout this part of the program.}

C{\sc ONVENTIONS}:
The classes have methods prefixed by \\{Start}, \\{Process},
and \\{Finish}.
\bul The \\{Start} methods reset the state variables needed
to parse the syntactic entity.

\bul The \\{Process} methods usually update the state variables,
either allocating new objects or transferring the current contents of a
state variable in a different state variable.

\bul The \\{Finish} methods construct
a \WSM/ abstract syntax tree for the parsed entity.

@<parseraddition.pas@>=
@<GNU License@>
unit parseraddition; @#

interface @|@#


uses syntax, errhan, mobjects, mscanner, abstract_syntax, wsmarticle, xml_inout; @#

procedure InitWsMizarArticle; @t\2@> @#

type @|@/
@<Extended block class declaration@>@;
@<Extended item class declaration@>@;
@<Extended subexpression class declaration@>@;
@<Extended expression class declaration@>@; @#

   function @? GetIdentifier:integer; @t\2@>
   function @? CreateArgs(aBase:integer): PList; @t\2@> @#

var
@<Global variables introduced in \texttt{parseraddition.pas}@>@; @#

implementation @|@#
uses mizenv, mconsole, parser, _formats, pragmas
mdebug ,info @+ end_mdebug; @#

const
   MaxSubTermNbr   =   64;

var
   @<Local variables for parser additions@>@; @#

   @<Implementation of parser additions@> @t\2@>@;
end.

@ @<Implementation of parser additions@>=
@<Get the identifier number for current word@>@;

@<Initialize WS Mizar article@>;

@<Extended block implementation@>@;

@<Extended item implementation@>@;

@<Extended subexpression implementation@>@;

@<Extended expression implementation@>@;

@ When the current token is an identifier, we should obtain its
number. If the current token is not an identifier, we should return 0.
Since the ID numbers for variables (and types and\dots) are nonzero,
returning 0 indicates the current token is not an identifier.

\label{GetIdentifier}

@<Get the identifier number for current word@>=
function GetIdentifier:integer;
begin
   result:=0;
   if CurWord.Kind = Identifier then result:=CurWord.Nr
end;

@ Initializing a weakly-strict Mizar article requires setting the
values for some of the global variables. Importantly, this will
initialize the \\{gBlockPtr} in the Parser to be an \\{extBlockObj}
instance. Note that this will create ``the'' |blMain| block object.

The \\{gLastWSItem} state variable tracks the last \emph{statement item}.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gWSTextProper: wsTextProperPtr; { article's text body AST }
  @! gLastWSBlock: WSBlockPtr; { block statement AST }
  @! gLastWSItem: WSItemPtr; { statement AST }

@ @<Initialize WS Mizar article@>=
procedure InitWsMizarArticle;
begin {inintialize global variables which were declared
   in \texttt{parseraddition}}
   gWSTextProper:=new(wsTextProperPtr,Init(ArticleID,ArticleExt,CurPos));
   gLastWSBlock:=gWSTextProper;
   gLastWSItem:=nil; @/
   gBlockPtr:=new(extBlockPtr, Init(blMain)); {initialize other global variables}
end;

@* [S] Extended block class.
We extend the \\{Block} class (\section\xref{BlockObj:syntax.pas})
introduced in the \texttt{syntax.pas} unit. Also recall
the \\{wsBlock} class (\section\xref{wsTextProper:ast}) and
the \\{wsItem} class (\section\xref{TextItem:ast}).
\medbreak
\figure
\centerline{\graphics{img/classdiagram-4}}
\caption{Class hierarchy for \\{extBlockObj}, methods omitted.}
\endfigure
\medbreak\noindent%

@ @<Extended block class declaration@>=
   extBlockPtr = ^extBlockObj; @/
   extBlockObj = object(BlockObj) @t\1@> @/
      nLastWSItem: WSItemPtr;
      nLastWSBlock: WSBlockPtr; @#
      
      nLinked: Boolean; {is block prefixed by ``\texttt{then}''?}
      nLinkAllowed: Boolean; {isn't this a duplicate of next field?}
      nLinkProhibited: Boolean; {can statement kind be prefixed by ``\texttt{then}''?}
      nLinkPos:Position; @#
      
      nInDiffuse:boolean;
      nLastSentence: FormulaPtr; @#
      
      nHasAssumptions: Boolean; @#
      
      constructor Init(fBlockKind:BlockKind); @t\2@>
      procedure @? Pop; virtual; @t\2@>
      procedure @? StartProperText; virtual; @t\2@>
      procedure @? ProcessRedefine; virtual; @t\2@>
      procedure @? ProcessLink; virtual; @t\2@>
      procedure @? ProcessBegin; virtual; @t\2@>
      procedure @? ProcessPragma; virtual; @t\2@>
      procedure @? StartSchemeDemonstration; virtual; @t\2@>
      procedure @? FinishSchemeDemonstration; virtual; @t\2@>
      procedure @? CreateItem(fItemKind:ItemKind); virtual; @t\2@>
      procedure @? CreateBlock(fBlockKind:BlockKind); virtual; @t\2\2\2@>
   end;

@ \node{Constructor.}
The constructor for an extended block object invokes the parent
class's constructor (\section\xref{BlockObj.Init}), initializes the
instance variables, then its behaviour depends on whether we are
constructing a ``main'' block or not.

@<Extended block implementation@>=
constructor @? extBlockObj.Init(fBlockKind:BlockKind);
begin
   inherited Init(fBlockKind); @/
   @<Initialize default values for \\{extBlock} instance@>;
   if nBlockKind = blMain then
   @<Initialize \texttt{main} \\{extBlock} instance@>
   else
   @<Initialize ``proper text'' \\{extBlock} instance@>;
end;

@ We have the default values suppose links are prohibited for the
block, and there are no assumptions for the block. The last |wsItem|
and |wsBlock| pointers are set to the global |gLastWSItem| and
|gLastWSBlock| variables, respectively.

@<Initialize default values for \\{extBlock} instance@>=
   nLinked:=false;
   nLinkPos:=CurPos;
   nLinkAllowed:=false;
   nLinkProhibited:=true;
   nHasAssumptions:=false;
   gRedefinitions:=false; @#

   nLastWSItem:=gLastWSItem;
   nLastWSBlock:=gLastWSBlock;

@ The ``main'' block of text needs to load the formats file, and
populate the \\{gFormatsColl} (\section\xref{gFormatsColl}) and
the \\{gFormatsBase} (\emph{ibid}.) global
variables. The \texttt{parseraddition.pas} unit's \\{gProofCnt} global
variable is initialized to zero here.

@<Initialize \texttt{main} \\{extBlock} instance@>=
   begin
      nInDiffuse:=true;
      gProofCnt:=0; @/
      FileExam(EnvFileName+'.frm');
      gFormatsColl.LoadFormats(EnvFileName+'.frm');
      gFormatsBase:=gFormatsColl.Count;
      setlength(Term,MaxSubTermNbr);
   end

@ @<Local variables for parser additions@>=
  @! Term: array of TermPtr; {(\section\xref{uml-class-diagram-for-term-ast})}

@ @<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gProofCnt: integer;

@ The ``proper text'' branch updates the \\{gLastWSBlock} global
variable. For most of the kinds of blocks, we will have to
toggle \\{nInDiffuse} to be true or false. For proof blocks, we will
need to increment the ``depth'' counter tracking the proof block
``nestedness''.

Only the ``\texttt{case}'' and ``\texttt{suppose}'' blocks, when
determining if they are in ``diffuse mode'' or not, need to
confer with the previous block. (Recall (\section\xref{StackedObj}),
\\{StackedObj} classes has a \\{Previous} pointer.)

@<Initialize ``proper text'' \\{extBlock} instance@>=
   begin
      gLastWSBlock:=gWsTextProper^.NewBlock(nBlockKind,CurPos);
      mizassert(2341,gLastWSItem<>nil);
      if gLastWSItem^.nItemKind in [itDefinition,itRegularStatement,itSchemeBlock,
                                    itTheorem,itConclusion,itCaseBlock,itCorrCond,
                                    itCorrectness,itProperty,itPropertyRegistration] then
         wsItemPtr(gLastWSItem).nBlock:=gLastWSBlock;
      case nBlockKind of
         blDefinition: nInDiffuse:=false;
         blNotation: nInDiffuse:=false;
         blDiffuse: nInDiffuse:=true;
         blHereby: nInDiffuse:=true;
         blProof:
            begin
               nLastSentence:=gLastFormula;
               inc(gProofCnt); @+
            end;
         blCase: nInDiffuse:=extBlockPtr(Previous)^.nInDiffuse;
         blSuppose: nInDiffuse:=extBlockPtr(Previous)^.nInDiffuse;
         blRegistration: nInDiffuse:=false;
         blPublicScheme: nInDiffuse:=false;
      endcases;
   end

@ \node{Popping a block.} When we ``pop'' a proof block, we need to
track the formula that was just proven and store it in the global
variable \\{gLastFormula}.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gLastFormula: FormulaPtr;
   
@ This actually implements the \\{Pop} method for blocks. When a block
``closes'' (i.e., the corresponding ``\texttt{end}'' statement has
been encountered), we restore the global
state's \\{gLastWSItem} and \\{gLastWSBlock} pointers. When a proof
block closes, we also restore the \\{gLastFormula} state.

Also note: the parent class's method (\section\xref{BlockObj.Pop})
does nothing. This will be invoked in the \\{KillBlock}
(\section\xref{KillBlock}). 

@<Extended block implementation@>=
procedure @? extBlockObj.Pop;
begin
   gLastWSBlock^.nBlockEndPos:=CurPos;
   case nBlockKind of
      blProof:
         begin
            gLastFormula:=nLastSentence;
            dec(gProofCnt); @+
         end;
   endcases; @/
   gLastWSItem:=nLastWSItem;
   gLastWSBlock:=nLastWSBlock; {restore the ``last'' pointers}
   inherited Pop;
end;

@ \node{Process ``begin''.}
Mizar uses ``\texttt{begin}'' to start a new ``section'' at the
top-level of an article. Recall the grammar for this bit of Mizar:
$$\vbox{\halign{$#$\hfil\cr
\<Text-Proper> ::= \<Section>\ \LB\ \<Section>\ \RB\ .\cr
\<Section> ::= \hbox{\texttt{"begin"} } \LB\ \<Text-Item>\ \RB\ .\cr
}}$$
There are zero or more Text-Items in a section.

We should note that the main text is not organized as a linked list of
``main'' blocks. Instead, we have a single ``main'' block, and we just
push an \\{itSection} item to its contents.

@! @:extBlockObj.ProcessBegin}{\\{extBlockObj.ProcessBegin}@>

\label{extBlockObj.ProcessBegin}
@<Extended block implementation@>=
procedure @? extBlockObj.@!ProcessBegin;
begin
   nLinkAllowed:=false;
   nLinkProhibited:=true;
   gLastWSItem:=gWsTextProper^.NewItem(itSection,CurPos);
   nLastWSItem:=gLastWSItem;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
end;

@ This will add a pragma item to the current block.
The Parser's \\{ProcessPragmas} (\section\xref{ProcessPragmas:parser})
invokes this method.

\label{extBlockObj.ProcessPragma}

@<Extended block implementation@>=
procedure @? extBlockObj.@!ProcessPragma;
begin
   nLinkAllowed:=false;
   nLinkProhibited:=true; @/
   {Create a new item}
   gLastWSItem:=gWsTextProper^.NewItem(itPragma,CurPos);
   gLastWSItem^.nContent:=new(PragmaPtr,Init(CurWord.Spelling)); @/
   {Insert the pragma, update last item in block}
   nLastWSItem:=gLastWSItem;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
end;

@ Starting the proper text will just update the \\{nBlockPos} field to
whatever the current position is.
\label{extBlockObj.StartProperText}

@<Extended block implementation@>=
procedure @? extBlockObj.StartProperText;
begin
   gWSTextProper^.nBlockPos:=CurPos; @+
end;

@ Processing redefinitions sets the global variable \\{gRedefinitions}
to the result of comparing the current word to the
``\texttt{redefine}'' keyword.

@<Extended block implementation@>=
procedure @? extBlockObj.@!ProcessRedefine;
begin
   gRedefinitions:=CurWord.Kind = sy_Redefine; @+
end;

@ When a block statement is linked, but it should not, then we raise
a \texttt{164} error. Otherwise, be sure to mark the block as linked
(i.e., toggle \\{nLinked} to be true) and assign the \\{nLinkPos} to
be the current position.

@<Extended block implementation@>=
procedure @? extBlockObj.@!ProcessLink;
begin
   if CurWord.Kind in [sy_Then,sy_Hence] then
   begin
      if nLinkProhibited then ErrImm(164);
      nLinked:=true;
      nLinkPos:=CurPos;
   end;
end;

@ \node{Proof of a scheme.} We should increment the proof depth global
variable. 

Recall that \\{ProofPragma} means ``check the proof is valid?'' In
other words, when \\{ProofPragma} is false, we are skipping the
proofs.

\label{thesis-formula:macro-def}

@d thesis_formula == new(ThesisFormulaPtr,Init(CurPos))
@d thesis_prop == new(PropositionPtr,
                      Init(new(LabelPtr,Init(0,CurPos)),
                           thesis_formula,CurPos))
@d skipped_proof_justification ==  new(JustificationPtr,Init(infSkippedProof,CurPos))

@<Extended block implementation@>=
procedure @? extBlockObj.@!StartSchemeDemonstration;
begin
   inc(gProofCnt);
   if not ProofPragma then
   @<Mark schema proof as ``skipped''@>;
end;

@ When we skip the proof (due to pragmas being set), we just add the
scheme as a compact statement whose justification is the ``skipped
proof justification''.

First, we create a new text item for the proper text global variable. Then
we set its content to the compact statement with the ``skipped''
justification. Finally we add this item to the ``last''
(latest) \\{wsBlock} global variable.

@<Mark schema proof as ``skipped''@>=
   begin
      gLastWSItem:=gWsTextProper^.NewItem(itConclusion,CurPos);
      gLastWSItem^.nContent:=
         new(CompactStatementPtr,
             Init(thesis_prop,
                  skipped_proof_justification));@/
      gLastWSBlock^.nItems.Insert(gLastWSItem);
   end

@ Finishing the proof for a scheme should decrement the global ``proof depth''
counter.

@<Extended block implementation@>=
procedure @? extBlockObj.@!FinishSchemeDemonstration;
begin
   dec(gProofCnt); @+
end;

@ The factory method for \\{extBlock} creating an item will update the
global \\{gItemPtr} variable (\section\xref{gSubexpPtr}).

@<Extended block implementation@>=
procedure @? extBlockObj.@!CreateItem(fItemKind:ItemKind);
begin
   gItemPtr:=new(extItemPtr, Init(fItemKind)); @+
end;

@ The factory method for \\{extBlock} creating a new block will update
the \\{gBlockPtr} global variable (\section\xref{gSubexpPtr}).

@<Extended block implementation@>=
procedure @? extBlockObj.@!CreateBlock(fBlockKind:BlockKind);
begin
   gBlockPtr:=new(extBlockPtr,Init(fBlockKind)) @+
end;

@* [S] Extended item class.
The class diagram for extended items looks like:
\medbreak
\figure
\centerline{\graphics{img/classdiagram-5}}
\caption{Class hierarchy for \\{extItemObj}. The base \\{MObject} class omitted from the hierarchy.}
\endfigure
\medbreak\noindent%
Recall (\section\xref{RegularStatementKind}) the regular statement
kind is one of three possibilities: diffuse statement, compact
statement, iterative equality.

The ``Finish'' methods updates the contents of the \\{extItem} class
with a \WSM/ abstract syntax tree for the statement.

Since this is a ``stub'', I will just leave the placeholder chunk for
the methods overriden by the extended Item class here (remove later).

@<Methods overriden by extended Item class@>=

@ @<Extended item class declaration@>=
  @! extItemPtr = ^extItemObj; @/
  @! extItemObj = object(ItemObj) @t\1@> @/

     @! nItemPos:Position;
     @! nLastWSItem: WSItemPtr; @#

     @! nLabelIdNr: integer;
     @! nLabelIdPos:Position;
     @! nLabel: LabelPtr; @#

     @! nPropPos: Position; @#

     @! nInference: JustificationPtr; @/
     @! nLinkable: boolean; @#

     @! nRegularStatementKind: RegularStatementKind; @#

     @! nItAllowed: boolean; @#

      constructor @? Init(fKind:ItemKind); @t\2@>
      procedure @? Pop; virtual; @t\2@> @#

@t\4@>  @<Methods overriden by extended Item class@> @t\2\2@> @;

   end;

@* [s] Constructor.
There are a number of comments in Polish which I haphazardly
translated into English (``Przygotowanie definiensow:'' translates as
``Preparation of definiens:''; ``Ew.\ zakaz przy obiektach ekspandowanych''
translates as ``Possible ban on expanded facilities'')

@<Extended item implementation@>=
constructor @? extItemObj.Init(fKind:ItemKind);
begin
   inherited Init(fKind); @/
   @<Initialize the fields for newly allocated \\{extItem} object@>@;
   mizassert(2343,gLastWSBlock<>nil);
   if not (nItemKind in [itReservation,itConstantDefinition,itExemplification,
                         itGeneralization,itLociDeclaration]) then
   begin
      gLastWSItem:=gWsTextProper^.NewItem(fKind,CurPos);
      nLastWSItem:=gLastWSItem;
   end;
   case nItemKind of
      @<Initialize extended item by \\{ItemKind}@>@;
   endcases;
   if not (nItemKind in [itReservation,itConstantDefinition,itExemplification,
                         itGeneralization,itLociDeclaration]) then
      gLastWSBlock^.nItems.Insert(gLastWSItem);
end;

@ \node{Initializing the fields.}
The |it_Allowed| global variable is toggled on and off when the
Parser encounters ``guards'' in conditional definitions, whereas the
|nItAllowed| fields reflects whether the sort of definition allows
``\texttt{it}'' in the definiens.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! dol_Allowed: Boolean;
  @! it_Allowed: Boolean;
  @! in_AggrPattern: Boolean; @#

  @! gLastType: TypePtr;
  @! gLastTerm: TermPtr;
  @! gDefiningWay: HowToDefine;

@ @<Local variables for parser additions@>=
  @! gClusterSort: ClusterRegistrationKind;
  @! gDefiniens: DefiniensPtr;
  @! gPartialDefs: PList;
  @! nDefiniensProhibited: boolean;
  @! gSpecification: TypePtr;

@ @<Initialize the fields for newly allocated \\{extItem} object@>=
   nItemPos:=CurPos;
   gClusterSort:=ExistentialRegistration;
   nItAllowed:=false;
   it_Allowed:=false; {global variable!}
   in_AggrPattern:=false;
   dol_Allowed:=false;
   gSpecification:=nil;
   gLastType:=nil;
   gLastFormula:=nil;
   gLastTerm:=nil; @/
   { Preparation of definiens: }
   nDefiniensProhibited:=false; @/
   { Possible ban on expanded facilities }
   gDefiningWay:=dfEmpty;
   gDefiniens:=nil;
   gPartialDefs:=nil;
   nLinkable:=false;

@ \node{Kind-specific initialization.} Each kind of item may need some
specific initialization. We work through all the cases. The first two
cases considered are generalization (``\texttt{let} $\langle$\textit{Qualified Variables}$\,\rangle$
\texttt{be} [\texttt{such} $\langle$\textit{Conditions}$\,\rangle$]'')
and existential assumptions (``\texttt{given}
$\langle$\textit{Qualified Variables}$\,\rangle$
\texttt{such}
$\langle\,$\textit{Conditions}$\,\rangle$''). Existential assumptions
need to toggle the ``has assumptions'' field to true for the global
block pointer.

@<Initialize extended item by \\{ItemKind}@>=
      itGeneralization: ; {\texttt{let} statements}
      itExistentialAssumption: ExtBlockPtr(gBlockPtr)^.nHasAssumptions:=true;

@ \node{Property initialization.}
Initializing a property statement \\{Item} should raise an error
when the property does not appear in the correct block.

\bul Defining a predicate can support the following properties:
symmetry, reflectivity, irreflexivity, transitivity, conectedness, asymmetry.
\bul Functors can support: associativity, commutativity, idempotence,
involutiveness, and projectivity properties. 
\bul Modes can support the sethood property.

\medbreak
In all other situations, an error should be flagged (the user is
trying to assert an invalid property).

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gDefKind: ItemKind;

@ @<Local variables for parser additions@>=
  @! gExpandable:boolean;
  @! gPropertySort: PropertyKind;
  
@ @<Initialize extended item by \\{ItemKind}@>=
      itProperty:
         begin
            gPropertySort:=PropertyKind(CurWord.Nr);
            case PropertyKind(CurWord.Nr) of
               sySymmetry,syReflexivity,syIrreflexivity,syTransitivity,syConnectedness,syAsymmetry:@|@/
                  if gDefKind<>itDefPred then begin ErrImm(81); gPropertySort:=sErrProperty;@+ end;
               syAssociativity,syCommutativity,syIdempotence:
                  if gDefKind<>itDefFunc then begin ErrImm(82); gPropertySort:=sErrProperty;@+ end;
               syInvolutiveness,syProjectivity:
                  if gDefKind<>itDefFunc then begin ErrImm(83); gPropertySort:=sErrProperty;@+ end;
               sySethood:
                  if (gDefKind<>itDefMode) or gExpandable then begin ErrImm(86); gPropertySort:=sErrProperty;@+ end;
            endcases;
         end;

@ \node{Reconsider initialization.} We need to allocate a new (empty)
list for the list of terms being reconsidered.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gReconsiderList: PList;

@ @<Initialize extended item by \\{ItemKind}@>=
      itReconsider:
         gReconsiderList:=new(PList,Init(0));

@ We can have in Mizar ``\texttt{suppose that}
$\langle\textit{statement\/}\rangle$'' (as well as ``\texttt{case that}\dots'').
But in those cases, the statement cannot be linked to the next
statement (i.e., the next statement cannot begin with ``\texttt{then}\dots'').
Assumptions without ``\texttt{that}'' are always linkable.r

Theorems, ``regular statements'', and conclusions are always linkable.

@ @<Initialize extended item by \\{ItemKind}@>=
      itRegularStatement: nLinkable:=true;
      itConclusion:
         nLinkable:=true;
      itPerCases: ;
      itCaseHead:
         if AheadWord.Kind <> sy_That then nLinkable:=true;
      itSupposeHead:
         if AheadWord.Kind <> sy_That then nLinkable:=true;
      itTheorem:
         nLinkable:=true;
      itAxiom:
         if not AxiomsAllowed then ErrImm(66);
      itChoice: ;

@ \node{Initializing an assumption.} Collective assumptions
(``\texttt{assume that} $\langle$\textit{formula}$\rangle$'') are not
linkable, but
single assumptions (``\texttt{assume} $\langle$\textit{Proposition}$\rangle$'')
are linkable. The statement will introduce a list of premises, which
will be tracked in the \\{gPremises} local variable for the module.

@<Local variables for parser additions@>=
  @! gPremises: PList;

@ @<Initialize extended item by \\{ItemKind}@>=
      itAssumption:
         begin
            if AheadWord.Kind <> sy_That then nLinkable:=true;
            gPremises:=nil;
         end;


@ \node{Definition items.}
Definition items need to be initialized with some nuance. Some
definitions permit ``\texttt{it}'' to be used in the definiens, but
others do not. Mizar toggles the global variables tracking this
here. There is a common set of things toggled which we have isolated
as the \WEB/ macro |initialize_definition_item| common to initializing
all definition items.

The correctness conditions are determined at this point, as well.

@d initialize_definition_item == 
            gCorrectnessConditions:=[];
            gDefPos:=CurPos;
            gDefKind:=nItemKind

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gCorrectnessConditions : CorrectnessConditionsSet;

@ @<Local variables for parser additions@>=
  @! gDefPos: Position;
  @! gStructPrefixes: PList;

@ @<Initialize extended item by \\{ItemKind}@>=
      itLociDeclaration: ;
      itDefMode:
         begin
            nItAllowed:=true;
            gExpandable:=false;
            initialize_definition_item @+
         end;
      itDefAttr:
         begin
            initialize_definition_item @+
         end;
      itAttrSynonym:
         begin
            initialize_definition_item @+
         end;
      itAttrAntonym:
         begin
            initialize_definition_item @+
         end;
      itModeNotation:
         begin
            initialize_definition_item @+
         end;
      itDefFunc:
         begin
            nItAllowed:=true;
            initialize_definition_item @+
         end;
      itFuncNotation:
         begin
             initialize_definition_item; @+
         end;
      itDefPred,
      itPredSynonym,
      itCluster,
      itIdentify,
      itReduction: @|@/
         begin  initialize_definition_item; @+
         end;
      itPropertyRegistration:
         begin
            initialize_definition_item;
            gPropertySort:=PropertyKind(CurWord.Nr);
         end;
      itDefStruct:
         begin
            initialize_definition_item;
            gStructPrefixes:=new(PList,Init(0)); @+
         end;
      itCanceled:
         begin
            ErrImm(88); @+
         end;

@ \node{Correctness conditions.} Registrations and definitions need
correctness conditions to ensure the well-definedness of adjective
clusters and terms. The correctness conditions needed for a definition
(or registration) are inserted into
the \\{gCorrectnessConditions} variable. When the correctness
condition is found, we remove it from the \\{gCorrectnessConditions} set.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gRedefinitions: boolean;

@ @<Local variables for parser additions@>=
  @! gCorrCondSort: CorrectnessKind;

@<Initialize extended item by \\{ItemKind}@>=
      itCorrCond:
         if CorrectnessKind(CurWord.Nr) in gCorrectnessConditions then
         begin
            exclude(gCorrectnessConditions,CorrectnessKind(CurWord.Nr));
            gCorrCondSort:=CorrectnessKind(CurWord.Nr);
            if (gRedefinitions and (gCorrCondSort=syCoherence) and ExtBlockPtr(gBlockPtr)^.nHasAssumptions) then ErrImm(243);
         end
         else
         begin
            ErrImm(72);
            gCorrCondSort:=CorrectnessKind(0); @+
         end;
      itCorrectness: if (gRedefinitions and ExtBlockPtr(gBlockPtr)^.nHasAssumptions) then ErrImm(243);

@ The last statement needing attention will be the \texttt{scheme}
block. Note that \\{gLocalScheme} is not used anywhere.

@<Local variables for parser additions@>=
  @! gLocalScheme: boolean;
  @! gSchemePos: Position;

@ @<Initialize extended item by \\{ItemKind}@>=
      itDefinition, itSchemeHead, itReservation,
      itPrivFuncDefinition, itPrivPredDefinition,
      itConstantDefinition, itExemplification:;
      itCaseBlock:;
      itSchemeBlock:
         begin
            gLocalScheme:=CurWord.Kind <> sy_Scheme;
            gSchemePos:=CurPos; @+
         end;


@ \node{Popping an extended item.}

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gSchemeParams: PList;

@ @<Local variables for parser additions@>=
  @! gPatternPos: Position;
  @! gPattern: PatternPtr;
  @! gNewPatternPos: Position;
  @! gNewPattern: PatternPtr;

  @! gSchemeIdNr: integer;
  @! gSchemeIdPos: Position;
  @! gSchemeConclusion: FormulaPtr;
  @! gSchemePremises: PList;

@* [s] Popping.
Popping an item is invoked as part of \\{KillItem}, which occurs
whenever (1) a semicolon is encountered, 
or (2) when starting a proof environment.

The contract for popping an item ensures the \\{nContent} field shall
be populated for valid items.

N{\sc OTE}: \PASCAL/ has a set operation $\\{include} (\\{set},\\{element})$
which adjoins an \\{element} to a \\{set}.

@<Extended item implementation@>=
procedure @? extItemObj.Pop;
var k:integer;
begin
   gLastWSItem^.nItemEndPos:=PrevPos; 
   @<Check for errors with definition items@>@;
   @<Update content of |nLastWSItem| based on type of item popped@>; @/
   @<Check the popped item's linkages are valid@>;
   if gDefiningWay <> dfEmpty then
   begin
      if gDefiniens^.nDefSort = ConditionalDefiniens then
         include(gCorrectnessConditions,syConsistency);
      if gRedefinitions then
         include(gCorrectnessConditions,syCompatibility);
   end;
   inherited Pop; {(\section\xref{ItemObj.Pop})}
end;

@ We will update the caller's \\{nLastWSItem}'s contents in most cases.

@<Update content of |nLastWSItem| based on type of item popped@>=
   case nItemKind of
      itTheorem:
         nLastWSItem^.nContent:=
         new(CompactStatementPtr,
             Init(new(PropositionPtr,Init(nLabel,
                                          gLastFormula,nPropPos)),
                  nInference)); @#
@t\4@>      @<Pop a proof step@>@; @#
      itConclusion,
      itRegularStatement:
      @<Pop a conclusion or regular statement@>@;
      itGeneralization,
      itLociDeclaration:
      @<Pop a ``\texttt{let}'' statement@>@; @#
@t\4@>      @<Pop a definition item@>@;@#
      itPredSynonym, itPredAntonym, itFuncNotation, itModeNotation,
      itAttrSynonym, itAttrAntonym:
         nLastWSItem^.nContent:=
                        new(NotationDeclarationPtr,
                            Init(gNewPatternPos,nItemKind,gNewPattern,gPattern));@#
@t\4@>      @<Pop a registration item@>@;@#
      itCorrCond:
         nLastWSItem^.nContent:=new(CorrectnessConditionPtr,
                                    Init(nItemPos,gCorrCondSort,nInference));
      itCorrectness:
         nLastWSItem^.nContent:=new(CorrectnessConditionsPtr,
                                    Init(nItemPos,gCorrectnessConditions,nInference));
      itProperty:
         nLastWSItem^.nContent:=new(PropertyPtr,Init(nItemPos,gPropertySort,nInference));
      itSchemeHead:
         nLastWSItem^.nContent:=
         new(SchemePtr,Init(gSchemeIdNr,gSchemeIdPos,gSchemeParams,gSchemePremises,gSchemeConclusion));@#
@t\4@>      @<Pop \&{skip}s remaining cases@>@;
   endcases

@ @<Pop \&{skip}s remaining cases@>=
      itPrivFuncDefinition,
      itPrivPredDefinition,
      itPragma,
      itDefinition,
      itSchemeBlock,
      itReservation,
      itExemplification,
      itCaseBlock:;

@ \node{Check for errors.} We need to flag a 253 or 254 error when the user
tries to introduce an axiom (which shouldn't occur much anymore, since
axioms are not even documented anywhere).

@<Local variables for parser additions@>=
  @! gMeansPos: Position;

@ @<Check for errors with definition items@>=
   case nItemKind of
      itDefPred, itDefFunc, itDefMode, itDefAttr:
         begin
            if gDefiningWay <> dfEmpty then
            begin
               if nDefiniensProhibited and not AxiomsAllowed then
               begin
                  Error(gMeansPos,254);
                  gDefiningWay:=dfEmpty; @+
               end;
            end
            else if not gRedefinitions and not nDefiniensProhibited and not AxiomsAllowed then
               SemErr(253);
         end;
   endcases;

@ \node{Pop a proof step.} Popping a proof step should assign to the
contents of the caller's \\{nLastWsItem} some kind of inference justification,
usually in the form of a statement in the \WSM/ syntax tree.

@<Pop a proof step@>=
      itPerCases:
         nLastWSItem^.nContent:=nInference;

@ \node{Popping a reconsideration.} We should assign
a \\{TypeChangingStatement} to the content of the caller's last item, using
the \\{nInference} field of the caller as the justification.

@<Pop a proof step@>=
      itReconsider:
         nLastWSItem^.nContent:=
         new(TypeChangingStatementPtr,
             Init(gReconsiderList,gLastType,SimpleJustificationPtr(nInference)));

@ \node{Popping existential elimination and introduction.} We assign
a \texttt{consider} (or \texttt{given}) \WSM/ statement to the
caller's previous \\{WSItem}'s contents when popping a
choice (resp., existential assumption) item.

We should remind the reader of the grammar here:

\smallbreak
{\advance\leftskip3pc\parindent=0pt
$\langle$\textit{Qualified-Segment\/}$\rangle$ $::=$ $\langle$\textit{Variables\/}$\rangle$ $\langle$\textit{Qualification\/}$\rangle$

$\langle$\textit{Variables\/}$\rangle$ $::=$ $\langle$\textit{Variable\/}$\rangle$ $\LB$ \texttt{","} $\langle$\textit{Variable\/}$\rangle$ $\RB$

$\langle$\textit{Qualification\/}$\rangle$ $::=$
(\texttt{"being"} \pipe\ \texttt{"be"}) $\langle$\textit{Type-Expression\/}$\rangle$
\par}
\smallbreak\noindent%
And, of course, a qualified-segment list is just a comma-separated
list of qualified-segments.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gQualifiedSegmentList: PList;

@ @<Pop a proof step@>=
      itChoice:
         begin
            nLastWSItem^.nContent:=
               new(ChoiceStatementPtr,
                   Init(gQualifiedSegmentList,gPremises,SimpleJustificationPtr(nInference)));
            gPremises:=nil;
         end;
      itExistentialAssumption:
         begin
            nLastWSItem^.nContent:=
               new(ExistentialAssumptionPtr,
                   Init(nItemPos,gQualifiedSegmentList,gPremises));
            gPremises:=nil;
         end;

@ \node{Popping a stipulation.} When we pop
a \texttt{case}, \texttt{suppose}, or \texttt{assume} --- some kind of
``assumption''-like statement --- we are assigning
either a \\{CollectiveAssumption} object or a \\{SingleAssumption}
object to the content of the \emph{current} \\{WSItem} \textbf{global}
variable.

@<Local variables for parser additions@>=
  @! gThatPos: Position;

@ @<Pop a proof step@>=
      itSupposeHead,itCaseHead,
      itAssumption:
         if gPremises <> nil then
         begin
            gLastWSItem^.nContent:=new(CollectiveAssumptionPtr,Init(gThatPos,gPremises));
            gPremises:=nil;
         end
         else
            gLastWSItem^.nContent:=
               new(SingleAssumptionPtr,Init(nItemPos,
                                            new(PropositionPtr,Init(nLabel,
                                                                    gLastFormula,nPropPos))));

@ \node{Pop a conclusion or regular statement.} We assign an
appropriate \WSM/ statement node to the previous item's contents.

@<Local variables for parser additions@>=
  @! gIterativeSteps: PList;
  @! gIterativeLastFormula: FormulaPtr;
  @! gInference: JustificationPtr;

@ @<Pop a conclusion or regular statement@>=
         case nRegularStatementKind of
            stDiffuseStatement:
               nLastWSItem^.nContent:=
               new(DiffuseStatementPtr,Init(nLabel,
                                            stDiffuseStatement));
            stCompactStatement:
               nLastWSItem^.nContent:=
               new(CompactStatementPtr,
                   Init(new(PropositionPtr,Init(nLabel,
                                                gLastFormula,nPropPos)),
                        nInference));
            stIterativeEquality:
               nLastWSItem^.nContent:=
               new(IterativeEqualityPtr,
                   Init(new(PropositionPtr,Init(nLabel,
                                                gIterativeLastFormula,nPropPos)),
                        gInference,gIterativeSteps));
         endcases;

@ \node{Pop a `let' statement.} For generic let statements of the form
$$\texttt{let}~\vec{x}_{1}~\texttt{be}~T_{1},\dots,\vec{x}_{n}~\texttt{be}~T_{n}$$
we transform it to $n$ statements of the form ``\texttt{let}
$\vec{x}$ \texttt{be} $T$'', then add these to the \\{gLastWSBlock}'s
items. When we have
$$\texttt{let}~\vec{x}~\texttt{be}~T~\hbox{\texttt{such that}}~\Phi$$
we need to  add a \\{CollectiveAssumption} node to
the \textbf{global} \\{gLastWSBlock}'s items.

\label{pop-let-statement}

@<Local variables for parser additions@>=
  @! gSuchPos: Position;
  
@ @<Pop a ``\texttt{let}'' statement@>=
         begin
            for k := 0 to gQualifiedSegmentList^.Count-1 do
            begin
               gLastWSItem:=gWsTextProper^.NewItem(nItemKind,
                                                   QualifiedSegmentPtr(gQualifiedSegmentList^.Items^[k])^.nSegmPos);
               nLastWSItem:=gLastWSItem;
               gLastWSItem^.nContent:=gQualifiedSegmentList^.Items^[k];
               if k = gQualifiedSegmentList^.Count-1 then
                  gLastWSItem^.nItemEndPos:=PrevPos
               else
                  gLastWSItem^.nItemEndPos:=QualifiedSegmentPtr(gQualifiedSegmentList^.Items^[k+1])^.nSegmPos;
               gQualifiedSegmentList^.Items^[k]:=nil;
               gLastWSBlock^.nItems.Insert(gLastWSItem);
            end;
            dispose(gQualifiedSegmentList,Done);
            if gPremises <> nil then
            begin
               gLastWSItem:=gWsTextProper^.NewItem(itAssumption,gSuchPos);
               gLastWSItem^.nContent:=new(CollectiveAssumptionPtr,Init(gThatPos,gPremises));
               gPremises:=nil;
               gLastWSItem^.nItemEndPos:=PrevPos;
               nLastWSItem:=gLastWSItem;
               gLastWSBlock^.nItems.Insert(gLastWSItem);
            end;
         end;

@ \node{Pop a mode definition.} A mode is either expandable (an
abbreviation) or nonexpandable. For expandable modes, we just add a
new \\{ExpandableModeDefinition} \WSM/ object to the
caller's \\{nLastWSItem}'s contents.

On the other hand, non-expandable modes should add to the
caller's \\{nLastWSItem}'s contents a new \\{StandardModeDefinition}
object. If this is not a redefinition, then we must add the
``\texttt{existence}'' correctness condition to the global
variable \\{gCorrectnessConditions}. 

@<Pop a definition item@>=
      itDefMode:
         begin
            if gExpandable  then
               nLastWSItem^.nContent:=
                  new(ExpandableModeDefinitionPtr,
                      Init(gPatternPos,ModePatternPtr(gPattern),gLastType))
            else
            begin
               nLastWSItem^.nContent:=
                  new(StandardModeDefinitionPtr,
                      Init(gPatternPos,gRedefinitions,ModePatternPtr(gPattern),
                           gSpecification,gDefiniens));
               if not gRedefinitions then
                  include(gCorrectnessConditions,syExistence);
            end;
         end;

@ \node{Pop a functor definition.} When popping a functor definition,
we just add a \\{FunctorDefinition} object to the
caller's \\{nLastWSItem}'s contents.

@<Pop a definition item@>=
      itDefFunc:
         begin
            nLastWSItem^.nContent:=
               new(FunctorDefinitionPtr,
                   Init(gPatternPos,gRedefinitions,FunctorPatternPtr(gPattern),
                        gSpecification,gDefiningWay,gDefiniens));

         end;

@ \node{Pop an attribute definition.} We just need to add
an \\{AttributeDefinition} object to the caller's \\{nLastWSItem}'s
contents.

@<Pop a definition item@>=
      itDefAttr:
         begin
            nLastWSItem^.nContent:=
               new(AttributeDefinitionPtr,
                   Init(gPatternPos,gRedefinitions,AttributePatternPtr(gPattern),gDefiniens));
         end;

@  \node{Pop a predicate definition.} We just need to add
a \\{PredicateDefinition} object to the caller's \\{nLastWSItem}'s
contents.

@<Pop a definition item@>=
      itDefPred:
         begin
            nLastWSItem^.nContent:=
               new(PredicateDefinitionPtr,
                   Init(gPatternPos,gRedefinitions,PredicatePatternPtr(gPattern),gDefiniens));
         end;

@ \node{Popping a structure definition.} We just need to add
a \\{StructureDefinition} object to the caller's \\{nLastWSItem}'s
contents.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gConstructorNr: integer;

@ @<Local variables for parser additions@>=
  @! gParams: PList;
  @! gStructFields: PList;

@ @<Pop a definition item@>=
      itDefStruct:
         begin
            nLastWSItem^.nContent:=
               new(StructureDefinitionPtr,
                   Init(gPatternPos,gStructPrefixes,gConstructorNr,gParams,gStructFields));
         end;

@ \node{Pop a cluster registration item.} A ``cluster'' registration
(i.e., a existential, conditional, or functor registration) adds to
the caller's \\{nLastWSItem}'s contents a new cluster object (of
appropriate kind). The \\{gClusterSort} is populated when the Parser
finishes a cluster registration when
invoking \\{extItemObj.FinishAntecedent}
(\section\xref{extItemObj.FinishAntecedent}) or similar methods.

The \\{gClusterTerm} is populated in
the \\{extItemObj.FinishClusterTerm} method
(\section\xref{extItemObj.FinishClusterTerm}). 

@<Local variables for parser additions@>=
  @! gAntecedent,gConsequent: PList;
  @! gClusterTerm: TermPtr;

@ @<Pop a registration item@>=
      itCluster:
         begin
            case gClusterSort of
               ExistentialRegistration:
                  begin
                     nLastWSItem^.nContent:=new(EClusterPtr,Init(nItemPos,gConsequent,gLastType));
                     include(gCorrectnessConditions,syExistence)
                  end;
               ConditionalRegistration:
                  begin
                     nLastWSItem^.nContent:=
                        new(CClusterPtr,Init(nItemPos,gAntecedent,gConsequent,gLastType));
                     include(gCorrectnessConditions,syCoherence);
                  end;
               FunctorialRegistration:
                  begin
                     nLastWSItem^.nContent:=
                        new(FClusterPtr,Init(nItemPos,gClusterTerm,gConsequent,gLastType));
                     include(gCorrectnessConditions,syCoherence);
                  end;
            endcases;
         end;

@ \node{Pop a registration item.} For an \texttt{identify}
or \texttt{reduce} registration, we assign the content of the
caller's \\{nLastWSItem} a new \\{IdentifyRegistration}
(resp., \\{ReduceRegistration}) object. Identify registrations use
the \\{gIdentifyEqLociList} local variable, while the reduction
registrations use the \\{gLeftTermInReduction} module-wide variable.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gLeftTermInReduction: TermPtr;

@ @<Local variables for parser additions@>=
  @! gIdentifyEqLociList: PList;

@ @<Pop a registration item@>=
      itIdentify:
         begin
            nLastWSItem^.nContent:=
               new(IdentifyRegistrationPtr,Init(nItemPos,gNewPattern,gPattern,gIdentifyEqLociList));
            include(gCorrectnessConditions,syCompatibility);
         end;
      itReduction:
         begin
            nLastWSItem^.nContent:=
               new(ReduceRegistrationPtr,Init(nItemPos,gLeftTermInReduction,gLastTerm));
            include(gCorrectnessConditions,syReducibility);
         end;
      itPropertyRegistration:
         SethoodRegistrationPtr(nLastWSItem^.nContent)^.nJustification:=nInference;


@ \node{Check linkages are valid.} When popping an item, we should
check if the block containing the caller is \\{nLinked}. If so, flag a
``178'' error and assign |nLinked := false|. Update the block's
|nLinkAllowed| depending on the caller's |nLinkable| field. But if the
Parser is in panic mode, the containing block's |nLinkAllowed| and
|nLinkProhibited| are both assigned to false. \Ithink{This
configuration appears to encode a particular state which feels a bit
of a ``kludge'' to me\dots}

@^Error, 178@>

@<Check the popped item's linkages are valid@>=
   with extBlockPtr(gBlockPtr)^ do
   begin
      if nLinked then
      begin
         Error(nLinkPos,178);
         nLinked:=false @+
      end;
      nLinkAllowed:=nLinkable;
      nLinkProhibited:=not nLinkable;
      if not StillCorrect then
      begin
         nLinkAllowed:=false;
         nLinkProhibited:=false @+
      end;
   end

@* [s] Registrations and notations.
\node{Processing synonyms.} We need to update the \\{gNewPatternPos}
and \\{gNewPattern} global variables when processing a synonym.

@d process_notation_item ==
   gNewPatternPos:=gPatternPos;
   gNewPattern:=gPattern

@<Extended item implementation@>=
procedure @? extItemObj.ProcessModeSynonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessAttrSynonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessAttrAntonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessPredSynonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessPredAntonym;
begin process_notation_item; @+
end; @#

procedure @? extItemObj.ProcessFuncSynonym;
begin process_notation_item; @+
end; @#

@ \node{Starting attributes.} This is used when the Parser encounters
a cluster registration
(\section\xref{RegisterCluster:parser.pas}). The \\{gAttrColl} is
populated in the \\{extSubexpObj.CompleteAdjectiveCluster}
(\section\xref{extSubexpObj.CompleteAdjectiveCluster}) method.

\label{extItemObj.StartAttributes}

@<Local variables for parser additions@>=
  @! gAttrColl: PList;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartAttributes;
begin
   gAttrColl:=new(PList,Init(6));
end;

@ \node{Starting a sentence.} We just need to populate the
caller's \\{nPropPos}, assigning to it the current position of the
Parser.

\label{extItemObj.StartSentence}

@<Extended item implementation@>=
procedure @? extItemObj.StartSentence;
begin
   nPropPos:=CurPos;
end;

@ \node{Processing conditional registration.} This populates
the \\{gClusterSort} and the related global variables, as the Parser
finishes parsing the antecedent and consequent to the cluster.

\label{extItemObj.FinishAntecedent}

@<Extended item implementation@>=
procedure @? extItemObj.FinishAntecedent;
begin
   gClusterSort:=ConditionalRegistration;
   gAntecedent:=gAttrColl;
end; @#

procedure @? extItemObj.FinishConsequent;
begin
   gConsequent:=gAttrColl;
end;

@ \node{Finishing a cluster.} This populates the \\{gClusterSort} and
the \\{gClusterTerm}.

\label{extItemObj.FinishClusterTerm}

@<Extended item implementation@>=
procedure @? extItemObj.FinishClusterTerm;
begin
   gClusterSort:=FunctorialRegistration;
   gClusterTerm:=gLastTerm;
end;

@ \node{Identify registration.} Schematically, we have the
registration statement look like (using global variable names for the
subexpressions): 
$$\texttt{identify}~\langle\textit{gNewPattern\/}\rangle~\texttt{with}~\langle\textit{gPattern}\rangle~[\texttt{when}~\langle\textit{gIdentifyEqLociList\/}\rangle]\texttt{;}$$
We store the first pattern in the \\{gNewPattern} global variable,
then the second pattern in the \\{gPattern} global
variable. Completing the identify registration will check if the
current word is ``\texttt{when}'' and, if so, start a list of loci equalities.

@<Extended item implementation@>=
procedure @? extItemObj.StartFuncIdentify;
begin
end; @#

procedure @? extItemObj.ProcessFuncIdentify;
begin
   gNewPatternPos:=gPatternPos;
   gNewPattern:=gPattern;
end; @#

procedure @? extItemObj.CompleteFuncIdentify;
begin
   gIdentifyEqLociList:=nil;
   if CurWord.Kind = sy_When then
      gIdentifyEqLociList:=new(PList,Init(0));
end;

@ \node{``Reduces to'' registrations.}
Recall, these schematically look like
$$\hbox{\texttt{reduce}\ }\langle\textit{gLeftLocus\/}\rangle\hbox{ \texttt{to} }\langle\textit{Locus\/}\rangle\hbox{\texttt{;}}$$
Mizar will populate \\{gLeftLocus}. The gambit will be to treat this
as a functor pattern; i.e., the \\{gLeftLocus} will be used to
populate \\{gNewPattern} in the method
\\{extItemObj.FinishFunctorPattern} (\section\xref{extItemObj.FinishFunctorPattern}).

@<Local variables for parser additions@>=
  @! gLeftLocus: LocusPtr;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessLeftLocus;
begin
   gLeftLocus:=new(LocusPtr,Init(CurPos,GetIdentifier));
end; @#

procedure @? extItemObj.ProcessRightLocus;
begin
   gIdentifyEqLociList.Insert(new(LociEqualityPtr,
                                 Init(PrevPos,gLeftLocus,new(LocusPtr,Init(CurPos,GetIdentifier)))));
end; @#

procedure @? extItemObj.StartFuncReduction;
begin
end; @#

procedure @? extItemObj.ProcessFuncReduction;
begin
   gNewPatternPos:=gPatternPos;
   gLeftTermInReduction:=gLastTerm;
end;

@* [s] Processing definitions.
The terminology used by the Parser appears to be
(\section\section\xref{FixedVariables:parser.pas} \textit{et seq.}):
$$\hbox{\texttt{let} }\langle\textit{Fixed\ Variables}\rangle\hbox{\texttt{;}}$$
and
$$\hbox{\texttt{consider} }\langle\textit{Fixed\ Variables}\rangle\hbox{ \texttt{such that}}\dots$$
This would mean that we would have ``fixed variables'' refer to a list
of qualified segments. We remind the reader of the grammar
$$\vbox{\halign{$#$\hfil\cr
\<Fixed-Variables>\ ::= \<Implicitly-Qualified-Variables>\ \LB\ \hbox{\texttt{","}}\ \<Fixed-Variables>\ \RB\cr
\hphantom{\<Fixed-Variables>\ ::}\mid \<Explicitly-Qualified-Variables>\ \LB\ \hbox{\texttt{","}}\ \<Fixed-Variables>\ \RB\cr
\<Implicitly-Qualified-Variables> ::= \<Variables>\cr
\<Explicitly-Qualified-Variables> ::= \<Qualified-Segment>\ \LB \hbox{\texttt{","}}
\<Qualified-Segment>\ \RB\cr
\<Qualified-Segment> ::= \<Variables>\ \<Qualification>\cr
\<Variables> ::= \<Variable>\ \LB\ \hbox{\texttt{","}}\ \<Variable>\ \RB\cr
\<Qualification> ::= (\hbox{\texttt{"be"}}\ \pipe\ \hbox{\texttt{"being"}})\ \<Type>\cr}}$$
The ``fixed variables'' routine in the Parser will parse a
comma-separated list of qualified variables.

\CAUTION/: The grammar in the \texttt{syntax.txt} file is actually
more strict than this, because it actually states the following:
$$\<Loci-Declaration> ::= \hbox{\texttt{"let"} } \<Qualified-Variables> [ \hbox{ \texttt{"such"} } \<Conditions> \hbox{ }] \hbox{ \texttt{;}}$$
The grammar for a qualified segment \emph{requires} implicitly
qualified variables appear at the very end.

\label{extItemObj.StartFixedVariables}

@<Extended item implementation@>=
procedure @? extItemObj.StartFixedVariables;
begin
   gQualifiedSegmentList:=new(PList,Init(0));
end;

@ @<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gQualifiedSegment: MList;
  @! gSegmentPos: Position;

@ \node{Fixed segments.} This refers to each ``explicitly qualified segment''
or ``implicitly qualified segment'' appearing in the fixed variables
portion. The fixed segments are separated by commas.

@<Extended item implementation@>=
procedure @? extItemObj.StartFixedSegment;
begin
   gQualifiedSegment.Init(0);
   gSegmentPos:=CurPos;
end;

@ When parsing fixed variables, and the Parser has just entered the
loop to parse fixed variables, this function will be invoked.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessFixedVariable;
begin
   gQualifiedSegment.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end;

@ This ``clears the cache'' for assigning the type in an explicitly
qualified segment (appearing in a fixed variable segment).

@<Extended item implementation@>=
procedure @? extItemObj.ProcessBeing;
begin
   gLastType:=nil;
end;

@ The last statement in the Parser loop when parsing ``fixed
variables'' is to push the ``fixed segment'' onto
the \\{gQualifiedSegmentList} global variable. There are two cases to
consider: the implicitly qualified variables and the explicitly
qualified variables.

The implicitly qualified case simple \emph{moves} the pointers around
``manually'', so we need to update every entry
of \\{gQualifiedSegment.Items} to be nil. The explicitly qualified
case moves the pointers around using the \\{MList} constructor,
mutating \\{gQualifiedSegment} into a list of |nil| pointers.

@<Extended item implementation@>=
procedure @? extItemObj.FinishFixedSegment;
var k:integer;
begin
   if gLastType <> nil then {explicitly qualified case}
   begin
      gQualifiedSegmentList^.Insert(new(ExplicitlyQualifiedSegmentPtr,
                                        Init(gSegmentPos,new(PList,MoveList(gQualifiedSegment)),gLastType)));
      gQualifiedSegment.DeleteAll;
   end
   else
   begin
      for k := 0 to gQualifiedSegment.Count - 1 do
      begin
         gQualifiedSegmentList^.Insert(new(ImplicitlyQualifiedSegmentPtr,
                                           Init(VariablePtr(gQualifiedSegment.Items^[k])^.nVarPos,
                                                gQualifiedSegment.Items^[k])));
         gQualifiedSegment.Items^[k]:=nil;
      end;
   end;
   gQualifiedSegment.Done;
end;

@ When we finish parsing fixed variables, we need to ``unset''
the \\{gPremises} global variable. The Parser will either be looking
at a semicolon token or at ``\texttt{such} \<Conditions>''. The reader
should note that \\{gSuchThatOcc} is not used in the Parser, nor
anywhere else in Mizar. But we recall (\section\xref{pop-let-statement})
the \\{gSuchPos} is used when popping a \texttt{let} statement.

\label{extItemObj.FinishFixedVariables}

@<Local variables for parser additions@>=
  @! gSuchThatOcc: boolean; {not used}

@ @<Extended item implementation@>=
procedure @? extItemObj.FinishFixedVariables;
begin
   gSuchThatOcc:=CurWord.Kind = sy_Such;
   gSuchPos:=CurPos;
   gPremises:=nil;
end;

@ When the Parser encounters the statement:
$$\hbox{\texttt{let }} \<Fixed-Variables> \hbox{\texttt{ such that }} \<Assumption>\texttt{;}$$
The first things it does when encountering the ``\texttt{such}'' token
is move to the next token (``\texttt{that}'') and then invoke
the \\{StartAssumption} method. We should allocate a fresh list
for \\{gPremises} and mark the position of the ``\texttt{that}'' token.

@<Extended item implementation@>=
procedure @? extItemObj.StartAssumption;
begin
   gPremises:=new(PList,Init(0));
   gThatPos:=CurPos;
end;

@ Finishing an assumption will update the global
variable \\{gBlockPtr}'s field reflecting it has assumptions.

@<Extended item implementation@>=
procedure @? extItemObj.FinishAssumption;
begin
   ExtBlockPtr(gBlockPtr)^.nHasAssumptions:=true;
end;

@ When the Mizar Parser has encountered
$$\hbox{\texttt{assume that }} \<Conditions> \texttt{;}$$
we start a collective assumption when the Parser has just encountered
the ``\texttt{that}'' token. As with the ``\texttt{let} statement with
assumptions'', we need to allocate a new list for \\{gPremises} and
assign the \\{gThatPos} to the current position.

\label{extItemObj.StartCollectiveAssumption}

@<Extended item implementation@>=
procedure @? extItemObj.StartCollectiveAssumption;
begin
   gPremises:=new(PList,Init(0));
   gThatPos:=CurPos;
end;

@ \node{Processing copula in a definition.} When defining a
(nonexpandable) mode, a functor, a predicate, or an attribute, we have
$$\<Pattern> \hbox{ \texttt{means} } \<Expression>\texttt{;}$$
or
$$\<Pattern> \hbox{ \texttt{equals} } \<Expression>\texttt{;}$$
The expression may or may not be labeled, we may or may not have the
definition-by-cases. Whatever the situation, we should initialize the
variables describing the definiens:
\bul the \\{gDefLabId} should be reset to zero (and populated in
the \\{ProcessDefLabel} method);
\bul the \\{gDefLabPos} should be reset to the current position (and
populated in the \\{ProcessDefLabel} method);
\bul the \\{gDefiningWay} should be assigned to \\{dfMeans}
or \\{dfEquals} depending on the copula used in the definition;
\bul the \\{gOtherwise} pointer should be assigned to |nil|;
\bul the \\{gMeansPos} position should be assigned to the current position.

\medbreak\noindent%
Following tradition in logic, we will refer to ``\texttt{means}'' and
``\texttt{equals}'' as the \define{Copula} in the definition.

@^Copula@>

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gDefLabId:integer;
  @! gDefLabPos: Position;
   
@ @<Local variables for parser additions@>=
  @! gOtherwise: PObject;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessMeans;
begin
   gDefLabId:= 0;
   gDefLabPos:=CurPos;
   gDefiningWay:=dfMeans;
   gOtherwise:=nil;
   gMeansPos:=CurPos
end; @#

procedure @? extItemObj.ProcessEquals;
begin
   gDefLabId:= 0;
   gDefLabPos:=CurPos;
   gDefiningWay:=dfEquals;
   gOtherwise:=nil;
   gMeansPos:=CurPos;
end;

@ When parsing a definition-by-cases, the cases are terminated with an
``\texttt{otherwise}'' keyword. Recall the grammar for such
definitions looks like:
$$ \<Partial-Definiens-List> \hbox{ \texttt{"otherwise"} } \<Expression>\texttt{;}$$
What happens depends on whether the definition uses ``\texttt{means}''
or ``\texttt{equals}'': in the former case, we should update
the \\{gOtherwise} pointer to be the \\{gLastFormula}; in the latter
case, we should update the \\{gOtherwise} to be the \\{gLastTerm}.

@<Extended item implementation@>=
procedure @? extItemObj.FinishOtherwise;
begin
   if gDefiningWay = dfEquals then
      gOtherwise:=gLastTerm
   else gOtherwise:=gLastFormula;
end;

@ Starting a definiens should mutate the |it_Allowed| global variable
to be equal to the caller's |nItAllowed| field. The |it_Allowed|
global variable is toggled on and off when the Parser encounters ``guards'' in
conditional definitions, whereas the |nItAllowed| fields reflects
whether the sort of definition allows ``\texttt{it}'' in the definiens.

@<Extended item implementation@>=
procedure @? extItemObj.StartDefiniens;
begin
   it_Allowed:=nItAllowed;
end;

@ ``Guards'' refers to the conditions in a
definition-by-cases. Specifically, we have
$$\<Partial-Definiens> ::= \<Expression> \hbox{ \texttt{"if"} } \<Guard-Formula>$$
be the grammar for one particular case. We have a comma-separated list
of partial definiens, so whenever the Parser (a) first encounters the
``\texttt{if}'' keyword in a definiens, or (b) has already encountered
the ``\texttt{if}'' keyword and now has encountered a comma --- these
are the two cases to start a new guard.

@<Local variables for parser additions@>=
  @! gPartDef: PObject;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartGuard;
begin
   if gPartialDefs = nil then
      gPartialDefs:=new(PList,Init(0));
   it_Allowed:=false;
   if gDefiningWay = dfMeans  then
      gPartDef:=gLastFormula
   else gPartDef:=gLastTerm;
end;

@ After parsing a formula, then the Parser will invoke \\{FinishGuard}.
This will append to \\{gPartialDefs} a new partial definiens.

@<Extended item implementation@>=
procedure @? extItemObj.FinishGuard;
begin
   it_Allowed:=nItAllowed;
   case gDefiningWay of
      dfMeans:
         gPartialDefs.Insert(new(PartDefPtr,Init(new(DefExpressionPtr,Init(exFormula,gPartDef)),gLastFormula)));
      dfEquals:
         gPartialDefs.Insert(new(PartDefPtr,Init(new(DefExpressionPtr,Init(exTerm,gPartDef)),gLastFormula)));
   endcases;
end;

@ Recall for functor definitions we have something like:
$$ \hbox{\texttt{func }} \<Pattern> \hbox{ \texttt{->} } \<Type> \hbox{ ( \texttt{means} \pipe\ \texttt{equals} ) }\dots$$
Similarly, nonexpandable modes look like
$$ \hbox{\texttt{mode }} \<Pattern> \hbox{ \texttt{->} } \<Type> \hbox{ \texttt{means} } \dots$$
The ``\texttt{->} \<Type>'' is called the [type] \emph{specification} for the
definition. We should update the \\{gSpecification} global variable to
point to whatever the last type parsed was --- which is stored in
the \\{gLastType} global variable.

@<Extended item implementation@>=
procedure @? extItemObj.FinishSpecification;
begin
   gSpecification:=gLastType;
end;

@ ``Construction type'' is the term used by the Parser for
``nonexpandable modes''. They, too, have a type
specification. The \\{FinishConstructionType} populates
the \\{gSpecification} global variable with this type.

\label{extItemObj.FinishConstructionType}

@<Extended item implementation@>=
procedure @? extItemObj.FinishConstructionType;
begin
   gSpecification:=gLastType;
end;

@ Expandable mode definitions, after encountering the ``\texttt{is}''
keyword, invokes the \\{StartExpansion} method. This just ensures
there is no definiens, and the \\{gExpandable} global variable is
assigned to ``true''.

@<Extended item implementation@>=
procedure @? extItemObj.StartExpansion;
begin
   if gRedefinitions then  ErrImm(271);
   nDefiniensProhibited:=true;
   gExpandable:=true;
end;

@ The Parser, when determining the pattern for an attribute (\section\xref{GetAttrPattern:parser.pas}), resets the state when
starting to determine the pattern for the attribute. This is handled
by the \\{StartAttribute} method.

We should remind the reader that attributes can only have
arguments \emph{to its left}.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gParamNbr: integer;

@ @<Local variables for parser additions@>=
  @! gLocus: LocusPtr;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartAttributePattern;
begin
   gParamNbr:=0;
   gParams:=nil;
   gLocus:=new(LocusPtr,Init(CurPos,GetIdentifier));
end;

@ Since an attribute can only have attributes to its left, it's pretty
clear when the attribute pattern has been parsed: the Parser has found
the attribute being defined. In that case (assuming we're not
panicking), we should add the attribute format to the \\{gFormatsColl}
dictionary and update the global variables.

@<Extended item implementation@>=
procedure @? extItemObj.FinishAttributePattern;
var lFormatNr: integer;
begin
   lFormatNr:=0;
   if (CurWord.Kind = AttributeSymbol) and stillcorrect then
      lFormatNr:=gFormatsColl.CollectPrefixForm('V',CurWord.Nr,gParamNbr);
   gPatternPos:=CurPos;
   gConstructorNr:=CurWord.Nr;
   gPattern:=new(AttributePatternPtr,Init(gPatternPos,gLocus,gConstructorNr,gParams));
end;

@ A mode definition may include a ``\texttt{sethood}'' property. This
particular function is used when registering sethood in a registration
block. 

@<Extended item implementation@>=
procedure @? extItemObj.FinishSethoodProperties;
begin
   nLastWSItem^.nContent:=
      new(SethoodRegistrationPtr,Init(nItemPos,gPropertySort,gLastType));
end;

@ We remind the reader the grammar for a mode pattern
$$ \<Mode-Pattern> ::= \<Mode-Symbol>\;[\hbox{ \texttt{"of"} } \<Loci>\;] $$
The loci parameters can only appear \emph{after} the mode symbol (and
before the ``\texttt{of}'' reserved keyword). Starting a mode pattern
should reset the relevant global variables.

\label{extItemObj.StartModePattern}

@<Extended item implementation@>=
procedure @? extItemObj.StartModePattern;
begin
   gParamNbr:=0;
   gParams:=nil;
   gPatternPos:=CurPos;
   gConstructorNr:=CurWord.Nr;
end;

@ Finishing a mode pattern should build a new \\{ModePatternObj}, and
store it in the \\{gPattern} global variable. And if we are not
panicking, we should add it to the \\{gFormatsColl} dictionary.

\label{extItemObj.FinishModePattern}

@<Extended item implementation@>=
procedure @? extItemObj.FinishModePattern;
var lFormatNr: integer;
begin
   lFormatNr:=0;
   if StillCorrect then
      lFormatNr:=gFormatsColl.CollectPrefixForm('M',gConstructorNr,gParamNbr);
   gPattern:=new(ModePatternPtr,Init(gPatternPos,gConstructorNr,gParams));
end;

@ When Parser starts parsing a new predicate pattern, we should reset
the relevant global variables.

@<Extended item implementation@>=
procedure @? extItemObj.StartPredicatePattern;
begin
   gParamNbr:=0;
   gParams:=nil;
end;

@ When the Parser tries to parse a ``predicative formula'' (i.e., a
formula involving a predicate) --- including predicate patterns ---
the first thing it does is invoke this \\{ProcessPredicateSymbol} method.
This resets the global variables needed to populate the arguments to
the predicate in the formula.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gLeftLociNbr: integer;

@ @<Local variables for parser additions@>=
  @! gLeftLoci: PList;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessPredicateSymbol;
begin
   gPatternPos:=CurPos;
   gLeftLociNbr:=gParamNbr;
   gLeftLoci:=gParams;
   gParamNbr:=0;
   gParams:=nil;
   gConstructorNr:=CurWord.Nr;
end;

@ Finishing a predicate pattern will create a new \\{PredicatePattern}
object, update the \\{gPattern} global variable to point to it, and
(if the Parser is not panicking) add the predicate's format to
the \\{gFormatsColl} dictionary.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPredicatePattern;
var lFormatNr: integer;
begin
   lFormatNr:=0;
   if StillCorrect then
      lFormatNr:=gFormatsColl.CollectPredForm(gConstructorNr,gLeftLociNbr,gParamNbr);
   gPattern:=new(PredicatePatternPtr,Init(gPatternPos,gLeftLoci,gConstructorNr,gParams));
end;

@ Functor patterns a bit trickier. When starting one, what should
occur depends on the type of functor being defined. Specifically, we
handle brackets differently than other functors, and within the
brackets we handle braces (i.e., definitions like $\LB x_{1},\dots,x_{n}\RB$)
differently than square brackets ($\hbox{\texttt{[}}x_{1},\dots,x_{n}\hbox{\texttt{]}}$)
differently than everything other functor bracket.

In all cases, even non-bracket functors, we need to reset
the \\{gParamNbr} and \\{gParams} global variables so they may be
populated correctly.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gSubItemKind: TokenKind;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartFunctorPattern;
begin
   gPatternPos:=CurPos;
   gSubItemKind:=CurWord.Kind;
   case CurWord.Kind of
      LeftCircumfixSymbol: gConstructorNr:=CurWord.Nr;
      sy_LeftSquareBracket:
         begin
            gSubItemKind:=LeftCircumfixSymbol;
            gConstructorNr:=SquareBracket
         end;
      sy_LeftCurlyBracket:
         begin
            gSubItemKind:=LeftCircumfixSymbol;
            gConstructorNr:=CurlyBracket
         end;
   othercases gConstructorNr:=0;
   endcases;
   gParamNbr:=0;
   gParams:=nil;
end;

@ For ``non-bracket'' functors (i.e., infix operators), the functor
pattern is processed by (1) getting the left parameters, (2)
processing the functor symbol, (3) getting the right parameters. This
function is precisely step (2).

\label{extItemObj.ProcessFunctorSymbol}
@<Extended item implementation@>=
procedure @? extItemObj.@!ProcessFunctorSymbol;
begin
   gPatternPos:=CurPos;
   if CurWord.Kind = InfixOperatorSymbol then
   begin
      gSubItemKind:=InfixOperatorSymbol;
      gConstructorNr:=CurWord.Nr;
      gLeftLociNbr:=gParamNbr;
      gLeftLoci:=gParams;
      gParamNbr:=0;
      gParams:=nil;
   end;
end;

@ When defining a bracket functor pattern, we add a new bracket
format to the \\{gFormatsColl} dictionary, and then set \\{gPattern}
to a newly allocated Bracket pattern.

When defining an infix functor, we add a new functor format to
the \\{gFormatsColl} dictionary, and then we set the \\{gPattern} to a
newly allocated infix functor pattern.

The ``other cases'' constructs an infix functor pattern, but does not
add the form to the \\{gFormatsColl} dictionary.

\label{extItemObj.FinishFunctorPattern}
@<Extended item implementation@>=
procedure @? extItemObj.FinishFunctorPattern;
var lConstructorNr,lFormatNr: integer;
begin
   lFormatNr:=0;
   case gSubItemKind of
      LeftCircumfixSymbol:
         begin
            lConstructorNr:=CurWord.Nr;
            if StillCorrect then
               lFormatNr:=gFormatsColl.CollectBracketForm(gConstructorNr,lConstructorNr,gParamNbr,0,0);
            gPattern:=new(CircumfixFunctorPatternPtr,Init(gPatternPos,gConstructorNr,lConstructorNr,gParams));
         end;
      InfixOperatorSymbol:
         begin
            if StillCorrect then
               lFormatNr:=gFormatsColl.CollectFuncForm(gConstructorNr,gLeftLociNbr,gParamNbr);
            gPattern:=new(InfixFunctorPatternPtr,Init(gPatternPos,gLeftLoci,gConstructorNr,gParams));
         end;
   othercases
      gPattern:=new(InfixFunctorPatternPtr,Init(gPatternPos,gLeftLoci,gConstructorNr,gParams));
   endcases;
end;

@ The Parser's \\{ReadVisible} procedure begins by invoking
this \\{StartVisible} method. The \\{ReadVisible} procedure occurs
when getting most patterns.

@<Extended item implementation@>=
procedure @? extItemObj.StartVisible;
begin
   gParams:=new(PList,Init(0));
end;

@ The Parser iteratively calls its \\{GetVisible} (\section\xref{GetVisible:parser.pas}) procedure
when \\{ReadVisible} arguments in a pattern. The \\{GetVisible}
procedure in turn invokes this \\{ProcessVisible}, which increments
the number of parameters, and pushes a new \\{Locus} object onto
the \\{gParams} stack.

\label{extItemObj.ProcessVisible}

@<Extended item implementation@>=
procedure @? extItemObj.ProcessVisible;
begin
   inc(gParamNbr);
   if gParams<>nil then
      gParams^.Insert(new(LocusPtr,Init(CurPos,GetIdentifier)));
end;

@ Recall a structure definition, when it has ancestors, looks like
$$\hbox{\texttt{struct (}} \<Ancestors> \hbox{\texttt{) }} \<Structure-Symbol>\cdots$$
The \<Ancestors> field is considered the ``prefix'' to the structure
definition. The Parser parses a type (thereby populating
the \\{gLastType} global variable), then invokes the \\{FinishPrefix}
method, then iterates if it encounters a comma.

The \\{FinishPrefix} method pushes the \\{gLastType} global variable
to the \\{gStructPrefixes} state variable.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPrefix;
begin
   gStructPrefixes.Insert(gLastType);
end;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessStructureSymbol;
var lFormatNr: integer;
begin
   gConstructorNr:=0;
   gPatternPos:=CurPos;
   if CurWord.Kind = StructureSymbol then gConstructorNr:=CurWord.Nr;
   lFormatNr:=gFormatsColl.CollectPrefixForm('J',gConstructorNr,1);
   gParamNbr:=0;
   gParams:=nil;
end;

@ When the Parser has just finished parsing the ancestors to a
structure, but has not parsed the visible arguments. Then the Parser
prepares for reading the visible arguments and then the fields by
invoking this method.
This initializes the \\{gStructFields} state variable as well as
the \\{gFieldsNbr} state variable.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gFieldsNbr:integer;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartFields;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.CollectPrefixForm('L',gConstructorNr,gParamNbr);
   in_AggrPattern:=true;
   gStructFields:=new(PList,Init(0));
   gFieldsNbr:=0;
end;

@ The Parser has just encountered the end structure bracket
(``\texttt{\#)}'') token, so we want to add the format to
the \\{gFormatsColl} dictionary.

@<Extended item implementation@>=
procedure @? extItemObj.FinishFields;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.CollectPrefixForm('G',gConstructorNr,gFieldsNbr);
end;

@ Recall that each field-segment looks like
$$\<Field-Segment> ::= \<Selector-Symbol>\ \LB\hbox{\texttt{","} } \<Selector-Symbol>\RB\ \<Specification>$$
Before parsing the field-segment, the \\{StartAggrPattSegment} is
invoked. 

@<Local variables for parser additions@>=
  @! gStructFieldsSegment: PList;
  @! gSgmPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartAggrPattSegment;
begin
   gStructFieldsSegment:=new(Plist,Init(0));
   gSgmPos:=CurPos;
end;

@ For each selector-symbol the Parser encounters, it invokes
the \\{ProcessField}. 

@<Extended item implementation@>=
procedure @? extItemObj.ProcessField;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.CollectPrefixForm('U',CurWord.Nr,1);
   gStructFieldsSegment^.Insert(new(FieldSymbolPtr,Init(CurPos,CurWord.Nr)));
   inc(gFieldsNbr);
end;

@ After each field has been parsed, the Parser invokes this method to
update the \\{gStructFields} will push a new field segment object onto it.

@<Extended item implementation@>=
procedure @? extItemObj.FinishAggrPattSegment;
begin
   gStructFields.Insert(new(FieldSegmentPtr,Init(gSgmPos,gStructFieldsSegment,gLastType)));
end;

@* [s] Processing remaining statements.
\node{Processing schemes.}
Most of these methods are used in parsing a scheme block
(\section\xref{SchemeBlock:parser.pas}). It will be useful to examine
that function to see where these methods are invoked.

When the Parser starts a new scheme,
several state variables need to be reset. The \\{gSchemeIdNr} is
populated by the \\{GetIdentifier} (\section\xref{GetIdentifier}) procedure,
the \\{gSchemeIdPos} is assigned the current position, and
the \\{gSchemeParams} should be allocated to an empty list.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessSchemeName;
begin
   gSchemeIdNr:=GetIdentifier;
   gSchemeIdPos:=CurPos;
   gSchemeParams:=new(PList,Init(0));
end;

@ A scheme qualification segment looks like, for predicates:
$$\<Variable>\ \LB\ \hbox{ \texttt{","} } \<Variable>\ \RB\ \hbox{\texttt{"["}}
[\<Type-Expression-List>] \hbox{\texttt{"]"}}$$
And for functors:
$$\<Variable>\ \LB\ \hbox{ \texttt{","} } \<Variable>\ \RB\ \hbox{ \texttt{"("} } [\<Type-Expression-List>] \hbox{ \texttt{")"}}$$
When the comma-separated list of identifiers have all been read, but
before either ``\texttt{(}'' or ``\texttt{[}'' has been discerned, the
Parser invokes \\{StartSchemeQualification}.

This will assign the current word kind to \\{gSubItemKind}, and then
initialize the \\{gTypeList} to 4 items.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gTypeList: MList;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartSchemeQualification;
begin
   gSubItemKind:=CurWord.Kind;
   gTypeList.Init(4);
end;

@ After the type-list has been parsed, but before the closing
parentheses or bracket has been encountered, the Parser invokes
the \\{FinishSchemeQualification} method. This assigns the current
position to the \\{gSubItemPos}.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gSubItemPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.FinishSchemeQualification;
begin
   gSubItemPos:=CurPos
end;

@ Starting a scheme segment describes the situation where we
are \emph{just about} to start parsing the comma-separated list of
identifiers for the scheme parameters. This just assigns the current
position to the \\{gSubItemPos}, then initializes \\{gSchVarIds} to 2 spots.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gSchVarIds: MList;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartSchemeSegment;
begin
   gSubItemPos:=CurPos;
   gSchVarIds.Init(2);
end;

@ After parsing the identifier for an entry in the comma-separated
list of scheme variables, the Parser invokes \\{ProcessSchemeVariable}
to add the recently parsed identifier to the \\{gSchVarIds} state
variable. 

@<Extended item implementation@>=
procedure @? extItemObj.ProcessSchemeVariable;
begin
   gSchVarIds.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end;

@ Once the list of scheme variables and their type specification has
been parsed, then the Parser invokes the \\{FinishSchemeSegment} method.
This just turns the \\{gSchVarIds} list into a Predicate segment or a
Functor segment, using the type list the Parser just finished parsing.

@<Extended item implementation@>=
procedure @? extItemObj.FinishSchemeSegment;
begin
   case gSubItemKind of
      sy_LeftParanthesis:
         begin
            gSchemeParams.Insert(new(FunctorSegmentPtr,Init(gSubItemPos,
                                                            new(PList,MoveList(gSchVarIds)),
                                                            new(PList,MoveList(gTypeList)),gLastType)));
         end;
      sy_LeftSquareBracket:
         begin
            gSchemeParams.Insert(new(SchemeSegmentPtr,Init(gSubItemPos,PredicateSegment,
                                                           new(PList,MoveList(gSchVarIds)),
                                                           new(PList,MoveList(gTypeList)))));
         end;
   endcases;
end;

@ The ``scheme thesis'' is the formula statement of the
scheme. Informally, a scheme looks like:
$$ \hbox{\texttt{scheme} }\LB\<Scheme-Parameters>\RB\ \<Scheme-thesis>\ \hbox{\texttt{"provided"}}\ \<Scheme-premises>$$
This means the \\{gLastFormula} state variable contains the scheme's
thesis. But the Parser has not yet started the list of premises. This
is when the Parser invokes the \\{FinishSchemeThesis} method, which
assigns the \\{gLastFormula} to \\{gSchemeConclusion}, then allocates
a new empty list for the \\{gSchemePremises}.

@<Extended item implementation@>=
procedure @? extItemObj.FinishSchemeThesis;
begin
   gSchemeConclusion:=gLastFormula;
   gSchemePremises:=new(Plist,Init(0));
end;

@ The premises for a scheme consists of finitely many formulas
separated by ``\texttt{and}'' keywords. The Parser enters into a loop
invoking this method \emph{after} parsing the formula
but \emph{before} checking the next word is ``\texttt{and}'' 
(and iterating loop). We just need to push the formula onto
the \\{gSchemePremises} list.

@<Extended item implementation@>=
procedure @? extItemObj.FinishSchemePremise;
begin
   gSchemePremises^.Insert(new(PropositionPtr,
                               Init(nLabel,
                                    gLastFormula,nPropPos)));
end;

@ \node{Reserved variables.} These methods are invoked only when the
Parser parses a reservation (\section\xref{Reservation:parser.pas}). A
``reservation segment'' refers to the comma-separated list of
variables and the type.

Starting a reservation segment allocates a new (empty) list
for \\{gResIdents}, and assigns the \\{gResPos} to the current
position. Each variable encountered in the comma-separated list of
variables is appended to the \\{gResIdents} list using
the \\{ProcessReservedIdentifier} method.

Mizar treats each reservation segment as a separate statement. So
there is no difference between:
\smallbreak
{\advance\leftskip3pc\obeylines\parindent=0pt\tt
reserve G for Group, x,y,z for Element of G;
\par}
\smallbreak\noindent%
\dots and\dots
\smallbreak
{\advance\leftskip3pc\obeylines\parindent=0pt\tt
reserve G for Group;

reserve x,y,z for Element of G;
\par}
\smallbreak\noindent%
Finishing a reservation mutates both the \\{gLastWSItem}
and \\{gLastWSBlock} global variables. Specifically, we allocate a new
reservation \\{Item}, then update \\{gLastWSItem} to point to it. The
caller's \\{nLastWSItem} is updated to point to it, too. We assign the
content of this newly allocated reservation \\{Item} based on
the \\{gResIdents} list. We insert this \\{Item} to the end of
the \\{gLastWSBlock}'s items.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
   @!gResIdents: PList;
   @!gResPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartReservationSegment;
begin
   gResIdents:=new(Plist,Init(0));
   gResPos:=CurPos;
end; @#

procedure @? extItemObj.ProcessReservedIdentifier;
begin
   gResIdents^.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end; @#

procedure @? extItemObj.FinishReservationSegment;
begin
   gLastWSItem:=gWsTextProper^.NewItem(itReservation,gResPos);
   nLastWSItem:=gLastWSItem;
   gLastWSItem^.nContent:=new(ReservationSegmentPtr,Init(gResIdents,gLastType));
   gLastWSItem^.nItemEndPos:=PrevPos;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
end;

@ Both ``\texttt{defpred}'' and ``\texttt{deffunc}''
invokes \\{StartPrivateDefiniendum} to initialize the \\{gTypeList},
store the identifier in the \\{gPrivateId}, and assign the current
position to the \\{gPrivateIdPos}. Further, |dol_Allowed| 
is toggled to \\{true} --- placeholder variables are going to be
allowed in the type declarations of the private functor or private
predicate (for example ``\texttt{defpred Foo[set, Element of \$1]}'').

@<Global variables introduced in \texttt{parseraddition.pas}@>=
   @!gPrivateId: Integer;
   @!gPrivateIdPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartPrivateDefiniendum;
begin
   gPrivateId:=GetIdentifier;
   gPrivateIdPos:=CurPos;
   dol_Allowed:=true;
   gTypeList.Init(4);
end;

@ Reading a ``type list'' (for scheme parameters or for private
definitions) loops over reading a type, then pushing it onto
the \\{gTypeList}. The parser delegates that latter ``push work'' to
the \\{FinishLocusType} method.

@<Extended item implementation@>=
procedure @? extItemObj.FinishLocusType;
begin
   gTypeList.Insert(gLastType);
end;

@ The life-cycle of expressions is a little convoluted. The \\{Item}
will allocate a new \\{extExpression} object and assign it to
the \\{gExpPtr}. Later, almost always, the \\{gExpPtr} will invoke a
method to create a subexpression. This subexpression will be
populated, then the \\{gLastTerm} (or \\{gLastFormula}) will be
updated to point to this subexpression object. The expression object
will be freed.

\label{extItemObj.CreateExpression}
@<Extended item implementation@>=
procedure @? extItemObj.CreateExpression(fExpKind:ExpKind);
begin
   gExpPtr:=new(extExpressionPtr,Init(fExpKind));
end;

@ Recall the ``set'' statement is of the form
$$\hbox{\texttt{"set"} } \<Variable> \hbox{ \texttt{"="} } \<Term>\ \LB\ \hbox{\texttt{","} } \<Variable> \hbox{ \texttt{"="} } \<Term>\ \RB$$
The Parser parses this as a loop of assignments of terms to
identifiers. Before iterating, the Parser invokes
the \\{FinishPrivateConstant} method. This allocates a new item for
the constant definition, then assigns it to the \\{gLastWSItem} and to
the caller's \\{nLastWSItem} field. Then the content for the new item
is allocated to be a constant definition object using
the \\{VariablePtr} state variable and the \\{gLastTerm} state
variable. The \\{gLastBlock} global variable pushes the new constant
definition item to its contents.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPrivateConstant;
begin
   gLastWSItem:=gWsTextProper^.NewItem(itConstantDefinition,nItemPos);
   nLastWSItem:=gLastWSItem;
   gLastWSItem^.nContent:=
      new(ConstantDefinitionPtr,
          Init(new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),gLastTerm));
   gLastWSItem^.nItemEndPos:=PrevPos;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
   nItemPos:=CurPos;
end;

@ When the Parser is about to start parsing an assignment
``\<Variable> \texttt{=} \<Term>'' in a ``\texttt{set}'' statement,
the Parser invokes this method. The caller assigns the \\{gPrivateId}
state variable to be the result of \\{GetIdentifier}, and
the \\{gPrivateIdPos} state variable to be the current position.

@<Extended item implementation@>=
procedure @? extItemObj.StartPrivateConstant;
begin
   gPrivateId:=GetIdentifier;
   gPrivateIdPos:=CurPos;
end;

@ For a ``\texttt{defpred}'' and a ``\texttt{deffunc}'', before
parsing the definiens, we need to set the |dol_Allowed| global
variable to true (to allow placeholder variables).

@<Extended item implementation@>=
procedure @? extItemObj.StartPrivateDefiniens;
begin
   dol_Allowed:=true;
end;

@ After parsing the definiendum term for a ``\texttt{deffunc}'', the
Parser invokes this \\{FinishPrivateFuncDefinienition} method. This
assigns the contents of the caller to a \WSM/ private functor
definition syntax tree.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPrivateFuncDefinienition;
begin
   nLastWSItem^.nContent:=
      new(PrivateFunctorDefinitionPtr,
          Init(new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),
               new(PList,MoveList(gTypeList)),gLastTerm));
end;

@ When finishing the definiendum formula for a ``\texttt{defpred}'',
the Parser invokes this \\{FinishPrivatePredDefinienition} method.

@<Extended item implementation@>=
procedure @? extItemObj.FinishPrivatePredDefinienition;
begin
   nLastWSItem^.nContent:=
      new(PrivatePredicateDefinitionPtr,
          Init(new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),
               new(PList,MoveList(gTypeList)),gLastFormula));
end;

@ \node{Reconsider statements.}

@<Extended item implementation@>=
procedure @? extItemObj.ProcessReconsideredVariable;
begin
   gPrivateId:=GetIdentifier;
   gPrivateIdPos:=CurPos;
end; @#

procedure @? extItemObj.FinishReconsideredTerm;
begin
   gReconsiderList^.Insert(new(TypeChangePtr,
                               Init(Equating,new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),gLastTerm)));
end;

@ This is invoked when parsing a private item which is a
``\texttt{reconsider}'' statement.

@<Extended item implementation@>=
procedure @? extItemObj.FinishDefaultTerm;
begin
   gReconsiderList^.Insert(new(TypeChangePtr,Init(VariableIdentifier,
                                                  new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),nil)));
end;

@ When the Parser finishes parsing a formula in
``\texttt{consider} \<Segment> \texttt{such that} \<Formula> $\LB$\texttt{and} \<Formula>$\RB$'',
the Parser invokes the \\{FinishCondition} method. This checks
that \\{gPremises} has been allocated, then pushes a new labeled
formula into it.

@<Extended item implementation@>=
procedure @? extItemObj.FinishCondition;
begin
   if gPremises = nil then
      gPremises:=new(PList,Init(0));
   gPremises^.Insert(new(PropositionPtr,
                         Init(nLabel,
                              gLastFormula,nPropPos)));
end;

@ In statements of the form
$$\texttt{assume\ } \<Formula>\texttt{;}$$
Or of the form
$$\texttt{assume\ } \<Formula> \texttt{\ and\ } \<Formula> \texttt{\ and\ } \dots \texttt{\ and\ } \<Formula>\texttt{;}$$
After each formula parsed, the Parser invokes
the \\{FinishHypothesis}. This just inserts a new labeled formula into
the \\{gPremises} state variable, when the \\{gPremises} state
variable is not |nil|.

\label{extItemObj.FinishHypothesis}

@<Extended item implementation@>=
procedure @? extItemObj.FinishHypothesis;
begin
   if gPremises <> nil then
      gPremises^.Insert(new(PropositionPtr,
                            Init(nLabel,
                                 gLastFormula,nPropPos)));
end;

@ \node{``Take'' statements.} For statements of the form
$$\texttt{take\ }\<Variable>\texttt{\ =\ }\<Term>\texttt{;}$$
The Parser invokes the \\{ProcessExemplifyingVariable} method, then
parses the term, and then constructs the AST by invoking \\{FinishExemplifyingVariable}.

Finishing a ``\texttt{take}'' statement
mutates both the \\{gLastWSItem} and the \\{gLastWSBlock} global variables.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessExemplifyingVariable;
begin
   gPrivateId:=GetIdentifier;
   gPrivateIdPos:=CurPos;
end; @#

procedure @? extItemObj.FinishExemplifyingVariable;
begin
   gLastWSItem:=gWsTextProper^.NewItem(itExemplification,nItemPos);
   nLastWSItem:=gLastWSItem;
   gLastWSItem^.nContent:=new(ExamplePtr,Init(new(VariablePtr,
                                                  Init(gPrivateIdPos,gPrivateId)),gLastTerm));
   gLastWSItem^.nItemEndPos:=PrevPos;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
   nItemPos:=CurPos;
end;

@ In statements of the form
$$\texttt{take\ }\<Term>\texttt{;}$$
the Parser begins by invoking \\{StartExemplifyingTerm}, parses the
term, then \\{FinishExemplifyingTerm}.

@<Extended item implementation@>=
procedure @? extItemObj.StartExemplifyingTerm;
begin
   if (CurWord.Kind=Identifier) and extBlockPtr(gBlockPtr)^.nInDiffuse and
         ((AheadWord.Kind=sy_Comma) or (AheadWord.Kind=sy_Semicolon)) then
   begin
      gPrivateId:=GetIdentifier;
      gPrivateIdPos:=CurPos;
   end
   else gPrivateId:=0;
end; @#

procedure @? extItemObj.FinishExemplifyingTerm;
begin
   gLastWSItem:=gWsTextProper^.NewItem(itExemplification,nItemPos);
   nLastWSItem:=gLastWSItem;
   if gPrivateId <> 0 then
      gLastWSItem^.nContent:=
         new(ExamplePtr,Init(new(VariablePtr,Init(gPrivateIdPos,gPrivateId)),nil))
   else
      gLastWSItem^.nContent:=new(ExamplePtr,Init(nil,gLastTerm));
   gLastWSItem^.nItemEndPos:=PrevPos;
   gLastWSBlock^.nItems.Insert(gLastWSItem);
   nItemPos:=CurPos;
end;

@ When the Parser examines the correctness conditions
(\section\xref{Correctness:parser.pas}), it loops over the correctness
conditions and justifications. Afterwards, it invokes
the \\{ProcessCorrectness} method, which tests that the Parser is not
current looking at a correctness keyword. Then it tests if
|gCorrectnessConditions| is empty or |AxiomsAllowed| (in which case,
correctness has been satisfies, so the Parser moves happily
along). But if $\\{gCorrectnessConditions}\neq\emptyset$ or axioms are
not allowed, then a 73 error is raised.

@:Error, 073}{Error, 73@>

\label{extItemObj.ProcessCorrectness}

@<Extended item implementation@>=
procedure @? extItemObj.ProcessCorrectness;
begin
   if CurWord.Kind <> sy_Correctness then
      if (gCorrectnessConditions <> []) and not AxiomsAllowed then
         Error(gDefPos,73);
end;

@ A ``construction type'' appears in a redefinition where the type is
redefined. In such a situation, we need to add ``\texttt{coherence}''
as a correctness condition. The \\{StartConstructionType} handles this
task. 

\label{extItemObj.StartConstructionType}

@<Extended item implementation@>=
procedure @? extItemObj.StartConstructionType;
begin
   if gRedefinitions and (CurWord.Kind = sy_Arrow) then
      include(gCorrectnessConditions,syCoherence);
end;

@ This is used in the Parser's \\{ProcessLab} procedure. Really, all
the work is being done here: the \\{nLabel} field of the caller is
assigned to a newly allocated \\{Label} object.

\label{extItemObj.ProcessLabel}

@<Extended item implementation@>=
procedure @? extItemObj.ProcessLabel;
begin
   nLabelIdNr:=0;
   nLabelIdPos:=CurPos;
   if (CurWord.Kind=Identifier) and (AheadWord.Kind=sy_Colon) then
      nLabelIdNr:=CurWord.Nr;
   nLabel:=new(LabelPtr,Init(nLabelIdNr,nLabelIdPos));
end;

@ A regular statement is either a ``diffuse'' statement (which occurs
with the ``\texttt{now}'' keyword) or else it's a ``compact'' statement.

@<Extended item implementation@>=
procedure @? extItemObj.StartRegularStatement;
begin
   if CurWord.Kind=sy_Now then
      nRegularStatementKind:=stDiffuseStatement
   else nRegularStatementKind:=stCompactStatement;
end;

@ If the Parser encounters a colon after the copula, then it invokes
this method to construct a label for the Definiens.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
   @!gDefLabel: LabelPtr;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessDefiniensLabel;
begin
   gDefLabId:= 0;
   gDefLabPos:=CurPos;
   if (CurWord.Kind=Identifier) and (AheadWord.Kind=sy_Colon) then
      gDefLabId:= CurWord.Nr;
   gDefLabel:= new(LabelPtr,Init(gDefLabId,gDefLabPos));
end;

@ The Parser, having encountered ``\texttt{from}'' and a non-MML
reference, tries to treat the identifier as the label for a scheme
declared in the current article. The \\{nInference} field would be
a \\{SchemeJustification} object, so we just populate
its \\{nSchemeIdNr} and position fields.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessSchemeReference;
begin
   if CurWord.Kind = Identifier then
   begin
      SchemeJustificationPtr(nInference)^.nSchemeIdNr:=CurWord.Nr;
      SchemeJustificationPtr(nInference)^.nSchemeInfPos:=CurPos;
   end;
end;

@ When a ``\texttt{by}'' refers to a theorem or definition from an
article in the MML, the Parser invokes the \\{StartLibraryReference} method.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gTHEFileNr:integer;

@ @<Extended item implementation@>=
procedure @? extItemObj.StartLibraryReferences;
begin
   gTHEFileNr:=CurWord.Nr;
end;

@ The Parser has already encountered a ``\texttt{from}'' and then an
MML article identifier. Before continuing to parse the scheme number,
the Parser invokes this method to initialize the relevant state variables.

@<Extended item implementation@>=
procedure @? extItemObj.StartSchemeLibraryReference;
begin
   gTHEFileNr:=CurWord.Nr;
end;

@ For references to labels found in the article being processed
(``private references''), this method is invoked.

@<Extended item implementation@>=
procedure @? extItemObj.ProcessPrivateReference;
begin
   SimpleJustificationPtr(nInference)^.nReferences^.Insert(new(LocalReferencePtr,
                                                               Init(GetIdentifier,CurPos)));
end;

@ When using a definition from an MML article in a scheme reference
(something like\hfill\break
``\texttt{from MyScheme(ARTICLE:def 5,\dots)}''), well, the Parser
stores this fact in a state
variable \\{gDefinitional}. The \\{ProcessDef} method populates this
state variable correctly.

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gDefinitional: boolean;

@ @<Extended item implementation@>=
procedure @? extItemObj.ProcessDef;
begin
   gDefinitional:=(CurWord.Kind = ReferenceSort) and (CurWord.Nr = ord(syDef))
end;

@ When accumulating the references in a Scheme-Justification, and a
reference is from an MML article, \\{ProcessTheoremNumber} transforms
it into a newly allocated reference object. The
caller's \\{nInference} then adds the newly allocated object to
its \\{nReferences} collection. 

@^Error, 146@>

@<Extended item implementation@>=
procedure @? extItemObj.ProcessTheoremNumber;
var lRefPtr: ReferencePtr;
begin
   if CurWord.Kind <> Numeral then exit;
   if CurWord.Nr = 0 then
   begin
      ErrImm(146);
      exit
   end;
   if gDefinitional then
      lRefPtr:=new(DefinitionReferencePtr, Init(gTHEFileNr,CurWord.Nr,CurPos))
   else
      lRefPtr:=new(TheoremReferencePtr, Init(gTHEFileNr,CurWord.Nr,CurPos));
   SimpleJustificationPtr(nInference)^.nReferences^.Insert(lRefPtr);
end;

@ When a Scheme-Justification uses a local reference, the Parser
delegates the work to the \\{Item}'s \\{ProcessSchemeNumber} method. This updates
the caller's \\{nInference} field.

@^Error, 146@>

@<Extended item implementation@>=
procedure @? extItemObj.ProcessSchemeNumber;
begin
   if CurWord.Kind <> Numeral then exit;
   if CurWord.Nr = 0 then
   begin
      ErrImm(146);
      exit
   end;
   with SchemeJustificationPtr(nInference)^ do
   begin
      nSchFileNr:=gTHEFileNr;
      nSchemeIdNr:=CurWord.Nr;
      nSchemeInfPos:=PrevPos;
   end;
end;

@ This appears when the Parser starts its \\{Justification}
(\section\xref{Justification:parser.pas}) procedure, or in the
\\{RegularStatement}
(\section\xref{RegularStatement:parser.pas}) procedure.

This clears the \\{nInference}, reassigning it to the |nil| pointer.

For nested ``\texttt{proof}'' blocks, check if the `check proofs'
(``\texttt{::\$P+}'') pragma has been enabled --- if so, just set the
caller's \\{nInference} to be a new Justification object with a
`proof' tag. Otherwise, we're skipping the proofs, so
set \\{nInference} to be the `skipped' justification.

@<Extended item implementation@>=
procedure @? extItemObj.StartJustification;
begin
   nInference:=nil;
   if CurWord.Kind = sy_Proof then
   begin
      if ProofPragma then
         nInference:=new(JustificationPtr,Init(infProof,CurPos))
      else
         nInference:=new(JustificationPtr,Init(infSkippedProof,CurPos))
   end;
end;

@ A simple justification is either a Scheme-Justification
(``\texttt{from}\dots''), a Straightforward-Justification
(``\texttt{by}\dots''), or\dots somethign else?

@<Extended item implementation@>=
procedure @? extItemObj.@!StartSimpleJustification;
begin
   case CurWord.Kind of
      sy_From:
         nInference:=new(SchemeJustificationPtr,Init(CurPos,0,0));
      sy_By:
         with extBlockPtr(gBlockPtr)^ do
         nInference:=new(StraightforwardJustificationPtr,Init(CurPos,nLinked,nLinkPos));
   othercases
      with extBlockPtr(gBlockPtr)^ do
         nInference:=new(StraightforwardJustificationPtr,Init(PrevPos,nLinked,nLinkPos));
   endcases;
end;

@ We should update the \\{nInference} field's sort to be \\{infError}
when, well, the inference is an error (e.g., the Parser is in panic
mode). We should set the \\{gBlockPtr}'s \\{nLinked} field to false
when we just added a straightforward justification (or an erroneous
justification). 

@d is_inference_error == not StillCorrect or@|
       ((CurWord.Kind <> sy_Semicolon) and (CurWord.Kind <> sy_DotEquals)) or@|
       ((nInference^.nInfSort = infStraightforwardJustification) and (byte(nLinked) > byte(nLinkAllowed))) or@|
       ((nInference^.nInfSort = infSchemeJustification) and (SchemeJustificationPtr(nInference)^.nSchemeIdNr = 0))

@<Extended item implementation@>=
procedure @? extItemObj.@!FinishSimpleJustification;
begin
   with extBlockPtr(gBlockPtr)^ do
   begin
      if is_inference_error
      then nInference^.nInfSort:=infError;
   end;
   if (nInference^.nInfSort = infStraightforwardJustification) or (nInference^.nInfSort = infError)
   then extBlockPtr(gBlockPtr)^.nLinked:=false;
end;

@ For iterative equalities, we should recall that it looks like
\smallbreak
{\advance\leftskip5pc\tt\obeylines\parindent=0pt
LHS = RHS \<Justification>

\ \ \ .= RHS2

\ \ \ .= \dots;\par}

\smallbreak\noindent%
This matters because, well, when the Parser has parsed ``\texttt{LHS = RHS} \<Justification>'',
the Parser believes it is a compact statement. Until the Parser looks
at the next token, it does not know whether this is a
Compact-Statement or an iterated equality. The \\{FinishCompactMethod}
peeks at the token, and when the token is an iterated equality
(``\texttt{.=}'') updates the caller's fields as well as initialize
the \\{gIterativeLastFormula}, \\{gIterativeSteps}, and \\{gInference}
state variables. The \\{gBlockPtr} is updated to make its \\{nLinked}
field false.

@<Extended item implementation@>=
procedure @? extItemObj.@!FinishCompactStatement;
begin
   if CurWord.Kind = sy_DotEquals then
   begin
      gIterativeLastFormula:=gLastFormula;
      nRegularStatementKind:=stIterativeEquality;
      extBlockPtr(gBlockPtr)^.nLinked:=false;
      gIterativeSteps:=new(PList,Init(0));
      gInference:=nInference;
   end;
end;

@ Every time the Parser encounters the ``\texttt{.=}'' token, it
immediately invokes the \\{StartIterativeStep} method. This just
updates the \\{gIterPos} state variable to the current position.

@<Local variables for parser additions@>=
  @! gIterPos: Position;

@ @<Extended item implementation@>=
procedure @? extItemObj.@!StartIterativeStep;
begin
   gIterPos:=CurPos; @+
end;

@ Right before the Parser iterates the loop checking if
``\texttt{.=}'' is the next token for an iterative equation, the
Parser invokes the \\{FinishIterativeStep} method. This just adds a
new \\{IterativeStep} object, an AST node representing the preceding
``\texttt{.= RHS by} \<Justification>''.

@<Extended item implementation@>=
procedure @? extItemObj.@!FinishIterativeStep;
begin
   gIterativeSteps^.Insert(new(IterativeStepPtr,Init(gIterPos,gLastTerm,nInference)));
end;

@ In a definition, after the Parser finishes parsing the definiens, we
construct the AST node for it with the \\{FinishDefiniens} method.

For each copula (``\texttt{means}'' and ``\texttt{equals}''), the
algorithm is the same: if we just had a definition-by-cases, then
store the ``\texttt{otherwise}'' clause in \\{lExp} and assign
the \\{gDefiniens} state variable to a newly allocated conditional
definiens object. If the definiens is not a definition-by-cases (i.e.,
it's a ``simple'' definition), then just assign \\{gDefiniens} a newly
allocated \\{SimpleDefiniens} object.

For functor definitions (not redefinitions),
the \\{gCorrectnessConditions} are assigned here.

@^Correctness Conditions@>

@<Extended item implementation@>=
procedure @? extItemObj.@!FinishDefiniens;
var lExp: DefExpressionPtr;
begin
   case gDefiningWay of
      dfMeans:@|@/
         if gPartialDefs <> nil then
         begin
            lExp:=nil;
            if gOtherwise <> nil then
               lExp:=new(DefExpressionPtr,Init(exFormula,gOtherwise));
            gDefiniens:=new(ConditionalDefiniensPtr,Init(gMeansPos,gDefLabel,gPartialDefs,lExp))
         end
         else
            gDefiniens:=new(SimpleDefiniensPtr,Init(gMeansPos,gDefLabel,
                                                    new(DefExpressionPtr,Init(exFormula,gLastFormula))));
      dfEquals:@|@/
         if gPartialDefs <> nil then
         begin
            lExp:=nil;
            if gOtherwise <> nil then
               lExp:=new(DefExpressionPtr,Init(exTerm,gOtherwise));
            gDefiniens:=new(ConditionalDefiniensPtr,Init(gMeansPos,gDefLabel,gPartialDefs,lExp))
         end
         else
            gDefiniens:=new(SimpleDefiniensPtr,Init(gMeansPos,gDefLabel,new(DefExpressionPtr,Init(exTerm,gLastTerm))));
   endcases;
   if not gRedefinitions and (nItemKind = itDefFunc) then
   begin
      if gDefiningWay = dfMeans then
         gCorrectnessConditions:=[syExistence,syUniqueness]
      else if gDefiningWay = dfEquals then
         gCorrectnessConditions:=[syCoherence];
   end;
end;


@* [S] Extended subexpression class.
\node{Aside: refactoring.}
We should probably refactor a private procedure \\{PushTermStack} to
push a new term onto the term stack, and a private
function \\{PopTermStack} to return the top of the term stack (and
mutate the term stack), and possibly a \\{ResetTermStack} procedure
(which will clear the term stack and possibly the objects stored in it?).

We see that \\{TermNbr} is
decremented when popping the \\{Term} stack (via \\{FinishTerm});
when \\{FinishQualifyingFormula} is invoked, it decrements the \\{TermNbr};
when \\{FinishAttributiveFormula} is invoked, it decrements the \\{TermNbr};
but these latter two methods can (and should) be refactored to use
the \\{FinishTerm} to pop the term stack and decrement the \\{TermNbr}
state variable.

Assigning the \\{TermNbr} occurs
when \\{CreateArgs} method is invoked;
the \\{InsertIncorrBasic} method resets the \\{TermNbr} to the \\{nTermBase};
the \\{ProcessAtomicFormula}, when a 157 error is raised, will reset
the \\{TermNbr} to the \\{nTermBase};
when the constructor for an \\{extExpression} object is invoked, it
resets the \\{TermNbr} to zero (which happens in
the \\{extItem}'s \\{CreateExpression} method---which occurs
frequently enough to be a worry).

The only time when the \\{TermNbr} is incremented is when we push a
new term onto the \\{Term} stack.


@
There is a comment in Polish ``teraz jest to kolekcja
MultipleTypeExp'', which Google translates to ``now it is a
MultipleTypeExp collection''. I have made this replacement in the code
below, prefixed with a ``+'' sign (to distinguish it from the other
comment already in English).

Also note: the \\{nRestriction} refers to the subformula in a
universally quantified formula
$$\hbox{\texttt{for }}\<Variables>\hbox{ \texttt{st} }\<Restriction>\hbox{ \texttt{holds} }\dots$$

\label{extSubexprObj:class}

@d arg_type == record Start,Length: integer; end
@d func_type == record Instance,SymPri: integer; FuncPos: Position; end

@<Methods implemented by subclasses of |SubexpObj|@>=

@ @<Extended subexpression class declaration@>=
   @! extSubexpPtr = ^extSubexpObj; @/
   @! extSubexpObj = object(SubexpObj) @t\1@> @/
      @! nTermBase, @! nRightArgBase: integer;
      @! nSubexpPos,@! nNotPos,@! nRestrPos: Position;
      @! nQuaPos:Position;
      @! nSpelling: Integer;
      @! nSymbolNr, @!nRSymbolNr: integer;
      @! nConnective, @! nNextWord: TokenKind;
      @! nModeKind: TokenKind;
      @! nModeNr: integer;
      @! nRightSideOfPredPos: Position;
      @! nMultipredicateList:MList; @#
      
      @! nSample: TermPtr; {for Fraenkel terms}
      @! nAllPos: Position;
      @! nPostQualList: MList; {+ now it is a MultipleTypeExp collection}
      @! nQualifiedSegments: MList;
      @! nSegmentIdentColl: MList; {quantified variables, keeps spellings of vars}
      @! nSegmentPos: Position; @#

      @! nFirstSententialOperand: FormulaPtr;
      @! nRestriction: FormulaPtr; @#

      @! nAttrCollection: MList; @#

      @! nNoneOcc: boolean;
      @! nNonPos:Position;
      @! nPostNegated: boolean; @#

      @! nArgListNbr: integer; {position in a term (\section\xref{AppendFunc:parser.pas})}
      @! nArgList: array of arg_type;
      @! nFunc: array of func_type; @#

      constructor @? Init; @t\2@> @/

@t\4@> @<Methods implemented by subclasses of |SubexpObj|@>@t\2\2@>@;
   end;


@ The |TermNbr| is used to treat a list of terms as a stack data
structure. Specifically, the \\{Term} array is treated as a stack, and
the \\{TermNbr} is the index of the ``top'' of the stack.

@<Local variables for parser additions@>=
  @! TermNbr: integer;

@ @<Extended subexpression implementation@>=
{{\it Subexpressions handling}}

constructor @? extSubexpObj.Init;
const MaxArgListNbr = 20;
begin
   inherited Init;
   nRestriction:=nil;
   nTermBase:=TermNbr;
   nArgListNbr:=0;
   setlength(nArgList,MaxArgListNbr+1);
   setlength(nFunc,MaxArgListNbr+1);
   nArgList[0].Start:=TermNbr+1;
end;


@ When the Parser is about to parse a stack of attributes, either in a
registration or on a type, we need to initialize the appropriate state
variables. We also need the caller's \\{nAttrCollection} to be
initialized with an empty list.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartAttributes;
begin
   nAttrCollection.Init(0);
   gLastType:=nil;
end;

@ When the Parser expects an adjective, and the caller is used to
store the adjective or attribute, we need to check if it is
negated. This handles it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessNon;
begin
   nNoneOcc:=CurWord.Kind = sy_Non;
   nNonPos:=CurPos;
end;

@ \node{Pop arguments from term stack.} This will take some
parameter \\{aBase} and copy pointers to each element of |Term[aBase .. TermNbr]| into a new list. 
Then the \\{TermNbr} state variable is updated to be $\\{aBase}-1$.

This means that executing ``|list1 := CreateArgs(aBase); list2 := CreateArgs(aBase);|''
will have |list2 = nil|.

Bug: when |aBase <= 0|, this will set |TermNbr| to a negative number.

\label{CreateArgs}
@<Extended subexpression implementation@>=
function CreateArgs(aBase:integer): PList;
var k:integer;
lList: PList;
begin
   lList:=new(PList,Init(TermNbr-aBase));
   for k:=aBase to TermNbr do
      lList.Insert(Term[k]);
   TermNbr:=aBase-1;
   CreateArgs:=lList;
end;

@ The ``process (singular) attribute'' method is invoked in
the ``process (plural) attributes'' procedure (\section\xref{ProcessAttributes:parser.pas}), and in the \\{ATTSubexpression} procedure (\section\xref{ATTSubexpression}).
This method will be invoked when the Parser is looking at an attribute
token.

When there is no format recorded for such an attribute, then a 175
error will be raised.

This will allocate a new Adjective object, store it in
the \\{gLastAdjective} state variable, then append it to
the \\{nAttrCollection} field of the caller.

@^Error, 175@>

@<Global variables introduced in \texttt{parseraddition.pas}@>=
  @! gLastAdjective: AdjectiveExpressionPtr;

@ @<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessAttribute;
var lFormatNr:integer;
begin
   if CurWord.Kind = AttributeSymbol then
   begin
      lFormatNr:=gFormatsColl.LookUp_PrefixFormat('V',CurWord.Nr,TermNbr-nTermBase+1);
      if lFormatNr = 0 then {format not found!}
      begin
         gLastAdjective:=new(AdjectivePtr,Init(CurPos,0,CreateArgs(nTermBase+1)));
         Error(CurPos,175)
      end
      else
      begin
         gLastAdjective:=new(AdjectivePtr,Init(CurPos,CurWord.Nr,CreateArgs(nTermBase+1)));
         if nNoneOcc then
            gLastAdjective:=new(NegatedAdjectivePtr,Init(nNonPos,gLastAdjective));
      end;
   end
   else {needed for \\{ATTSubexpression} adjective cluster handling}
   begin
      gLastAdjective:=new(AdjectivePtr,Init(CurPos,0,CreateArgs(nTermBase+1)));
   end; @/
   nAttrCollection.Insert(gLastAdjective);
end;

@ These next next method is invoked before the Parser parses arguments
for an attribute.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartAttributeArguments;
begin
   nTermBase:=TermNbr;
end;

@ The next two methods are invoked after the Parser has finished
parsing the arguments for an attribute.

I am confused why there is
duplicate code here, and the naming conventions suggest
the \\{FinishAttributeArguments} method should be preferred.

\label{extSubexpObj.CompleteAttributeArguments}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.CompleteAttributeArguments;
begin
   nSubexpPos:=CurPos;
   nRightArgBase:=TermNbr;
end; @#

procedure @? extSubexpObj.FinishAttributeArguments;
begin
   nSubexpPos:=CurPos;
   nRightArgBase:=TermNbr;
end;

@ This allocates a new list of pointers, moves the
caller's \\{nAttrCollection} into the list, and updates the \\{gAttrColl}
state variable to point at them.

Again, this should be named \\{FinishedAdjectiveCluster} to be
consistent with the naming conventions seemingly adopted.

\label{extSubexpObj.CompleteAdjectiveCluster}
@<Extended subexpression implementation@>=
procedure @? extSubexpObj.CompleteAdjectiveCluster;
begin
   gAttrColl:=new(PList,MoveList(nAttrCollection));
end;

@ When the Parser works its way through a registration block, check
that the \\{TermNbr} points to not farther ahead than one more token 
ahead from the caller's \\{nTermBase} field. Raise an error if that
happens.

This method is only invoked in the Parser module's
the \\{RegisterCluster} (\section\xref{RegisterCluster:parser.pas}) procedure.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.CompleteClusterTerm;
begin
   if TermNbr-nTermBase > 1 then
   begin
      ErrImm(379);
      gLastTerm:=new(IncorrectTermPtr,Init(CurPos));
   end;
end;

@ A ``simple term'' appears to be a variable. This is used when the
Parser parses an identifier as a closed term
(\section\xref{GetClosedSubterm:identifier:parser.pas}). The state
variable |gLastTerm| is updated to point to a newly
allocated \\{SimpleTerm} AST node (\section\xref{ast:SimpleTerm}).

This method should probably be moved closer to the other methods
used when parsing terms.

\label{extSubexpObj.ProcessSimpleTerm}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessSimpleTerm;
begin
   gLastTerm:=new(SimpleTermPtr,Init(CurPos,GetIdentifier));
end;

@ \node{Qualified terms.} The Parser invokes \\{ProcessQua} when it is
looking directly at a ``\texttt{qua}'' token, specifically in
the \\{AppendQua} (\section\xref{AppendQua})
procedure. The \\{ProcessQua} method is used nowhere else. It is
solely responsible for ``marking the current position'' of the Parser,
and storing that in the caller's \\{nQuaPos} field.

\label{extSubexpObj.ProcessQua}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessQua;
begin
   nQuaPos:=CurPos
end;

@ The Parser invokes the \\{FinishedQualifiedTerm} method after
encountering a ``\texttt{qua}'' and after parsing the type. This
method constructs a new \\{QualifiedTerm} object reflecting the top of
the \\{Term} stack is taken ``\texttt{qua}'' the \\{gLastType}, and
the mutates the top of the \\{Term} stack to be this newly
allocated \\{QualifiedTerm} object.

This method does not push anything new to
the term stack, but it does mutate the \\{Term} stack.

This method is used nowhere else other than the Parser's \\{AppendQua}
(\section\xref{AppendQua}) procedure.

\label{extSubexpObj.FinishQualifiedTerm}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishQualifiedTerm;
begin
   Term[TermNbr]:=new(QualifiedTermPtr, Init(nQuaPos,Term[TermNbr],gLastType));
end;

@ Although the ``\texttt{exactly}'' reserved keyword is not used for
anything, the method for \\{ProcessExactly} marks the current position
and stores it in the caller's \\{nQuaPos}, then \emph{updates}
(\textbf{not} pushes) to the top of the term
stack by turning the top of the stack into an \\{ExactlyTerm} object.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessExactly;
begin
   nQuaPos:=CurPos;
   Term[TermNbr]:=new(ExactlyTermPtr, Init(nQuaPos,Term[TermNbr]));
end;

@ \node{Arguments to a term.} The \\{CheckTermLimit} procedure is a
``private helper function'' for the \\{FinishArgument} method.

@<Extended subexpression implementation@>=
procedure CheckTermLimit;
var l: integer;
begin
   if TermNbr >= length(Term) then
   begin
      l:=2*length(Term);
      setlength(Term,l);
   end;
end;

@ \node{Pushing the Term stack.}
This method pushes the \\{gLastTerm} state variable's contents to
the \\{Term} stack, mutating the \\{TermNbr} and \\{Term} module-local variables.

\label{extSubexpObj.FinishArgument}
@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishArgument;
begin
   CheckTermLimit;
   inc(TermNbr);
   Term[TermNbr]:=gLastTerm;
end;

@ \node{Pop the Term stack.} The evil twin to ``pushing'' an element
onto a stack, ``popping'' a stack removes the top element. We pop
the \\{Term} stack whenever we finish the term.

This is only used in \\{AppendFunc} (\section\xref{AppendFunc:parser.pas}).

This should probably check that the \\{Term} stack is not empty before
being invoked.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishTerm;
begin
   gLastTerm:=Term[TermNbr];
   dec(TermNbr);
end;

@* [s] Parsing Types.
When we start parsing a new type, we make sure the \\{gLastType}
state variable is not caching an old type. We assign it to be the |nil|
pointer. 

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartType;
begin
   gLastType:=nil;
end;

@ This is invoked only by the Parser's \\{RadixTypeSubexpression}
(\section\xref{RadixTypeSubexpression:parser.pas}) procedure. The
Parser delegates the work of storing the mode information to this
method. In turn, the caller's \\{nModeKind} field stores the current word's
token \\{Kind}, and the caller's \\{nModeNr} field stores the current
word's number. The Parser's current position is marked and stored in
the caller's \\{nSubexpPos} field.

But no state variables are mutated by this method.

\label{extSubexpObj.ProcessModeSymbol}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessModeSymbol;
begin
   nModeKind:=CurWord.Kind;
   nModeNr:=CurWord.Nr;
   if (CurWord.Kind = sy_Set) {?|and (AheadWord.Kind <> sy_Of)|?} then
      nModeKind:=ModeSymbol;
   nSubexpPos:=CurPos;
end;

@ The Parser has just finished parsing a type and its arguments ---
``\<Mode> \texttt{of} \<Term-list>'' or ``\<Structure> \texttt{over} \<Term-list>''.
The data has been accumulated into the caller, which will now be
constructed into an AST object. The newly allocated AST node will be
stored in the \\{gLastType} state variable.

If the caller is trying to construct a mode which does not match the
format recorded in the \\{gFormatsColl}, a 151 error will be raised.

Similarly, if the caller is trying to construct a structure which does
not match the format recorded in the \\{gFormatsColl}, a 185 error
will be raised.

@^Error, 151@>
@^Error, 185@>

This is invoked only by the Parser's \\{RadixTypeSubexpression}
(\section\xref{RadixTypeSubexpression:parser.pas}) procedure.
@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishType;
var lFormatNr: integer;
begin
   case nModeKind of
      ModeSymbol:
         begin
            lFormatNr:=gFormatsColl.LookUp_PrefixFormat('M',nModeNr,TermNbr-nTermBase);
            if lFormatNr=0 then Error(nSubexpPos,151); {format missing}
            gLastType:=new(StandardTypePtr,Init(nSubexpPos,nModeNr,CreateArgs(nTermBase+1)));
         end;
      StructureSymbol:
         begin
            lFormatNr:=gFormatsColl.LookUp_PrefixFormat('L',nModeNr,TermNbr-nTermBase);
            if lFormatNr = 0 then SemErr(185); {format missing}
            gLastType:=new(StructTypePtr,Init(nSubexpPos,nModeNr,CreateArgs(nTermBase+1)));
         end;
   othercases
   begin
      gLastType:=new(IncorrectTypePtr, Init(CurPos)); @+
   end;
   endcases;
end;

@ If the Parser has the misfortune of trying to make sense of a
malformed type expression, then with a heavy heart it invokes this
method to update the \\{gLastType} state variable to be an incorrect
type expression at the current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.InsertIncorrType;
begin
   gLastType:=new(IncorrectTypePtr, Init(CurPos));
end;

@ When the Parser encounters a qualifying formula
(``\<Term> \texttt{is} \<Type>'') or is parsing a type for a cluster
(the ``\texttt{cluster} \dots \texttt{for} \<Type>''), after parsing
the type, this method is invoked to \textbf{update} the \\{gLastType} state
variable to store the \\{ClusteredType} AST node (which decorates a
type --- the contents of \\{gLastType} at the time of calling --- with
a bunch of attributes).

The caller's \\{nAttrCollection} is transferred to the \\{gLastType}.
At the end of the method, the caller's \\{nAttrCollection} (array of
pointers) is freed. This does not free the objects referenced by the
pointers, however.

If |gLastType = nil|, then the Parser has somehow failed to parse the
type expression. An error should be raised.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.CompleteType;
var j: integer;
begin
   mizassert(5433,gLastType <> nil);
   if nAttrCollection.Count > 0 then
   begin
      gLastType:=new(ClusteredTypePtr,Init(gLastType^.nTypePos,
                                           new(PList,Init(nAttrCollection.Count)),gLastType));
      for j := 0 to nAttrCollection.Count-1 do
         ClusteredTypePtr(gLastType)^.nAdjectiveCluster^.Insert(PObject(nAttrCollection.Items^[j]));
      nAttrCollection.DeleteAll;
   end;
end;

@* [s] Parsing operator precedence.
Mario Carneiro's ``Mizar in Rust'' (\section6.2) gives an overview of
this parsing routine (see also his \texttt{mizar-rs/src/parser/miz.rs}
for the Rust version of the same code). It is a constrained
optimization problem. We shall take care to dissect this routine.
This appears to be where operator precedence, the \\{gPriority}
(\section\xref{gFormatsColl}) global variable, comes into play.


@ \node{Starting a ``long term''.}

We can observe that \\{nTermBase} is initialized upon construction to \\{TermNbr};
in \\{ProcessAtomicFormula} and \\{StartPrivateFormula} it is assigned to \\{TermNbr}.


\label{extSubexpObj.StartLongTerm}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartLongTerm;
begin
   nArgListNbr:=0;
   nArgList[0].Length:=TermNbr-nTermBase;
end;

@ \node{Malformed term errors.}

We should remind the reader, errors 165--175 are ``unknown functor format'',
errors 176 is ``unknown attribute format'', and error 177 is ``unknown
structure format''. Only when such an error occurs, the flow experiences a
|goto AfterBalance|.

For an example of a 168, 169 error:
\medbreak
{\obeylines\tt
for x being Nat

holds (id + x +) = x;
\par}
\medbreak\noindent%
For an example of a 170, 171 error (the first \texttt{0} will be
flagged 170, the second \texttt{0} will be flagged as 171):
\medbreak
{\obeylines\tt
for x being Nat

holds 0 0 + x = x;

\par}
\medbreak\noindent%
For an example of a 172, 173 error:
\medbreak
{\obeylines\tt
for x being Nat

holds x + / = x;\par}

\medbreak\noindent%
For an example of a 174, 175 error:

\medbreak
{\obeylines\tt
for x being Nat

holds x + (1,2) + x = x;\par}

@ We can recall that a ``generic'' term looks like an infixed operator
of the form
$$ (t^{(\ell)}_{1},\dots,t^{(\ell)}_{m})\;t\;(t^{(r)}_{1},\dots,t^{(r)}_{n}) $$
The parentheses are optional. Constants will have $m=n=0$ and look
like $()\;t\;()$. Function-like terms will have $m=0$ and look like
$()\;t\;(t^{(r)}_{1},\dots,t^{(r)}_{n})$.
The problem statement could be re-phrased as: given several infixed
terms without parentheses inserted anywhere, determine how to cluster
terms together.

@ The problem statement for constructing the syntax tree for a term is
something like the following: we have an expression of the form
$$ x^{(0)}_{1},\dots,x^{(0)}_{k_{0}}\;F_{1}\; x^{(1)}_{1},\dots,x^{(1)}_{k_{1}}\;F_{2}\;\cdots \;F_{n}\; x^{(n)}_{1},\dots,x^{(n)}_{k_{n}}$$
We want to produce a suitable binary tree with $F_{i}$ on the internal
nodes and the $(x^{(i)}_{j})_{j\leq k_{i}}$ on the leafs, respecting
precedence such that each $F_{i}$ is applied to the correct number of arguments.

Mario Carneiro noted (\arXiv{2304.08391}, \section6.2) the existence of an $O(n^{4})$ algorithm using
dynamic programming techniques. The trick is to compute the minimal
``cost'' [number of violations] for each substring of nodes
$F_{a}\cdots F_{b}$ for each $1\leq a\leq i\leq b\leq n$ with node
$F_{i}$ being the root of the subtree. There are $O(n^{3})$ such
subproblems, and they can be calculated from smaller subproblems in $O(n)$.
This might seem alarmingly large, but usually the terms in Mizar are
sufficiently small.

It is interesting to see how other languages tackle this problem, so I
am going to give a haphazard literature review:
\enumerate
\item Nils Anders Danielsson and Ulf Norell's ``Parsing Mixfix Operators''
(in SB.\ Scholz and O.\ Chitil (eds.), \emph{Symposium on Implementation and Application of Functional Languages},
Springer 2008, pp.\ 80--99; \doi{10.1007/978-3-642-24452-0_5})
discuss how Agda approaches parsing mixfix operators with different precedence.
\item The Isabelle proof assistant uses a modified version of Earley
parsing of terms, supporting precedence between 0 to 1000.
\endenumerate

@ The only two place where \\{FinishLongTerm} is invoked is in
the \\{AppendFunc} procedure (\section\xref{AppendFunc:parser.pas})
in \texttt{parser.pas}.

This relies on |MFormatsList.LookUpFuncFormat| (\section\xref{MFormatsList.LookUp_FuncFormat}),
which attempts to look up an \\{MInfixFormatObj}
(\section\xref{MInfixFormatObj}) with a given id number as well as
number of left and right arguments.

We will need to populate |ArgsLength| and |To_Right| to determine the
syntax tree for the term (which is our real goal here). The
|ArgsLength| encodes the number of terms are to the left and right of
each ``internal node''. The |To_Right| controls associativity (which
is how Mizar handles operator precedence): if node $F_{k+1}$ is higher
precedence than node $F_{k}$, then |To_Right(k)| is true.

The |Exchange(i)| procedure will make node $i$ a child of $i-1$
(when node $i$ is a child of $i-1$), and vice-versa. 
Visually, this means we transform the tree as:
$$\bigl(\cdots F_{i-1}\;x_{1},\dots,x_{\ell}\bigr),x_{\ell+1},\dots,x_{n}\; F_{i}\cdots\longleftrightarrow\cdots F_{i-1}\;x_{1},\dots,x_{\ell-1},\bigl(x_{\ell},x_{\ell+1},\dots,x_{n}\; F_{i}\cdots\bigr)$$
Observe that ``|Exchange(i);Exchange(i)|'' is equivalent to doing nothing.

We should recall (\section\xref{extSubexprObj:class})
that \\{nArgList} is an array of ``|record Instance,SymPri: integer; FuncPos: Position; end|''.

\label{extSubexpObj.FinishLongTerm}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishLongTerm;
var
   ArgsLength: array of record l,r: integer; end;
To_Right: array of boolean@t\1@>; 
procedure Exchange(i:integer);
var l: integer;
begin
   l:=ArgsLength[i].l;
   ArgsLength[i].l:=ArgsLength[i-1].r;
   ArgsLength[i-1].r:=l;
   To_Right[i-1]:=not To_Right[i-1];
end; @t\2@>
var
   Bl,new_Bl: integer; {indexes |nFunc|, |ArgsLength|}
   i,j,k: integer; {various indices}
   @<Variables for finishing a long term in a subexpression@>
label Corrected,AfterBalance;@t\2@>
begin
   @<Rebalance the long term tree@>@;
AfterBalance:
   @<Construct the term's syntax tree after balancing arguments among subterms@>
end;

@ \node{Rebalancing the term tree.}

Note that \\{nArgListNbr} is mutated only in \\{extSubexpObj.ProcessFunctorSymbol}
(\section\xref{extSubexpObj.ProcessFunctorSymbol}), and
in \\{ProcessAtomicFormula}
(\section\xref{extSubexpObj.ProcessAtomicFormula}) it is reset to zero.

@d missing_functor_format == gFormatsColl.LookUp_FuncFormat(Instance,l,r) = 0

@<Rebalance the long term tree@>=
   @<Initialize |To_Right| and |ArgsLength| arrays@>@;
   @<Initialize |Bl|, |goto AfterBalance| if term has at most one argument@>@; @/
   {|Bl = 1 or Bl = 2|}
   for k:=2 to nArgListNbr-1 do
      with nFunc[k], ArgsLength[k] do
   begin
      if missing_functor_format then
      @<Guess the $k^{th}$ functor format@>@;
      Corrected:
   end;
   for j:=nArgListNbr downto Bl+1 do
      with nFunc[j], ArgsLength[j] do
   begin
      if not missing_functor_format then goto AfterBalance;
      Exchange(j);
      @<Check for 172/173 error, |goto AfterBalance| if erred@>@;
   end;
   @<Check for 174/175 error, |goto AfterBalance| if erred@>@;

@ @<Check for 172/173 error, |goto AfterBalance| if erred@>=
      if missing_functor_format then
      begin
         Error(FuncPos,172);
         Error(nFunc[nArgListNbr].FuncPos,173);
         goto AfterBalance; @+
      end;

@ @<Check for 174/175 error, |goto AfterBalance| if erred@>=
   with nFunc[Bl], ArgsLength[Bl] do
      if missing_functor_format then
      begin
         Error(FuncPos,174);
         Error(nFunc[nArgListNbr].FuncPos,175);
         goto AfterBalance; @+
      end;

@ We first allocate the arrays, the we initialize the values.

@<Initialize |To_Right| and |ArgsLength| arrays@>=
   setlength(ArgsLength,nArgListNbr+1);
   setlength(To_Right,nArgListNbr+1);
   setlength(Depo,nArgListNbr+1); 

@ The
initial guess depends on whether $F_{k}$ has precedence over $F_{k+1}$
or not.

If $F_{k+1}$ has higher precedence than $F_{k}$, then the initial
guess groups terms as:
$$ \cdots F_{k} \;\;\bigl((x_{1}^{(k)},\dots,x^{(k)}_{m_{k}}) F_{k+1} (\cdots)\bigr)\cdots,\quad\hbox{and}\quad\\{To\_Right}[k]=\\{true}.$$
On the other hand, if $F_{k+1}$ \emph{does not} have higher precedence
than $F_{k}$, then we guess the terms are grouped as
$$ \cdots \bigl(\cdots F_{k} (x_{1}^{(k)},\dots,x^{(k)}_{m_{k}})\bigr)\;\; F_{k+1} \cdots,\quad\hbox{and}\quad\\{To\_Right}[k]=\\{false}.$$
This is a first stab, but sometimes we get lucky and it's correct.

@d next_term_has_higher_precedence(#) == @/
  gPriority.Value(ord('O'),nFunc[#].Instance) < gPriority.Value(ord('O'),nFunc[#+1].Instance)

@<Initialize |To_Right| and |ArgsLength| arrays@>=
   ArgsLength[1].l:=nArgList[0].Length;
   To_Right[0]:=true;
   for k:=1 to nArgListNbr-1 do
      with ArgsLength[k] do
         if next_term_has_higher_precedence(k) then
         begin
            r:=1;
            ArgsLength[k+1].l:=nArgList[k].Length;
            To_Right[k]:=true @+
         end
         else
         begin
            r:=nArgList[k].Length;
            ArgsLength[k+1].l:=1;
            To_Right[k]:=false @+
         end;
   ArgsLength[nArgListNbr].r:=nArgList[nArgListNbr].Length;
   To_Right[nArgListNbr]:=false;

@ The first situation we encounter is if the user tries to tell Mizar
to evaluate something like:

\medbreak
{\obeylines\tt
for x being Nat

holds x + (1,2) = x;
\par}
\medbreak\noindent%
Mizar will not understand ``{\tt x + (1,2)}'' because it is an invalid
functor format --- the format would look something like
$\langle\hbox{``\texttt{+}''}, {\rm left}: 1, {\rm right}: 1\rangle$ but
the format of the expression is $\langle {\rm left}: 1, {\rm right}: 2\rangle$.
The mismatch on the ``right'' values in the formats will raise a 165 error.

For a 166 error example,
\medbreak
{\obeylines\tt
for x being Nat

holds + / = x;
\par}
\medbreak\noindent%
Mizar will not like the leading ``{\tt + /}'' expression, and flag
this with the 166 error.

Mizar will flag ``{\tt + 0}'' as a 165 error.

@<Initialize |Bl|, |goto AfterBalance| if term has at most one argument@>=
   with nFunc[1], ArgsLength[1] do
   begin
      if nArgListNbr = 1 then
      begin
         if missing_functor_format then
         begin
            Error(FuncPos,165);
            goto AfterBalance @+
         end;
         goto AfterBalance;
      end;
      Bl:=1;
      if missing_functor_format then
      begin
         Exchange(2);
         Bl:=2;
         if missing_functor_format then
         begin
            Error(FuncPos,166);
            goto AfterBalance @+
         end;
      end;
   end;

@ @<Guess the $k^{th}$ functor format@>=
      begin
         Exchange(k+1);
         new_Bl:=Bl;
         if missing_functor_format then
         begin
            if Bl = k then
            begin
               Error(nFunc[k-1].FuncPos,168);
               Error(FuncPos,169);
               goto AfterBalance; @+
            end;
            Exchange(k+1);
            Exchange(k);
            new_Bl:=k;
            if missing_functor_format then
            begin
               Exchange(k+1);
               new_Bl:=k+1;
               if missing_functor_format then
               begin
                  Error(FuncPos,167);
                  goto AfterBalance @+
               end;
            end;
            for j:=k-1 downto Bl+1 do
               with nFunc[j], ArgsLength[j] do
            begin
               if not missing_functor_format then goto Corrected;
               Exchange(j);
               if missing_functor_format then
               begin
                  Error(FuncPos,168);
                  Error(nFunc[k].FuncPos,169);
                  goto AfterBalance; @+
               end;
            end;
            @<Check term |Bl| has valid functor format, |goto AfterBalance| if not@>@;
         end;
         Bl:=new_Bl;
      end;

@ @<Check term |Bl| has valid functor format, |goto AfterBalance| if not@>=
            with nFunc[Bl], ArgsLength[Bl] do
               if missing_functor_format then
               begin
                  Error(FuncPos,170);
                  Error(nFunc[k].FuncPos,171);
                  goto AfterBalance; @+
               end;

@ \node{Constructing the syntax tree.} The second half of finishing a
long term constructs the syntax tree for the term.

@<Variables for finishing a long term in a subexpression@>=
   ak,pl,ll,kn: integer;
   lTrm: TermPtr;
   lLeftArgs,lRightArgs: PList;
   DepoNbr: integer;
   Depo: array of record FuncInstNr:integer; dArgList:PList; end;

@ @<Construct the term's syntax tree after balancing arguments among subterms@>=
   @<Initialize symbol priorities, determine last |ll|, |pl| values@>@;
   DepoNbr:=0;
   for kn:=nArgListNbr downto 2 do
      if To_Right[kn-1] then {if |kn| node is parent of |kn-1| node}
      begin
         with nFunc[kn] do
         begin
            lRightArgs:=CreateArgs(nArgList[kn].Start); { (\section\xref{CreateArgs}) }
            lLeftArgs:=CreateArgs(nArgList[kn-1].Start);
            lTrm:=new(InfixTermPtr,Init(FuncPos,Instance,lLeftArgs,lRightArgs));
         end;
         for j:=DepoNbr downto 1 do
            with Depo[j], nFunc[FuncInstNr] do
         begin
            if symPri <= nFunc[kn-1].SymPri then break;
            dec(DepoNbr);
            lLeftArgs:=new(PList,Init(1));
            lLeftArgs^.Insert(lTrm);
            lTrm:=new(InfixTermPtr,Init(FuncPos,Instance,lLeftArgs,dArgList));
         end;
         gLastTerm:=lTrm; @/
         gSubexpPtr^.FinishArgument;
      end
      else
      begin
         inc(DepoNbr);
         with Depo[DepoNbr] do
         begin
            FuncInstNr:=kn;
            dArgList:=CreateArgs(nArgList[kn].Start); @+
         end;
      end;
   with nFunc[1] do
   begin
      lRightArgs:=CreateArgs(nArgList[1].Start);
      lLeftArgs:=CreateArgs(nArgList[0].Start);
      lTrm:=new(InfixTermPtr,Init(FuncPos,Instance,lLeftArgs,lRightArgs));
   end;
   for j:=DepoNbr downto 1 do
      with Depo[j], nFunc[FuncInstNr] do
   begin
      lLeftArgs:=new(PList,Init(1));
      lLeftArgs^.Insert(lTrm);
      lTrm:=new(InfixTermPtr,Init(FuncPos,Instance,lLeftArgs,dArgList));
   end;
   gLastTerm:=lTrm;

@ @<Initialize symbol priorities, determine last |ll|, |pl| values@>=
   for ak:=1 to nArgListNbr do
   begin
      ll:=1;
      pl:=1;
      if To_Right[ak-1] then ll:=nArgList[ak-1].Length;
      if not To_Right[ak] then pl:=nArgList[ak].Length;
      with nFunc[ak] do
      begin
         symPri:=gPriority.Value(ord('O'),Instance); @+
      end;
   end;

@* [s] Processing subexpressions.
Note that \\{ProcessFunctorSymbol} is the only place where
|nArgListNbr| is incremented. Processing functor symbols occurs in the
Parser's \\{AppendFunc} (\section\xref{AppendFunc:parser.pas}) in a loop.

\label{extSubexpObj.ProcessFunctorSymbol}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.@!ProcessFunctorSymbol;
var l: integer;
begin
   inc(nArgListNbr);
   if nArgListNbr >= length(nFunc) then
   begin
      l:=2*length(nFunc)+1;
      setlength(nArgList,l);
      setlength(nFunc,l);
   end;
   nArgList[nArgListNbr].Start:=TermNbr+1;
   nFunc[nArgListNbr].FuncPos:=CurPos;
   nFunc[nArgListNbr].Instance:=CurWord.Nr;
end;

@ The Parser is in the middle of \\{AppendFunc} and has just finished
parsing a term $t$ or a tuple of 
terms \hbox{\texttt{(} $t_{1}$, \dots, $t_{n}$ \texttt{)}}. Before the
Parser checks if it's looking at an infixed functor operator or not,
the Parser invokes the \\{FinishArgList} method. It's the only time
where the \\{FinishArgList} method is invoked.

This allocates either 1 or $n$ to the length of |nArgList[nArgListNbr]|,
to store the information for the term(s).

\label{extSubexpObj.FinishArgList}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishArgList;
begin
   nArgList[nArgListNbr].Length:=TermNbr-nArgList[nArgListNbr].Start+1;
end;

@ The Parser is looking at ``\texttt{where}'' or (when the variables
are all reserved) a colon ``\texttt{:}'', the Parser invokes
the \\{StartFraenkelTerm} which will store the previous term in
the \\{nSample} field --- so schematically, the Fraenkel term could
look like
$$\LB\<nSample>\hbox{ \texttt{where} }\<Postqualification> : \<Formula>\RB$$

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartFraenkelTerm;
begin
   nSample:=gLastTerm;
end;

@ This is only invoked in the Parser's \\{ProcessPostqualification}
(\section\xref{ProcessPostqualification}) procedure, which is only
invoked after the Parser calls the \\{extSubexp}
object's \\{StartFraenkelTerm} method.

\label{extSubexpObj.StartPostqualification}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPostqualification;
begin
   nPostQualList.Init(0);
end;

@ The Parser is looking at the post-qualified segment of a Fraenkel
operator. This will be a list of variables ``\texttt{being}'' a type,
we allocate an array for the variables. This is handled by
the \\{StartPostQualifyingSegment} method.

\label{extSubexpObj.StartPostQualifyingSegment}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPostQualifyingSegment;
begin
   nSegmentIdentColl.Init(2);
end;

@ While looping over the comma-separated list of variables in a
post-qualified segment (in a Fraenkel term), the Parser invokes
the \\{ProcessPostqualifiedVariable} on each iteration until it has
parsed all the variables. This allocates a new \\{Variable} object,
and pushes it onto the \\{nSegmentIdentColl} ``stack''.

\label{extSubexpObj.ProcessPostqualifiedVariable}
@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessPostqualifiedVariable;
begin
   nSegmentIdentColl.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end;

@ The Parser is looking at ``\texttt{is}'' or ``\texttt{are}'' in a
Fraenkel term's post-qualification segment, but has not yet parsed the
type. This method will assign the \\{nSegmentPos} field to be the
current position, and assign the \\{gLastType} state variable to be
the \&{nil} pointer.

\label{extSubexpObj.StartPostqualificationSpecyfication}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPostqualificationSpecyfication;
begin
   nSegmentPos:=CurPos;
   gLastType:=nil;
end;

@ The Parser has just parsed either (1) a comma-separated list of variables, the
copula ``\texttt{is}'' or ``\texttt{are}'', and the type; or (2) a
comma-separated list of reserved variables (but no copula and no
type). We just need to construct an appropriate node for the abstract
syntax tree. This method will append a new Segment to the \\{nPostQualList}.

\label{extSubexpObj.FinishPostQualifyingSegment}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishPostQualifyingSegment;
var k: integer;
lSegment: ExplicitlyQualifiedSegmentPtr;
begin
   if gLastType <> nil then
   begin
      lSegment:=new(ExplicitlyQualifiedSegmentPtr,
                    Init(nSegmentPos,new(PList,Init(0)),gLastType));
      nPostQualList.Insert(lSegment);
      for k := 0 to nSegmentIdentColl.Count - 1 do
      begin
         ExplicitlyQualifiedSegmentPtr(lSegment)^.nIdentifiers.Insert(nSegmentIdentColl.Items^[k]);
      end;
   end
   else
   begin
      for k := 0 to nSegmentIdentColl.Count - 1 do
      begin
         nPostQualList.Insert(new(ImplicitlyQualifiedSegmentPtr,
                                  Init(VariablePtr(nSegmentIdentColl.Items^[k])^.nVarPos,
                                       nSegmentIdentColl.Items^[k])));
      end;
   end;
   nSegmentIdentColl.DeleteAll;
   nSegmentIdentColl.Done;
end;

@ The Parser has just finished the formula in a Fraenkel term, and it
is staring at the closet ``$\RB$'' bracket. The Parser invokes this
method to construct a new \\{FraenkelTerm} AST node, and updates
the \\{gLastTerm} to point at it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishFraenkelTerm;
begin
   gLastTerm:=new(FraenkelTermPtr,Init(CurPos,new(PList,MoveList(nPostQualList)),
                                       nSample,gLastFormula));
end;

@ The Parser has already encountered ``\texttt{the set}'' and the next
token is ``\texttt{of}'', which means the Parser has encountered a
``simple'' Fraenkel term of the form ``\texttt{the set of all} \<Term>\dots''.
This method will be invoked once the Parser has stumbled across the
``\texttt{all}''. The caller updates its \\{nAllPos} to the Parser's
current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartSimpleFraenkelTerm;
begin
   nAllPos:=CurPos;
end;

@ The Parser has just finished parsing the post-qualification to the
simple Fraenkel term, which means it has finished parsing the simple
Fraenkel term. This method allocates a new \\{SimpleFraenkelTerm} AST
node with the accumulated AST nodes, then updates the \\{gLastTerm} to
point to the allocated \\{SimpleFraenkelTerm} node.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishSimpleFraenkelTerm;
begin
   gLastTerm:=new(SimpleFraenkelTermPtr,Init(nAllPos,new(PList,MoveList(nPostQualList)),nSample));
end;

@ The Parser is looking at a closed term of the form ``\<Identifier> \texttt{(}\dots'',
and so it looks like a private functor. This method updates the
caller's \\{nSubexpPos} to the Parser's current position, and
the \\{nSpelling} is assigned to the identifier's number (for the
private functor).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPrivateTerm;
begin
   nSubexpPos:=CurPos;
   nSpelling:=CurWord.Nr;
end;

@ The Parser just finished parsing all the arguments to the private
functor, and is looking at the closing parentheses for the private
functor. This method allocates a new \\{PrivateFunctorTerm} object,
using the arguments just parsed, and updates the \\{gLastTerm} state
variable to point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishPrivateTerm;
begin
   gLastTerm:=new(PrivateFunctorTermPtr,Init(nSubexpPos,nSpelling,CreateArgs(nTermBase+1)));
end;

@ The Parser has just encountered either a left bracket term or the
opening left bracket for a set ``$\LB$''. The Parser calls this
method, which just updates the caller's \\{nSymbolNr} to be whatever
the current token's numeric ID value is.

\label{extSubexpObj.StartBracketedTerm}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartBracketedTerm;
begin
   nSymbolNr:=CurWord.Nr;
end;

@ If the Parser is in panic mode, this method does nothing.

Either the Parser has finished parsing an enumerated set
$\LB\,x_{1},\dots,x_{n}\,\RB$ or a bracketed term. We need to double
check the format for the bracket matches what is stored in
the \\{gFormatsColl}, and raise a 152 error if there's a
mismatch. Otherwise, allocate a new AST node for the bracketed term,
and use \\{CreateArgs} on the terms contained within the brackets.

\label{extSubexpObj.FinishBracketedTerm}

@^Error, 152@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishBracketedTerm;
var lFormatNr: integer;
begin
   if StillCorrect then
   begin
      nRSymbolNr:=CurWord.Nr;
      lFormatNr:=gFormatsColl.LookUp_BracketFormat(nSymbolNr,nRSymbolNr,TermNbr-nTermBase,0,0);
      if lFormatNr=0 then SemErr(152);
      gLastTerm:=new(CircumfixTermPtr, Init(CurPos,nSymbolNr,nRSymbolNr,CreateArgs(nTermBase+1)));
   end;
end;

@ Remember that Mizar calls ``an instance of structure''
an \define{Aggregate}. When the Parser is parsing for a closed subterm
and has stumbled across a structure constructor (\section\xref{ClosedSubter:structure:parser.pas}), it first invokes this
method. This stores the ID number for the structure in the
caller's \\{nSymbolNr}. 

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartAggregateTerm;
begin
   nSymbolNr:=CurWord.Nr;
end;

@ The Parser has just parsed the arguments for the structure
constructor, and the Parser is now looking at the ``\texttt{\#)}''
token. This method is invoked.

We should check the format for the structure constructor is stored in
the \\{gFormatsColl}. If not, raise a 176 error. Otherwise, we
allocate a new \\{AggregateTerm} with the parsed arguments, and then
update the \\{gLastTerm} pointer to point at it.

@^Error, 176@>

\label{extSubexpObj.FinishAggregateTerm}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishAggregateTerm;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.LookUp_PrefixFormat('G',nSymbolNr,TermNbr-nTermBase);
   if lFormatNr = 0 then Error(CurPos,176); {missing format error}
   gLastTerm:=new(AggregateTermPtr, Init(CurPos,nSymbolNr,CreateArgs(nTermBase+1)));
end;

@ The Parser is parsing for a closed subterm, and has stumbled across
``\texttt{the}'' and is looking at a selector token
(\section\xref{GetClosedSubterm:the:parser.pas}). This method is
invoked. We assign the caller's \\{nSymbolNr} to the ID number for the
selector token, assign the caller's \\{nSubexpPos} to the Parser's
current position, and store the next token's kind (i.e., the
``\texttt{of}'' token's kind) in the \\{nNextWord}
field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartSelectorTerm;
begin
   nSymbolNr:=CurWord.Nr;
   nSubexpPos:=CurPos;
   nNextWord:=AheadWord.Kind;
end;

@ The Parser has just parsed ``\texttt{the} \<Selector> \texttt{of} \<Term>''.
Now this method is invoked to assemble the parsed data into an AST
node.

If there is no selector with this matching format, then a 182 error
will be raised.

If the caller's \\{nNextWord} is an ``\texttt{of}'' token's kind, then
we're describing a selector term. We update the \\{gLastTerm} state
variable to point to a newly allocated \\{SelectorTerm} object with
the appropriate data set.

On the other hand, \define{internal selectors} occur when defining a
structure. For example,

\smallbreak
{\tt\obeyspaces\obeylines\parindent=0pt\advance\leftskip3pc
\noindent struct (1-sorted) multMagma \hbox{(\#}

\quad carrier -> set,

\quad multF -> BinOp of the carrier

\ \hbox{\#);}
\par}

\smallbreak\noindent%
Observe the \texttt{multF} specification is \texttt{BinOp of the carrier}.
That ``\texttt{the carrier}'' is an internal selector. In this case,
allocate a new \\{InternalSelectorTerm} object, and update
the \\{gLastTerm} state variable to point to it.

If, for some reason, the Parser is in neither situation, then
just \\{gLastTerm} state variable to be an incorrect term.

@^Error, 182@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishSelectorTerm;
var lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.LookUp_PrefixFormat('U',nSymbolNr,1);
   if lFormatNr = 0 then Error(nSubexpPos,182); {missing format error}
   if nNextWord = sy_Of then
      gLastTerm:=new(SelectorTermPtr, Init(nSubexpPos,nSymbolNr,gLastTerm))
   else
      if in_AggrPattern then
         gLastTerm:=new(InternalSelectorTermPtr, Init(nSubexpPos,nSymbolNr))
      else
      begin
         gLastTerm:=new(IncorrectTermPtr, Init(nSubexpPos));
         Error(nSubexpPos,329)
      end;
end;

@ The Parser is about to start parsing a forgetful functor
(\section\xref{GetClosedSubterm:forgetful-functor:parser.pas}) --- for
example ``\texttt{the multMagma of REAL.TopGroup}''. This
method is invoked. The caller's \\{nSymbolNr} field is updated to the
current token's ID Number, the \\{nSubexpPos} field is assigned the
Parser's current position, and the \\{nNextWord} field is assigned to
the token kind of the next token --- this is expected to be ``\texttt{of}''.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartForgetfulTerm;
begin
   nSymbolNr:=CurWord.Nr;
   nSubexpPos:=CurPos;
   nNextWord:=AheadWord.Kind;
end;

@ The Parser just finished parsing a forgetful functor. If the Parser
is not panicking, check the format for the forgetful functor matches
what is stored in the \\{gFormatsColl} state variable. If the format
is invalid, raise a 184 error.

Whether the Parser is panicking or not, allocate a
new \\{ForgetfulFunctor} term, and update the \\{gLastTerm} to point
to it.

@^Error, 184@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishForgetfulTerm;
var lFormatNr: integer;
begin
   lFormatNr:=0;
   if StillCorrect then
   begin
      lFormatNr:=gFormatsColl.LookUp_PrefixFormat('J',nSymbolNr,1);
      if lFormatNr = 0 then Error(nSubexpPos,184); {missing format}
   end;
   gLastTerm:= new(ForgetfulFunctorTermPtr, Init(nSubexpPos,nSymbolNr,gLastTerm));
end;

@ There are several situations where this is invoked:
\enumerate
\item The Parser has just parsed ``\texttt{the}'' but is not looking
  at a selector symbol (``\texttt{the multF of}\dots''), nor is the
  Parser looking at a forgetful functor (``\texttt{the multMagma of}\dots'').
  Then this is interpreted as looking at a choice operator
  (\section\xref{GetClosedSubterm:the:parser.pas}).
\item The Parser has just parsed ``\texttt{the}'' but is not looking
  at a forgetful functor, so the Parser believes it must be looking at
  a choice operator
  (\section\xref{GetClosedSubterm:forgetful-functor:parser.pas}). 
\item The Parser has just parsed ``\texttt{the}'' and is now looking
  at ``\texttt{set}'' --- so this is invoking the axiom of choice to
  pick ``\texttt{the set}'' (\section\xref{ParseSimpleFraenkelExprOrTheSet:parser.pas}).
\endenumerate
\smallbreak\noindent%
In these three situations, the Parser invokes this method. It just
updates the caller's \\{nSubexpPos} field to point to the Parser's
current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartChoiceTerm;
begin
   nSubexpPos:=CurPos;
end;

@ The Parser has just parsed a type, and now believes it has finished
parsing a choice expression. Then it invokes this method to construct
an appropriate AST node for the term, by specifically allocating a
new \\{ChoiceTerm} for the \\{gLastType} type. We then update
the \\{gLastTerm} state variable to point to this newly allocated term.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishChoiceTerm;
begin
   gLastTerm:=new(ChoiceTermPtr,Init(nSubexpPos,gLastType));
end;

@ When the Parser encounters a numeral while seeking a closed subterm
(\section\xref{GetClosedSubterm:parser.pas}), it invokes this method
to allocate a new \\{NumeralTerm}. The \\{gLastTerm} state variable is
updated to point to this newly allocated numeral object.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessNumeralTerm;
begin
   gLastTerm:=new(NumeralTermPtr, Init(CurPos,CurWord.Nr));
end;

@ The Parser tries to parse a closed subterm
(\section\xref{GetClosedSubterm:parser.pas}) and encounters the
``\texttt{it}'' token. Well, if the |it_Allowed| state variable is
true, then we should allocate a new \\{ItTerm} and update
the \\{gLastTerm} state variable to point to it.

Otherwise, when the |it_Allowed| state variable is false, we should
raise a 251 error.

@^Error, 251@>
@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessItTerm;
begin
   if it_Allowed then gLastTerm:=new(ItTermPtr, Init(CurPos))
   else
   begin
      gLastTerm:=new(IncorrectTermPtr, Init(CurPos));
      ErrImm(251)
   end;
end;

@ The Parser tries parsing for a closed subterm and has encountered a
placeholder term for a private functor (e.g., ``\texttt{\$1}''). If
the |dol_Allowed| state variable is true, then allocate a
new \\{PlaceholderTerm} object and update the \\{gLastTerm} state
variable to point at it.

If the |dol_Allowed| state variable is false, then we should raise a
181 error.

@^Error, 181@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessLocusTerm;
begin
   if dol_Allowed then
      gLastTerm:=new(PlaceholderTermPtr, Init(CurPos,CurWord.Nr))
   else
   begin
      gLastTerm:=new(IncorrectTermPtr, Init(CurPos));
      ErrImm(181)
   end;
end;

@ Calamity! An incorrect expression has crossed the Parser's
path. Allocate an \\{IncorrectTerm} object located at the Parser's
current position, then update the \\{gLastTerm} state variable to
point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.InsertIncorrTerm;
begin
   gLastTerm:=new(IncorrectTermPtr, Init(CurPos));
end;

@* [s] Parsing formulas.
The Parser is trying to parse an atomic formula
(\section\xref{CompleteAtomicFormula:parser.pas}), but something has
gone awry. Allocate a new \\{IncorrectFormula} object located at the
Parser's current position, update the \\{gLastFormula} state variable
to point to it, and ``reset'' the \\{TermNbr} state variable to point
to where the caller's \\{nTermBase} is located.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.InsertIncorrBasic;
begin
   gLastFormula:=new(IncorrectFormulaPtr,Init(CurPos));
   TermNbr:=nTermBase;
end;

@ While the Parser was trying to parse a formula, it found something
which ``doesn't quite fit''. Allocate a new \\{IncorrectFormula}
object, then update the \\{gLastFormula} state variable to point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.InsertIncorrFormula;
begin
   gLastFormula:=new(IncorrectFormulaPtr,Init(CurPos));
end;

@ If we are in a proof, allocate a new \\{ThesisFormula} object
(recall the \WEB/ macro for this \section\xref{thesis-formula:macro-def}).
Otherwise, raise a 65 error.

@:Error, 065}{Error, 65@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessThesis;
begin
   if gProofCnt > 0 then
      gLastFormula:=thesis_formula
   else
   begin
      ErrImm(65);
      gLastFormula:=new(IncorrectFormulaPtr,Init(CurPos));
   end;
end;

@ The Parser has encountered ``\<Term> \texttt{is}'', or some other
generic atomic formula
(\section\xref{CompleteAtomicFormula:parser.pas}), this method is invoked.

If more than one term appears before the ``\texttt{is}'' token (i.e.,
if |TermNbr - nTermBase <> 1|), then a 157 error is raised.
There is a Polish comment here, ``Trzeba chyba wstawic recovery dla |TermNbr = nTermBase|'',
which I translated to English.

This will initialize the fields for the caller in preparation for
parsing some atomic formula.
In particular, this is the only place where \\{TermNbr} is initialized
to a nonzero value (and isn't in an incorrect formula).

@^Error, 157@>

\label{extSubexpObj.ProcessAtomicFormula}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.@!ProcessAtomicFormula;
const MaxArgListNbr = 20;
begin
   nSubexpPos:=CurPos;
   nSymbolNr:=0;
   case CurWord.Kind of
      sy_Is:
         if TermNbr - nTermBase <> 1 then
         begin
            ErrImm(157);
            TermNbr:=nTermBase;
            InsertIncorrTerm;
            FinishArgument;
            { I think you need to insert recovery for |TermNbr = nTermBase| }
         end;
   endcases; @/
   nRightArgBase:=TermNbr;
   nTermBase:=TermNbr;
   nPostNegated:=false;
   nArgListNbr:=0;
   nArgList[0].Start:=TermNbr+1;
end;

@ The Parser is either finishing a ``predicative formula'' (\section\xref{CompletePredicativeFormula:parser.pas}) or it's parsing a predicate pattern (\section\xref{GetPredPattern:parser.pas}),
it invokes this method to initialize the fields needed when forming an
AST node. Specifically, the \\{nSubexpPos} is assigned to the Parser's
current position, the \\{nSymbolNr} is updated either to the current
token's ID number (if the current token is ``\texttt{=}'' or a
predicate) or else assigned to be zero. Last, the \\{nRightArgBase} is
assigned to equal the \\{TermNbr} state variable.

\label{extSubexpObj.ProcessPredicateSymbol}

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessPredicateSymbol;
begin
   nSubexpPos:=CurPos;
   case CurWord.Kind of
      sy_Equal,PredicateSymbol: nSymbolNr:=CurWord.Nr;
   othercases nSymbolNr:=0;
   endcases; @/
   nRightArgBase:=TermNbr;
end;

@ The Parser is parsing a ``predicate formula'' which has arguments on
the righthand side of the predicate symbol (\section\xref{CompleteRightSideOfThePredicativeFormula:parser.pas}).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessRightSideOfPredicateSymbol;
begin
   nRightSideOfPredPos:=CurPos;
   case CurWord.Kind of
      sy_Equal,PredicateSymbol: nSymbolNr:=CurWord.Nr;
   othercases nSymbolNr:=0;
   endcases; @/
   nRightArgBase:=TermNbr;
end;

@ The Parser has just finished a ``predicate formula''
(\section\xref{CompletePredicativeFormula:parser.pas}), then this
method is invoked to construct an AST for the formula. First we check
if the format is valid. If the format for the formula is not found in
the \\{gFormatsColl}, then we must raise a 153 error.
Otherwise, we construct two lists (one for the left arguments, another
for the right arguments), and use them to construct a
new \\{PredicativeFormula} object. We update the \\{gLastFormula}
state variable to point to the newly allocated formula object.

@^Error, 153@>

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishPredicativeFormula;
var lLeftArgs,lRightArgs: PList;
lFormatNr: integer;
begin
   lFormatNr:=gFormatsColl.LookUp_PredFormat(nSymbolNr,nRightArgBase-nTermBase,TermNbr-nRightArgBase);
   if lFormatNr = 0 then Error(nSubexpPos,153); {missing format}
   lRightArgs:=CreateArgs(nRightArgBase+1);
   lLeftArgs:=CreateArgs(nTermBase+1);
   gLastFormula:=new(PredicativeFormulaPtr,Init(nSubexpPos,nSymbolNr,lLeftArgs,lRightArgs));
end;

@ The Parser tries to construct an AST when finishing up the
right-hand side of a predicative formula
(\section\xref{CompleteRightSideOfThePredicativeFormula:parser.pas}),
it invokes this method after the \\{extSubexpObj.FinishPredicativeFormula}
has been invoked.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishRightSideOfPredicativeFormula;
var lRightArgs: PList;
lLeftArgsNbr,lFormatNr: integer;
lFrm:FormulaPtr;
begin
   lFrm:=gLastFormula;
   if lFrm^.nFormulaSort = wsNegatedFormula then
      lFrm:=NegativeFormulaPtr(lFrm)^.nArg;
   lLeftArgsNbr:=RightSideOfPredicativeFormulaPtr(lFrm)^.nRightArgs^.Count;
   lFormatNr:=gFormatsColl.LookUp_PredFormat(nSymbolNr,lLeftArgsNbr,TermNbr-nRightArgBase);
   if lFormatNr = 0 then Error(nSubexpPos,153); {missing format}
   lRightArgs:=CreateArgs(nRightArgBase+1);
   gLastFormula:=new(RightSideOfPredicativeFormulaPtr,Init(nSubexpPos,nSymbolNr,lRightArgs));
   nMultiPredicateList.Insert(gLastFormula);
end;

@ When the Parser is parsing an atomic formula, when it has parsed a
formula and encounters another predicate, it defaults to
thinking that it is starting a ``multi-predicative formula''
(\section\xref{CompleteMultiPredicativeFormula:parser.pas}), and it
invokes this method. This initializes the \\{nMultiPredicateList} to
an empty list of length 4, and the first entry points to the same
formula pointed to by the \\{gLastFormula} state variable.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartMultiPredicativeFormula;
begin
   nMultiPredicateList.Init(4);
   nMultiPredicateList.Insert(gLastFormula);
end;

@ Finishing a ``multi-predicative formula'' allocates a
new \\{MultiPredicativeFormula} object, and moves the contents of the
caller's \\{nMultiPredicateList} to the newly minted
formula. The \\{gLastFormula} state variable is updated to point to
this newly allocated formula object.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishMultiPredicativeFormula;
begin
   gLastFormula:=new(MultiPredicativeFormulaPtr,Init(nSubexpPos,new(PList,MoveList(nMultiPredicateList))));
end;

@ The Parser has just parsed ``\<Term> \texttt{is} \<Type>'', and now
we need to store the accumulated data into a Formula AST. Of course,
if the \\{gLastType} variable is not pointing to a type object, then
we should raise an error (clearly something has gone wrong somewhere).

If we have accumulated attributes while parsing, then we should update
the \\{gLastType} to be a clustered type object (and we should move
the attributes over).

We should allocate a \\{QualifiedFormula} object, update
the \\{gLastFormula} state variable to point to it. If the Parser has
encountered ``\<Term> \texttt{is not} \<Type>'', then it will tell the
caller to toggle the \\{nPostNegated} to be true --- and in that case,
we should negate the \\{gLastFormula} state variable.

We mutate the \\{TermNbr} state variable, decrementing it by one
(since we consumed the top of the term stack).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishQualifyingFormula;
var j: integer;
begin
   mizassert(5430,gLastType <> nil);
   if nAttrCollection.Count > 0 then
   begin
      gLastType:=new(ClusteredTypePtr,
                     Init(gLastType^.nTypePos,new(PList,Init(nAttrCollection.Count)),gLastType));
      for j := 0 to nAttrCollection.Count-1 do
         ClusteredTypePtr(gLastType)^.nAdjectiveCluster^.Insert(PObject(nAttrCollection.Items^[j]));
   end;
   gLastFormula:=new(QualifyingFormulaPtr,Init(nSubexpPos,Term[TermNbr],gLastType));
   if nPostNegated then
      gLastFormula:=new(NegativeFormulaPtr,Init(nNotPos,gLastFormula));
   dec(TermNbr);
end;

@ The Parser has just finished parsing ``\<Term> \texttt{is} \<Attribute>''
or ``\<Term> \texttt{is not} \<Attribute>'', and so it invokes this
method. We allocate a new \\{AttributiveFormula} object, and negate it
if needed. We also decrement the \\{TermNbr} state variable (since we
consumed one element of the term stack).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishAttributiveFormula;
begin
   gLastFormula:=
      new(AttributiveFormulaPtr,Init(nSubExpPos,Term[TermNbr],new(PList,MoveList(nAttrCollection))));
   if nPostNegated then
      gLastFormula:=new(NegativeFormulaPtr,Init(nNotPos,gLastFormula));
   dec(TermNbr);
end;

@ While the Parser is working its way through a formula, and it is
looking at an identifier and the next token is a square bracket
``\texttt{[}'', then the Parser invokes this method to initialize the
relevant fields to store accumulated data.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartPrivateFormula;
begin
   nTermBase:=TermNbr;
   nSubexpPos:=CurPos;
   nSpelling:=CurWord.Nr;
end;

@ The Parser has just encountered ``\texttt{]}'' and now we assemble
the accumulated data into a formula. This allocates a
new \\{PrivatePredicativeFormula}, moves the arguments encountered
since starting the private predicate into a list
(\section\xref{CreateArgs}) owned by the formula
object. The \\{gLastFormula} is updated to point to the newly
allocated formula object.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishPrivateFormula;
begin
   gLastFormula:=new(PrivatePredicativeFormulaPtr,Init(nSubexpPos,nSpelling,CreateArgs(nTermBase+1)));
end;

@ The Parser has encountered the ``\texttt{contradiction}'' token, so
it invokes this method, which allocates a \\{ContradictionFormula} and
updates the \\{gLastFormula} state variable to point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessContradiction;
begin
   gLastFormula:=new(ContradictionFormulaPtr,Init(CurPos));
end;

@ The Parser routinely allocates a formula object, then realizes later
it should negate that formula object. This is handled by storing the
formula object in the \\{gLastFormula} object, then this method
allocates a new formula (which is the negation of
the \\{gLastFormula}) and updates the \\{gLastFormula} to point to the
newly allocated negated formula.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessNegative;
begin
   gLastFormula:=new(NegativeFormulaPtr,Init(CurPos,gLastFormula));
end;

@ When the Parser has encountered the ``\texttt{not}'' reserved
keyword, it invokes the \\{ProcessNegation} method which just toggles
the \\{nPostNegated} field of the caller, and assigns the \\{nNotPos}
field to the Parser's current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessNegation;
begin
   nPostNegated:=not nPostNegated;
   nNotPos:=CurPos;
end;

@ When the Parser is looking at a binary connective token
(e.g., ``\texttt{implies}'', ``\texttt{or}'', etc.), this method is
invoked to store the connective kind as well as the ``left-hand side'' to the
binary connective in the \\{nFirstSententialOperand} field. 

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessBinaryConnective;
begin
   nConnective:=CurWord.Kind;
   nFirstSententialOperand:=gLastFormula;
   nSubexpPos:=CurPos;
end;

@ The Parser has seen ``\<Formula> \texttt{or} \texttt{...} \texttt{or}''. 
Then this method will be invoked to store that first formula parsed in
the caller's \\{nFirstSententialOperand} field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessFlexDisjunction;
begin
   nFirstSententialOperand:=gLastFormula;
end;

@ The Parser has seen ``\<Formula> \texttt{\AM} \texttt{...} \texttt{\AM}''. 
Then this method will be invoked to store that first formula parsed in
the caller's \\{nFirstSententialOperand} field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessFlexConjunction;
begin
   nFirstSententialOperand:=gLastFormula;
end;

@ The Parser has parsed ``\texttt{for} \<Qualified-Variables> \texttt{st}'',
and it is staring at the ``\texttt{st}'' token. Then it will invoke
this method to mark the \\{nRestrPos}, setting it equal to the
Parser's current position.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartRestriction;
begin
   nRestrPos:=CurPos;
end;

@ The Parser has just parsed the formula appearing after
``\texttt{st}'', so this method is invoked to store that formula in
the caller's \\{nRestriction} field (for later use when constructing
an AST).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishRestriction;
begin
   nRestriction:=gLastFormula;
end;

@ The Parser has finished parsing a formula involving binary
connectives, then it invokes this method to construct the formula AST.

If somehow the connective is not ``\texttt{implies}'',
``\texttt{iff}'', ``\texttt{or}'', or ``\texttt{\AM}'', then we should
raise an error.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishBinaryFormula;
begin
   case nConnective of
      sy_Implies:
         gLastFormula:=new(ConditionalFormulaPtr,Init(nSubExpPos,nFirstSententialOperand,gLastFormula));
      sy_Iff:
         gLastFormula:=new(BiconditionalFormulaPtr,Init(nSubexpPos,nFirstSententialOperand,gLastFormula));
      sy_Or:
         gLastFormula:=new(DisjunctiveFormulaPtr,Init(nSubexpPos,nFirstSententialOperand,gLastFormula));
      sy_Ampersand:
         gLastFormula:=new(ConjunctiveFormulaPtr,Init(nSubexpPos,nFirstSententialOperand,gLastFormula));
   othercases
      RunTimeError(3124);
   endcases;
end;

@ We have parsed ``\<Formula> \texttt{or ... or} \<Formula>'', and the
Parser invokes this method to construct an AST for the formula. This
method allocates a new \\{FlexaryDisjunctive} formula object, and
updates the \\{gLastFormula} state variable to point to it.

There is a comment in Polish, ``polaczyc z flexConj'', which Google
translates to ``connect to flexConj''.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishFlexDisjunction; {polaczyc z flexConj}
begin
   gLastFormula:=new(FlexaryDisjunctiveFormulaPtr,
                     Init(CurPos,nFirstSententialOperand,gLastFormula));
end;

@ We have parsed ``\<Formula> \texttt{\AM\ ... \AM} \<Formula>'', and
the Parser invokes this method to construct an AST for the
formula. This allocates a new \\{FlexaryConjunctive} formula object,
and updates the \\{gLastFormula} state variable to point to it.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishFlexConjunction;
begin
   gLastFormula:=new(FlexaryConjunctiveFormulaPtr,
                     Init(CurPos,nFirstSententialOperand,gLastFormula));
end;

@ The Parser is looking at the ``\texttt{ex}'' token, then invokes
this method to reset the caller's fields in preparation for
accumulating data needed when constructing the formula's AST.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartExistential;
begin
   nQualifiedSegments.Init(0);
   nSubexpPos:=CurPos;
end;

@ The Parser is looking at the ``\texttt{for}'' token, and it invokes
this method to reset the relevant fields in the caller.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartUniversal;
begin
   nQualifiedSegments.Init(0);
   nSubexpPos:=CurPos;
end;

@ After the Parser has invoked \\{StartUniversal}
or \\{StartExistential}, it parses the quantified variables (which
begins by invoking this method).

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartQualifiedSegment;
begin
   nSegmentIdentColl.Init(2);
   nSegmentPos:=CurPos;
end;

@ The Parser has parsed a comma-separated list and is expecting either
``\texttt{be}'' or ``\texttt{being}'', but before parsing for that
copula the Parser invokes the \\{StartQualifyingType} method to update
the \\{gLastType} state variable to point to \&{nil}.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.StartQualifyingType;
begin
   gLastType:=nil;
end;

@ The Parser has just finished parsing quantified variables. There are
two possible situations:
\enumerate
\item We have just parsed reserved variables, so the types are all
known. Then the |gLastType = nil|.
\item We have parsed an explicitly typed list of variables, so the
|gLastType <> nil|.
\endenumerate

\smallbreak\noindent In the first case, we should allocate
an \\{ImplicitlyQualifiedSegment} object and move all the segment's
identifiers to this object. Then we clean up the
caller's \\{nSegmentIdentColl} field (since it's an array of \&{nil}
pointers). 

In the second case, we can just move the identifiers when allocating a
new \\{ExplicitlyQualifiedSegment} object.

In both cases, the new allocated \\{QuantifiedSegment} object is
appended to the caller's \\{nQualifiedSegments} field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishQualifiedSegment;
var k: integer;
begin
   if gLastType = nil then
   begin
      for k := 0 to nSegmentIdentColl.Count - 1 do
      begin
         nQualifiedSegments.Insert(new(ImplicitlyQualifiedSegmentPtr,
                                       Init(VariablePtr(nSegmentIdentColl.Items^[k])^.nVarPos,
                                            nSegmentIdentColl.Items^[k])));
         nSegmentIdentColl.Items^[k]:=nil;
      end;
      nSegmentIdentColl.Done;
   end
   else
   begin
      nQualifiedSegments.Insert(new(ExplicitlyQualifiedSegmentPtr,
                                    Init(nSegmentPos,new(PList,MoveList(nSegmentIdentColl)),gLastType)));
   end;
end;

@ When the Parser is parsing quantified variables, specifically when
it is parsing a comma-separated list of variables, it will invoke this
method, then check if the next token is a comma (and if so
iterate). This \\{ProcessVariable} method should accumulate
a \\{Variable} object with the current token's identifier, then insert
it into the caller's \\{nSegmentIdentColl} field.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.ProcessVariable;
begin
   nSegmentIdentColl.Insert(new(VariablePtr,Init(CurPos,GetIdentifier)));
end;

@ The Parser has just finished something like
$$\hbox{\texttt{ex }} \<Qualified-Variables>\hbox{ \texttt{,} }\dots\hbox{ \texttt{,} }\<Qualified-Variables>\hbox{ \texttt{st} }\<Formula>$$
Now we assemble it as
$$\hbox{\texttt{ex }} \<Qualified-Variables>\hbox{ \texttt{st} }\bigl(\hbox{\texttt{ex }}\dots\hbox{ \texttt{st} }(\hbox{\texttt{ex} }\<Qualified-Variables>\hbox{ \texttt{st} }\<Formula>)\bigr)$$
starting with the innermost existentially quantified formula, working
our ways outwards.

Importantly, assembling the AST reflects the quantified variables has
the grammar

\smallbreak
{\obeylines\parindent=0pt\advance\leftskip3pc

\<Qualified-Variables> = \<Implicitly-Qualified-Variables>

\hskip3pc\pipe\ \<Explicitly-Qualified-Variables>

\hskip3pc\pipe\ \<Explicitly-Qualified-Variables> \texttt{","} \<Implicitly-Qualified-Variables>
\par}

\smallbreak\noindent%


@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishExistential;
var k:integer;
begin
   for k:=nQualifiedSegments.Count-1 downto 1 do {from inside outwards}
   begin
      gLastFormula:=new(ExistentialFormulaPtr,
                        Init(QualifiedSegmentPtr(nQualifiedSegments.Items^[k])^.nSegmPos,
                             nQualifiedSegments.Items^[k],gLastFormula));
      nQualifiedSegments.Items^[k]:=nil;
   end;
   if nQualifiedSegments.Count > 0 then
   begin
      gLastFormula:=new(ExistentialFormulaPtr,
                        Init(nSubexpPos,nQualifiedSegments.Items^[0],gLastFormula));
      nQualifiedSegments.Items^[0]:=nil;
   end;
   nQualifiedSegments.Done;
end;

@ Universally quantified formulas first transforms
$$\hbox{\texttt{for }}\<Qualified-Variables>\hbox{ \texttt{st} }\<Formula>_{1} \hbox{ \texttt{holds} }\<Formula>_{2}$$
into
$$\hbox{\texttt{for }}\<Qualified-Variables>\hbox{ \texttt{holds} }\<Formula>_{1} \hbox{ \texttt{implies} }\<Formula>_{2}$$
which is handled immediately.

The remainder of the method iteratively constructs the universally
quantified formulas by ``unrolling'' the qualified segments, just as
we did for existentially quantified formulas.

@<Extended subexpression implementation@>=
procedure @? extSubexpObj.FinishUniversal;
var k:integer;
begin
   if nRestriction <> nil then {transform \texttt{st} into \texttt{implies}}
      gLastFormula:=new(ConditionalFormulaPtr,Init(nRestrPos,nRestriction,gLastFormula));
   for k:=nQualifiedSegments.Count-1 downto 1 do
   begin
      gLastFormula:=new(UniversalFormulaPtr,
                        Init(QualifiedSegmentPtr(nQualifiedSegments.Items^[k])^.nSegmPos,
                             nQualifiedSegments.Items^[k],gLastFormula));
      nQualifiedSegments.Items^[k]:=nil;
   end;
   if nQualifiedSegments.Count > 0 then
   begin
      gLastFormula:=new(UniversalFormulaPtr,
                        Init(nSubexpPos,nQualifiedSegments.Items^[0],gLastFormula));
      nQualifiedSegments.Items^[0]:=nil;
   end;
end;

@* [S] Extended expression class.
When an expression is needed, the \\{gExpPtr} state variable is used
to build it out of subexpressions. The \\{gExpPtr} state variable is
an instance of the \\{extExpression} class.

@<Extended expression class declaration@>=
   extExpressionPtr = ^extExpressionObj; @/
   extExpressionObj = object(ExpressionObj) @t\1@>
      constructor Init(fExpKind:ExpKind); @t\2@>
      procedure CreateSubexpression; virtual; @t\2\2\2@>
   end;

@ \node{Constructor.} This just invokes the parent class's constructor
(\section\xref{ExpressionObj.Init}), then resets the module-wide
variable \\{TermNbr} to zero.

@<Extended expression implementation@>=
constructor extExpressionObj.Init(fExpKind:ExpKind);
begin
   inherited Init(fExpKind);
   TermNbr:=0;
end;

@ An \\{extExpression} creating a subexpression \emph{overrides} the
parent class's method (\section\xref{ExpressionObj.CreateSubexpression}),
and sets the global \\{gSubexpPtr} to point to a new \\{extSubexp}
object.

\label{extExpressionObj.CreateSubexpression}

@<Extended expression implementation@>=
procedure extExpressionObj.CreateSubexpression;
begin
   gSubexpPtr:=new(extSubexpPtr,Init)
end;

