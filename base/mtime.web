
@* [F] Time utilities.
We will want to report to the user how much time Mizar takes during
various phases of execution.
This is another heavily ``system dependent'' library.

@<mtime.pas@>=
  @<GNU License@>

unit mtime;

interface @;@|@/

@<Interface for \texttt{mtime.pas}@>@;

implementation @; @|@/

@<Implementation for \texttt{mtime.pas}@>@; @+ @t\2@>

end;

@ The implementation begins with a rather \emph{thorny} digression
depending on which compiler we're using.

@<Implementation for \texttt{mtime.pas}@>=
@<Timing utilities |uses| for Delphi@>@;
@<Timing utilities |uses| for FreePascal@>@;
@ Delphi simply requires us to introduce a constant for milliseconds.

@<Timing utilities |uses| for Delphi@>=
@{@&$IFDEF DELPHI@}
uses windows;
const cmSecs = 1000; @/
@{@&$ENDIF@}

@ FreePascal requires a bit more work, alas. We can use
the \\{GetTime} procedure to populate the hours, minutes, seconds, and
hundredths of a second. American readers forgetful of the metric
system should know that $0.01~{\rm s}=10~{\rm ms}$ (one hundredth of a
second is ten milliseconds).

Note: the \\{wMilliseconds} parameter is misnamed, it does not measure
in units of milliseconds but centiseconds.

@<Timing utilities |uses| for FreePascal@>=
@{@&$IFDEF FPC@}
uses dos;
const cmSecs = 100; {= 100 centiseconds per 1 second}
type
   TSystemTime = @/
     record
      wHour:word;
      wMinute:word;
      wSecond:word;
      wMilliseconds:word;
     end;
procedure GetLocalTime(var aTime: TSystemTime);
begin
 with aTime do GetTime(wHour,wMinute,wSecond,wMilliseconds);
end; @/
@{@&$ENDIF@}

@ Now we can happily plug along implementing the functions we need.
This is slightly misnamed, the result will be \emph{centiseconds}
(hundredths of a second).

@<Implementation for \texttt{mtime.pas}@>=
function SystemTimeToMiliSec(const fTime: TSystemTime): longint;
begin
 SystemTimeToMiliSec:=fTime.wHour*(3600*cmSecs)+@|
                      fTime.wMinute*longint(60*cmSecs)+@|
                      fTime.wSecond*cmSecs+@|
                      fTime.wMilliseconds;
end;

@ Time since we ``started the clock''. The result is stored in the
variable \\{W}.

@<Interface for \texttt{mtime.pas}@>=
procedure @? TimeMark(var W:longint);

@ @<Implementation for \texttt{mtime.pas}@>=
procedure TimeMark(var W:longint);
 var @? SystemTime: TSystemTime;
begin
 GetLocalTime(SystemTime);
 W:=SystemTimeToMiliSec(SystemTime);
end;

@ When we have measured the time already $W$ since the system started
(in ``milliseconds''), and we want to get the elapsed time \emph{since
we measured} $W$, then this function will accomplish the task. If $W$
is greater than the lifetime of Mizar's run, then clearly something
has gone awry. Mizar assumes a day has passed (in that case).

Note that $86400=24\times60\times60$ is the number of minutes in one day.

@<Interface for \texttt{mtime.pas}@>=
function @? ElapsedTime(W:longint): longint;

@ @<Implementation for \texttt{mtime.pas}@>=
function ElapsedTime(W:longint): longint;
 var @? T : longint;
     @? SystemTime: TSystemTime;
begin
 GetLocalTime(SystemTime);
 T := SystemTimeToMiliSec(SystemTime)-W;
 if T < 0 then T:=86400*cmSecs+T;
 ElapsedTime:=T;
end;

@ We can transform an interval of time (in ``milliseconds'') into
hours, minutes, seconds, a fractional amount of time. 

@<Interface for \texttt{mtime.pas}@>=
procedure @? MUnpackTime(W:longint; var H,M,S,F: word);

@ @<Implementation for \texttt{mtime.pas}@>=
procedure MUnpackTime(W:longint; var H,M,S,F: word);
begin
 H := W div (3600*cmSecs);
 M := (W-H*3600*cmSecs) div (60*cmSecs);
 S := (W-H*3600*cmSecs-M*60*cmSecs) div cmSecs;
 F := W-H*3600*cmSecs-M*60*cmSecs-S*cmSecs;
end;

@ When reporting time, we want to pad the time by a zero. This is
standard conventional stuff (e.g., I have an appointment at 11:01~AM,
not 11:1~AM).

@<Implementation for \texttt{mtime.pas}@>=
function LeadingZero(w : word) : String;
var lStr: String;
begin
  Str(w:0,lStr);
  if length(lStr) = 1 then lStr := '0' + lStr;
  LeadingZero := lStr;
end;

@ Reporting time transforms a time interval (measured in milliseconds)
into a human readable String.

@<Interface for \texttt{mtime.pas}@>=
function @? ReportTime(W:longint): String;

@ @<Implementation for \texttt{mtime.pas}@>=
function ReportTime(W:longint): String;
var H,M,S,F: word; lTimeStr: String;
begin
   MUnpackTime(ElapsedTime(W),H,M,S,F);
   @<Round to nearest second@>;
   if H<>0 then
   @<Report hours and minutes@>
   else Str(M:2,lTimeStr); {report minutes}
   ReportTime:=lTimeStr+':'+LeadingZero(S); {\dots and seconds}
end;

@ @<Round to nearest second@>=
   if F >= (cmSecs div 2) then inc(S)

@ @<Report hours and minutes@>=
   begin Str(H,lTimeStr); lTimeStr:=lTimeStr+'.'+LeadingZero(M) end

@ We also have one global variable tracking the start time of Mizar.
Every time Mizar starts up, it will ``mark the time'' (i.e., assign to
the \\{gStartTime} global variable the current time).

@<Interface for \texttt{mtime.pas}@>=
var
  gStartTime: longint;

@ When we run the program, we should mark the time.

@<Implementation for \texttt{mtime.pas}@>=
begin
 TimeMark(gStartTime);
end.
