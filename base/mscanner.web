
@* [F] MScanner.
We have the MScanner module transform an article (an input file) into
a stream of tokens.

@<scanner.pas@>=
@<GNU License@>

unit mscanner;

interface @|@#

uses errhan,mobjects,scanner; @|@#


  @<Public interface for MScanner@>@; @#

implementation @|@#

uses mizenv; @#

@<Implementation for MScanner@>; @t\2@> @#

end.

@ \node{Public types.} We have enumerated types for each construction
we'll encounter in Mizar.

\label{PropertyKind}

@<Public interface for MScanner@>=
type
   @<Token kinds for MScanner@>;

   CorrectnessKind  = (syCorrectness,
                       syCoherence, syCompatibility, syConsistency,
                       syExistence, syUniqueness, syReducibility); @#

   PropertyKind = (sErrProperty,
                   sySymmetry,syReflexivity,syIrreflexivity,
                   syAssociativity,syTransitivity,syCommutativity,
                   syConnectedness,syAsymmetry,syIdempotence,
                   syInvolutiveness,syProjectivity,sySethood,syAbstractness); @#

   LibraryReferenceKind = (syThe,syDef,sySch); @#

   DirectiveKind =
      (syVocabularies,syNotations,
       syDefinitions,syTheorems,sySchemes,syRegistrations,
       syConstructors,syRequirements,syEqualities,syExpansions); @#

   @<Token type for MScanner@>; @#
@ \node{Token type for MScanner.}

@<Token type for MScanner@>=
   Token =
      record @t\1@> Kind:TokenKind;
         Nr:integer;
         Spelling: string @t\2@>;
      end

@ \node{Constants for MScanner}

\label{MScanner:constants}

@<Public interface for MScanner@>=
const
   {Homonymic and special symbols in buildin vocabulery}
   {Homonymic Selector Symbol}
   StrictSym = 1;       {``strict''}
   {Homonymic Mode Symbol}
   SetSym = 1;          {`set'}
   {Homonymic Predicate Symbol}
   EqualitySym = 1;     {`='}
   {Homonymic Circumfix Symbols}
   SquareBracket = 1;   {`[' `]'}
   CurlyBracket = 2;    { ``\LB'' ``\RB'' }
   RoundedBracket = 3;  { ``('' ``)'' }
   
   scTooLongLineErrorNr = 200;  {Error number: Too long line}

   @<Token names for MScanner@>;

   CorrectnessName: array[CorrectnessKind] of string =
      ('correctness',
       'coherence',
       'compatibility',
       'consistency',
       'existence',
       'uniqueness',
       'reducibility'
      );

   PropertyName: array[PropertyKind] of string =
      ('',
       'symmetry',
       'reflexivity',
       'irreflexivity',
       'associativity',
       'transitivity',
       'commutativity',
       'connectedness',
       'asymmetry',
       'idempotence',
       'involutiveness',
       'projectivity',
       'sethood',
       'abstractness'
      );
   
   LibraryReferenceName: array[LibraryReferenceKind] of string =
      ( 'the','def','sch');
   
   DirectiveName: array[DirectiveKind] of string =
      ( 'vocabularies',
        'notations',
        'definitions',
        'theorems',
        'schemes',
        'registrations',
        'constructors',
        'requirements',
        'equalities',
        'expansions'
      );
   
   PlaceHolderName: array[1..10] of string =
      ( '$1', '$2', '$3', '$4', '$5', '$6', '$7', '$8', '$9', '$10' );
   
   Unexpected = sErrProperty;

@ \node{Public facing procedures and global variables.}
Of particular importance, the global variable \\{gScanner} is declared here.

@<Public interface for MScanner@>=   
var
   PrevWord,CurWord,AheadWord: Token; @/
   PrevPos,AheadPos: Position; @#
   
   procedure @? ReadToken; @t\2@> @#
   
   procedure @? LoadPrf(const aPrfFileName:string); @t\2@> @/
   procedure @? DisposePrf; @t\2@> @#
   
   procedure @? StartScaner; @t\2@> @#
   
   procedure @? InitSourceFile(const aFileName, aDctFileName:string); @t\2@> @/
   procedure @? CloseSourceFile; @t\2@> @/
   procedure @? InitScanning(const aFileName,aDctFileName:string); @t\2@> @/
   procedure @? FinishScanning; @t\2@> @/
   
var
  gScanner: MScannPtr = nil; {This is important}
  @? ModeMaxArgs,@? StructModeMaxArgs,@? PredMaxArgs: IntSequence;

@ \node{Token kinds.}
If I were cleverer, I would have some \WEB/ macros to make this
readable. 
\label{TokenKind}
@<Token kinds for MScanner@>=
   TokenKind = (
      syT0, @t\1@> {\begingroup\tt  \#0  }
      syT1, {  \#1  }
      syT2, {  \#2  }
      syT3, {  \#3  }
      syT4, {  \#4  }
      syT5, {  \#5  }
      syT6, {  \#6  }
      syT7, {  \#7  }
      syT8, {  \#8  }
      syT9, {  \#9  }
      syT10, {  \#10 }
      syT11, {  \#11 }
      syT12, {  \#12 }
      syT13, {  \#13 }
      syT14, {  \#14 }
      syT15, {  \#15 }
      syT16, {  \#16 }
      syT17, {  \#17 }
      syT18, {  \#18 }
      syT19, {  \#19 }
      syT20, {  \#20 }
      syT21, {  \#21 }
      syT22, {  \#22 }
      syT23, {  \#23 }
      syT24, {  \#24 }
      syT25, {  \#25 }
      syT26, {  \#26 }
      syT27, {  \#27 }
      syT28, {  \#28 }
      syT29, {  \#29 }
      syT30, {  \#30 }
      syT31, {  \#31 }
      Pragma, {  \#32 }
      EOT = 33, {! \#33 }
      sy_from, {" \#34 }
      sy_identify, {\# \#35 }
      sy_thesis, { \$ \#36}
      sy_contradiction, {\% \#37 }
      sy_Ampersand, {\AM\ \#38 }
      sy_by, {' \#39 }
      sy_LeftParanthesis, {( \#40 }
      sy_RightParanthesis, {) \#41 }
      sy_registration, {* \#42 }
      sy_definition, {+ \#43 }
      sy_Comma, {, \#44 }
      sy_notation, {- \#45 }
      sy_Ellipsis, {. \#46 }
      sy_proof, {/ \#47 }
      syT48, {0 \#48 }
      syT49, {1 \#49 }
      syT50, {2 \#50 }
      syT51, {3 \#51 }
      syT52, {4 \#52 }
      syT53, {5 \#53 }
      syT54, {6 \#54 }
      syT55, {7 \#55 }
      syT56, {8 \#56 }
      syT57, {9 \#57 }
      sy_Colon, {: \#58 }
      sy_Semicolon, {; \#59 }
      sy_now, {< \#60 }
      sy_Equal, {= \#61 }
      sy_end, {> \#62 }
      sy_Error, {? \#63 }
      syT64, {@@ \#64 }
      MMLIdentifier, {A \#65 }
      syT66, {B \#66 }
      syT67, {C \#67 }
      sy_LibraryDirective, {D \#68 } @+ {{\rm see DirectiveKind}}
      syT69, {E \#69 }
      syT70, {F \#70 }
      StructureSymbol, {G \#71 }
      syT72, {H \#72 }
      Identifier, {I \#73 }
      ForgetfulFunctor, {J \#74 }
      LeftCircumfixSymbol, {K \#75 }
      RightCircumfixSymbol, {L \#76 }
      ModeSymbol, {M \#77 }
      Numeral, {N \#78 }
      InfixOperatorSymbol, {O \#79 }
      syT80, {P \#80 }
      ReferenceSort, {Q \#81 }
      PredicateSymbol, {R \#82 }
      syT83, {S \#83 }
      syT84, {T \#84 }
      SelectorSymbol, {U \#85 }
      AttributeSymbol, {V \#86 }
      syT87, {W \#87 }
      sy_Property, {X \#88 } @+ {{\rm see PropertyKind}}
      sy_CorrectnessCondition, {Y \#89 } @+ {{\rm see CorrectnessKind }}
      sy_Dolar, {Z \#90 } @+ { \$1 \$2 \$3 \$4 \$5 \$6 \$7 \$8 \$9 \$10 }
      sy_LeftSquareBracket, {[ \#91 }
      syT92, {\ \#92 }
      sy_RightSquareBracket, {] \#93 }
      syT94, {\shiftSix\ \#94 }
      syT95, {\_ \#95 }
      syT96, {` \#96 }
      sy_according, {a \#97 }
      syT98, {b \#98 }
      sy_reduce, {c \#99 }
      syT100, {d \#100}
      sy_equals, {e \#101}
      syT102, {f \#102}
      syT103, {g \#103}
      sy_with, {h \#104}
      syT105, {i \#105}
      syT106, {j \#106}
      syT107, {k \#107}
      syT108, {l \#108}
      syT109, {m \#109}
      syT110, {n \#110}
      syT111, {o \#111}
      syT112, {p \#112}
      syT113, {q \#113}
      sy_wrt = 114, {r \#114}
      syT115, {s \#115}
      sy_to, {t \#116}
      syT117, {u \#117}
      syT118, {v \#118}
      sy_when, {w \#119}
      sy_axiom, {x \#120}
      syT121, {y \#121}
      syT122, {z \#122}
      sy_LeftCurlyBracket, {  \#123}
      syT124, {\pipe\ \#124}
      sy_RightCurlyBracket, {  \#125}
      syT126, {\TL\ \#126}
      syT127, {\#127}
      syT128, {\#128}
      syT129, {\#129}
      syT130, {\#130}
      syT131, {\#131}
      syT132, {\#132}
      syT133, {\#133}
      syT134, {\#134}
      sy_correctness = 135, {\#135}
      syT136, {\#136}
      syT137, {\#137}
      syT138, {\#138}
      syT139, {\#139}
      sy_if = 140, {\#140}
      syT141, {\#141}
      syT142, {\#142}
      syT143, {\#143}
      sy_is = 144, {\#144}
      sy_are, {\#145}
      syT146, {\#146}
      sy_otherwise, {\#147}
      syT148, {\#148}
      syT149, {\#149}
      syT150, {\#150}
      syT151, {\#151}
      syT152, {\#152}
      syT153, {\#153}
      syT154, {\#154}
      syT155, {\#155}
      sy_ex = 156, {\#156}
      sy_for, {\#157}
      syT158, {\#158}
      sy_define, {\#159}
      syT160, {\#160}
      sy_being, {\#161}
      sy_over, {\#162}
      syT163, {\#163}
      sy_canceled, {\#164}
      sy_do, {\#165}
      sy_does, {\#166}
      sy_or, {\#167}
      sy_where, {\#168}
      sy_non, {\#169}
      sy_not, {\#170}
      sy_cluster, {\#171}
      sy_attr, {\#172}
      syT173, {\#173}
      sy_StructLeftBracket, {\#174}
      sy_StructRightBracket, {\#175}
      sy_environ, {\#176}
      syT177, {\#177}
      sy_begin, {\#178}
      syT179, {\#179}
      syT180, {\#180}
      syT181, {\#181}
      syT182, {\#182}
      syT183, {\#183}
      syT184, {\#184}
      sy_hence, {\#185}
      syT186, {\#186}
      syT187, {\#187}
      sy_hereby, {\#188}
      syT189, {\#189}
      syT190, {\#190}
      syT191, {\#191}
      sy_then, {\#192}
      sy_DotEquals, {\#193}
      syT194, {\#194}
      syT195, {\#195}
      sy_synonym, {\#196}
      sy_antonym, {\#197}
      syT198, {\#198}
      syT199, {\#199}
      sy_let, {\#200}
      sy_take, {\#201}
      sy_assume, {\#202}
      sy_thus, {\#203}
      sy_given, {\#204}
      sy_suppose, {\#205}
      sy_consider, {\#206}
      syT207, {\#207}
      syT208, {\#208}
      syT209, {\#209}
      syT210, {\#210}
      sy_Arrow, {\#211}
      sy_as, {\#212}
      sy_qua, {\#213}
      sy_be, {\#214}
      sy_reserve, {\#215}
      syT216, {\#216}
      syT217, {\#217}
      syT218, {\#218}
      syT219, {\#219}
      syT220, {\#220}
      syT221, {\#221}
      syT222, {\#222}
      syT223, {\#223}
      sy_set, {\#224}
      sy_selector, {\#225}
      sy_cases, {\#226}
      sy_per, {\#227}
      sy_scheme, {\#228}
      sy_redefine, {\#229}
      sy_reconsider, {\#230}
      sy_case, {\#231}
      sy_prefix, {\#232}
      sy_the, {\#233}
      sy_it, {\#234}
      sy_all, {\#235}
      sy_theorem, {\#236}
      sy_struct, {\#237}
      sy_exactly, {\#238}
      sy_mode, {\#239}
      sy_iff, {\#240}
      sy_func, {\#241}
      sy_pred, {\#242}
      sy_implies, {\#243}
      sy_st, {\#244}
      sy_holds, {\#245}
      sy_provided, {\#246}
      sy_means, {\#247}
      sy_of, {\#248}
      sy_defpred, {\#249}
      sy_deffunc, {\#250}
      sy_such, {\#251}
      sy_that, {\#252}
      sy_aggregate, {\#253}
      sy_and {\#254\endgroup}
   );

@ We have string representation for each of the token kinds, which is
useful for debugging purposes.

@<Token names for MScanner@>=
   TokenName: array[TokenKind] of string =
      ('', {\begingroup\tt  \#0  } 
       '', {  \#1  } 
       '', {  \#2  } 
       '', {  \#3  } 
       '', {  \#4  } 
       '', {  \#5  } 
       '', {  \#6  } 
       '', {  \#7  } 
       '', {  \#8  } 
       '', {  \#9  } 
       '', {  \#10 } 
       '', {  \#11 } 
       '', {  \#12 } 
       '', {  \#13 } 
       '', {  \#14 } 
       '', {  \#15 } 
       '', {  \#16 } 
       '', {  \#17 } 
       '', {  \#18 } 
       '', {  \#19 } 
       '', {  \#20 } 
       '', {  \#21 } 
       '', {  \#22 } 
       '', {  \#23 } 
       '', {  \#24 } 
       '', {  \#25 } 
       '', {  \#26 } 
       '', {  \#27 } 
       '', {  \#28 } 
       '', {  \#29 } 
       '', {  \#30 } 
       '', {  \#31 } 
       '', {  \#32 } 
       '', {! \#33 } 
       'from', { {\tt "} \#34 }
       'identify', {\# \#35 } 
       'thesis', { \$ \#36 } 
       'contradiction', {\% \#37 } 
       '&', {\AM\ \#38 } 
       'by', {' \#39 } 
       '(',  {( \#40 } 
       ')', {) \#41 } 
       'registration', {* \#42 } 
       'definition', {+ \#43 } 
       ',', {, \#44 }
       'notation', {- \#45 } 
       '...', {. \#46 } 
       'proof', {/ \#47 } 
       '', {0 \#48 } 
       '', {1 \#49 } 
       '', {2 \#50 } 
       '', {3 \#51 } 
       '', {4 \#52 } 
       '', {5 \#53 } 
       '', {6 \#54 } 
       '', {7 \#55 } 
       '', {8 \#56 } 
       '', {9 \#57 } 
       ':', {: \#58 }
       ';', {; \#59 }
       'now',    {< \#60 }
       '=',   {= \#61 }
       'end', {> \#62 }
       '', {? \#63 } 
       '', {@@ \#64 } 
       '', {A \#65 } 
       '', {B \#66 } 
       '', {C \#67 } 
       'vocabularies', {D \#68 }
       '', {E \#69 } 
       '', {F \#70 } 
       '', {G \#71 } 
       '', {H \#72 } 
       '', {I \#73 } 
       '', {J \#74 } 
       '', {K \#75 } 
       '', {L \#76 } 
       '', {M \#77 } 
       '', {N \#78 } 
       '', {O \#79 } 
       '', {P \#80 } 
       'def', {Q \#81 } 
       '', {R \#82 } 
       '', {S \#83 } 
       '', {T \#84 } 
       '', {U \#85 } 
       '', {V \#86 } 
       '', {W \#87 } 
       'symmetry', {X \#88 } 
       'coherence', {Y \#89 } 
       '$1`', {Z \#90 }
       '[', {[ \#91 }
       '', {{\rm`}\SP{\rm'} \#92 } 
       ']', {] \#93 } 
       '', {\lower3pt\hbox{$\widehat{\ }$} \shiftSix\ \#94 }
       '', {\_ \#95 }
       '', {` \#96 }
       'according', {a \#97 }
       '', {b \#98 }
       'reduce', {c \#99 }
       '', {d \#100}
       'equals', {e \#101}
       '', {f \#102}
       '', {g \#103}
       'with', {h \#104}
       '', {i \#105}
       '', {j \#106}
       '', {k \#107}
       '', {l \#108}
       '', {m \#109}
       '', {n \#110}
       '', {o \#111}
       '', {p \#112}
       '', {q \#113}
       'wrt', {r \#114}
       '', {s \#115}
       'to', {t \#116}
       '', {u \#117}
       '', {v \#118}
       'when', {w \#119}
       'axiom', {x \#120}
       '', {y \#121}
       '', {z \#122}
       '{', {  \#123}
       '', {\pipe\ \#124}
       '}', { \#125}
       '', {\TL\ \#126}
       'T127', {\#127}
       '', {\#128}
       'T129', {\#129}
       '', {\#130}
       'T131', {\#131}
       '', {\#132}
       '', {\#133}
       '', {\#134}
       'correctness', {\#135}
       'T136', {\#136}
       '', {\#137}
       '', {\#138}
       '', {\#139}
       'if', {\#140}
       '', {\#141}
       '', {\#142}
       '', {\#143}
       'is', {\#144}
       'are', {\#145}
       '', {\#146}
       'otherwise', {\#147}
       '', {\#148}
       '', {\#149}
       '', {\#150}
       '', {\#151}
       'T152', {\#152}
       '', {\#153}
       '', {\#154}
       '', {\#155}
       'ex', {\#156}
       'for', {\#157}
       '', {\#158}
       'define', {\#159}
       '', {\#160}
       'being', {\#161}
       'over', {\#162}
       '', {\#163}
       'canceled', {\#164}
       'do', {\#165}
       'does', {\#166}
       'or', {\#167}
       'where', {\#168}
       'non', {\#169}
       'not', {\#170}
       'cluster', {\#171}
       'attr', {\#172}
       '', {\#173}
       '(\#', {\#174}
       '\#)', {\#175}
       'environ', {\#176}
       '', {\#177}
       'begin', {\#178}
       '', {\#179}
       '', {\#180}
       '', {\#181}
       '', {\#182}
       '', {\#183}
       '', {\#184}
       'hence', {\#185}
       '', {\#186}
       '', {\#187}
       'hereby', {\#188}
       '', {\#189}
       '', {\#190}
       '', {\#191}
       'then', {\#192}
       '.=', {\#193}
       '', {\#194}
       '', {\#195}
       'synonym', {\#196}
       'antonym', {\#197}
       '', {\#198}
       '', {\#199}
       'let', {\#200}
       'take', {\#201}
       'assume', {\#202}
       'thus', {\#203}
       'given', {\#204}
       'suppose', {\#205}
       'consider', {\#206}
       '', {\#207}
       '', {\#208}
       '', {\#209}
       '', {\#210}
       '->', {\#211}
       'as', {\#212}
       'qua', {\#213}
       'be', {\#214}
       'reserve', {\#215}
       '', {\#216}
       '', {\#217}
       '', {\#218}
       '', {\#219}
       '', {\#220}
       '', {\#221}
       '', {\#222}
       '', {\#223}
       'set', {\#224}
       'selector', {\#225}
       'cases', {\#226}
       'per', {\#227}
       'scheme', {\#228}
       'redefine', {\#229}
       'reconsider', {\#230}
       'case', {\#231}
       'prefix', {\#232}
       'the', {\#233}
       'it', {\#234}
       'all', {\#235}
       'theorem', {\#236}
       'struct', {\#237}
       'exactly', {\#238}
       'mode', {\#239}
       'iff', {\#240}
       'func', {\#241}
       'pred', {\#242}
       'implies', {\#243}
       'st', {\#244}
       'holds', {\#245}
       'provided', {\#246}
       'means', {\#247}
       'of', {\#248}
       'defpred', {\#249}
       'deffunc', {\#250}
       'such', {\#251}
       'that', {\#252}
       'aggregate', {\#253}
       'and' {\#254\endgroup}
      )

@ \node{Reading a token.}
This tokenizes a Mizar article, using the scanner's \\{GetToken}
method. We can trace this \\{GetToken} back to its
implementation (\section\xref{MTokeniser.GetToken}). This, in turn,
depends on the \\{SliceIt} method (\section\xref{MTokeniser.SliceIt}).

This method is used to determine the next token
in \texttt{parser.pas}'s \\{Parse} function.

This assumes that |StartScanner| (\section\xref{StartScanner}) has
been invoked already, which initializes the \\{CurWord} token and
other variables.

Also important to observe: the \\{Kind} of the token is populated here.

\label{ReadToken}

@^Tokenization@>

@<Implementation for MScanner@>=
procedure ReadToken;
begin
   PrevWord:=CurWord; PrevPos:=CurPos;
   CurWord:=AheadWord; CurPos:=AheadPos;
   {'\_' is not allowed in an identifiers in the text proper}
   if (CurWord.Kind = sy_Begin)
   then gScanner^.Allowed['_']:=0;
   if (CurWord.Kind = sy_Error) and
         (CurWord.Nr = scTooLongLineErrorNr)
   then ErrImm(CurWord.Nr);
   gScanner^.GetToken; @/
   AheadWord.Kind:=TokenKind(gScanner^.fLexem.Kind);
   AheadWord.Nr:=gScanner^.fLexem.Nr;
   AheadWord.Spelling:=gScanner^.fStr;
   AheadPos:=gScanner^.fPos;
end;

@ \node{Loading a proof file.}
The \texttt{.prf} file is a file containing numerals, and its usage
eludes me. The format consists of multiple lines:

{Line 1:} Three non-negative integers are on the first line ``$M$ $S$ $P$'' 

{Line 2:} Contains $M$ non-negative integers separated by a
single whitespace

{Line 3:} Contains $S$ non-negative integers separated by a
single whitespace

{Line 4:} Contains $P$ non-negative integers separated by a
single whitespace.

\medbreak\noindent%
This function loads the contents of the \texttt{.prf} file. This
initializes the global variables |ModeMaxArgs|,
|StructureModeMaxArgs|, |PredMaxArgs|, then populates them.

@:File, prf}{File, \texttt{.prf}@>
@:prf file}{\texttt{.prf} File@>
@^\texttt{.prf} File@>

@<Implementation for MScanner@>=
procedure LoadPrf(const aPrfFileName:string);
var lPrf: text;
lModeMaxArgsSize,lStructModeMaxArgsSize,lPredMaxArgsSize,i,lInt,r: integer;
begin
   assign(lPrf,aPrfFileName+'.prf'); reset(lPrf);
   Read(lPrf,lModeMaxArgsSize,lStructModeMaxArgsSize,lPredMaxArgsSize);
   ModeMaxArgs.Init(lModeMaxArgsSize+1);
   r:=ModeMaxArgs.Insert(0);
   StructModeMaxArgs.Init(lStructModeMaxArgsSize+1);
   r:=StructModeMaxArgs.Insert(0);
   PredMaxArgs.Init(lPredMaxArgsSize+1);
   r:=PredMaxArgs.Insert(0);
   for i:=1 to lModeMaxArgsSize do
   begin Read(lPrf,lInt);
   r:=ModeMaxArgs.Insert(lInt);
   end;
   for i:=1 to lStructModeMaxArgsSize do
   begin Read(lPrf,lInt);
   r:=StructModeMaxArgs.Insert(lInt);
   end;
   for i:=1 to lPredMaxArgsSize do
   begin Read(lPrf,lInt);
   r:=PredMaxArgs.Insert(lInt);
   end;
   close(lPrf);
end;

@ We cleanup after using the \texttt{.prf} file.

@<Implementation for MScanner@>=
procedure DisposePrf;
begin
   ModeMaxArgs.Done;
   PredMaxArgs.Done;
   StructModeMaxArgs.Done;
end;

@ We construct an MScann object to scan a file.

\label{StartScanner}

@<Implementation for MScanner@>=
procedure StartScaner;
begin
   CurPos.Line:=1; CurPos.Col:=0;
   AheadWord.Kind:=TokenKind(gScanner^.fLexem.Kind);
   AheadWord.Nr:=gScanner^.fLexem.Nr;
   AheadWord.Spelling:=gScanner^.fStr;
   AheadPos:=gScanner^.fPos;
end;

@ We initialize a scanner for a file.

@<Implementation for MScanner@>=
procedure InitSourceFile(const aFileName,aDctFileName:string);
begin
   new(@! gScanner,InitScanning(aFileName,aDctFileName));
   StartScaner;
end;

@ When we're done with a scanner, we call the destructor for the MScanner.

@<Implementation for MScanner@>=
procedure CloseSourceFile;
begin
   dispose(gScanner,Done);
end;

@ We can combine the previous functions together to initialize a
scanner for a file (an article) and its dictionary file.

@<Implementation for MScanner@>=
procedure InitScanning(const aFileName,aDctFileName:string);
begin
   gScanner:=new(MScannPtr, InitScanning(aFileName,aDctFileName));
   StartScaner;
   LoadPrf(aDctFileName);
end;

@ We cleanup after scanning, saving a dictionary \XML/ file to an
``\texttt{.idx}'' file. This uses the global variable |EnvFileName|
declared in \texttt{mizenv.pas} (\section\xref{mizenv-global-vars}).

@^\texttt{.idx} file@>
@:File, idx}{File, \texttt{.idx}@>
@:idx File}{\texttt{.idx} File@>

@<Implementation for MScanner@>=
procedure FinishScanning;
begin
   gScanner^.fIdents.SaveXDct(EnvFileName+'.idx');
   CloseSourceFile;
   DisposePrf;
end;
