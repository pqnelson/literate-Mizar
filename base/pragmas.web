
@* [F] Detour: Pragmas.
This chapter is a ``detour'' because it is out of order for the
compiler, but it is a dependency for the next file
(\texttt{parseradditions.pas}). 

The \texttt{base/pragmas.pas} contains the global variables
which are toggled by pragmas like ``\texttt{::\$P+}''. This will
toggle the \\{ProofPragma}. In particular, when \\{ProofPragma} is
true, then Mizar will double check the proofs. When \\{ProofPragma} is
false, Mizar will skip the proofs.

@<pragmas.pas@>=
@<GNU License@>
unit pragmas;

interface

uses mobjects;

var
  @! VerifyPragmaOn,@!VerifyPragmaOff : NatSet;
  @! VerifyPragmaIntervals: NatFunc;
  @! SchemePragmaOn,@!SchemePragmaOff: NatSet;
  @! SchemePragmaIntervals : NatFunc;
  @! ProofPragma: Boolean = true; {check the proofs?} @#

procedure @? SetParserPragma(aPrg: string); @t\2@>
procedure @? InsertPragma(aLine: integer; aPrg: string); @t\2@>
procedure @? CompletePragmas(aLine: integer); @t\2@> @#

procedure @? CanceledPragma(@+const aPrg:string;@+ var aKind: char;@+ var aNbr: integer); @t\2@>

implementation @|@#

uses mizenv; @#


@ Cancelling a definition or theorem is handled with the
``\texttt{::\$C}'' pragma, which is administered only by the editors
of the MML. For example ``\texttt{::\$CD}'' will cancel a definition,
``\texttt{CT}'' will cancel a theorem, and ``\texttt{CS}'' cancels a scheme.

@p
procedure CanceledPragma(@+const aPrg:string;@+ var aKind: char;@+ var aNbr: integer);
 var lStr: string;
     k,lCod: integer;
begin
 aKind:=' ';
 if (Copy(aPrg,1,2) = '$C') then
  begin
   if (length(aPrg) >= 3) and (aPrg[3] in ['D','S','T']) then
    begin
     aKind:=aPrg[3];
     lStr:=TrimString(Copy(aPrg,4,length(aPrg)-3));
     aNbr:=1;
     if length(lStr) > 0 then
      begin
       k:=1;
       while (k <= length(lStr)) and (lStr[k] in ['0'..'9']) do inc(k);
       delete(lStr,k,length(lStr));
       if length(lStr) > 0 then
        Val(lStr,aNbr,lCod);
      end;
    end;
  end;
end;

@ The ``\texttt{::\$P+}'' pragma instructs Mizar to start checking the
proofs for correctness. The ``\texttt{::\$P-}'' pragma instructs Mizar
to skip checking proofs.

\label{SetParserPragma}

@p
procedure SetParserPragma(aPrg: string);
begin
   if copy(aPrg,1,3)='$P+' then 
   begin
      ProofPragma:=true;
   end;
   if copy(aPrg,1,3)='$P-' then
   begin
      ProofPragma:=false;
   end;
end;

@ The ``\texttt{::\$S+}'' pragma will tell Mizar to check the scheme references,
whereas ``\texttt{::\$S-}'' pragma tells Mizar to stop verifying
scheme references.

The ``\texttt{::\$V+}'' pragma enables the verifier, and the
``\texttt{::\$V-}'' pragma disables the verifier (skipping all
verification until it is re-enabled). 

@p
procedure InsertPragma(aLine: integer; aPrg: string);
begin
   if copy(aPrg,1,3)='$V+' then
   begin
      VerifyPragmaOn.InsertElem(aLine); @+
   end;
   if copy(aPrg,1,3)='$V-' then
   begin
      VerifyPragmaOff.InsertElem(aLine); @+
   end;

   if copy(aPrg,1,3)='$S+' then
   begin
      SchemePragmaOn.InsertElem(aLine); @+
   end;
   if copy(aPrg,1,3)='$S-' then
   begin
      SchemePragmaOff.InsertElem(aLine); @+
   end;
end;

@ The \\{CompletePragmas} function will compute the intervals for
which the pragmas are ``active'', then check whether the given line
number falls within the ``active range''.

@p
procedure CompletePragmas(aLine: integer);
var i,j,a,b : integer; f:boolean;
begin
  for i:=0 to VerifyPragmaOff.Count-1 do
   begin
     f:=false;
     a:=VerifyPragmaOff.Items^[i].X;
     for j:=0 to VerifyPragmaOn.Count-1 do
      begin
       b:=VerifyPragmaOn.Items^[j].X;
       if b >= a then
        begin
         VerifyPragmaIntervals.Assign(a,b);
         f:=true;
         break; @+
        end;
      end;
     if not f then VerifyPragmaIntervals.Assign(a,aLine);
   end;
  for i:=0 to SchemePragmaOff.Count-1 do
   begin
     f:=false;
     a:=SchemePragmaOff.Items^[i].X;
     for j:=0 to SchemePragmaOn.Count-1 do
      begin
       b:=SchemePragmaOn.Items^[j].X;
       if b >= a then
        begin
         SchemePragmaIntervals.Assign(a,b);
         f:=true;
         break; @+
        end;
      end;
     if not f then SchemePragmaIntervals.Assign(a,aLine);
   end;
end;

@ Now we initialize the global variables declared in this module.

@p
begin

   VerifyPragmaOn.Init(10,10);
   VerifyPragmaOff.Init(10,10);
   VerifyPragmaIntervals.InitNatFunc(10,10);
   SchemePragmaOn.Init(10,10);
   SchemePragmaOff.Init(10,10);
   SchemePragmaIntervals.InitNatFunc(10,10);

end.

