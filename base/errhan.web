
@* [F] Error handling.
There are a few common error reporting routines bundled together. We
should recall Borland \PASCAL/'s \\{RunError} method stops the execution of
the program and generates a run-time error. The other
primitive \PASCAL/ function worth remembering is \\{Halt} which takes
an error exit code, halts the program, and returns control to the
calling program. For \PASCAL/ specific error codes, consult:

\href{https://wiki.freepascal.org/RunError}{{\tt https://wiki.freepascal.org/RunError}}

@<errhan.pas@>=
  @<GNU License@>

unit errhan;

interface @;@|@/

@<Interface for \texttt{errhan.pas}@>@;

implementation @; @|@/

uses mconsole,mizenv; @/

@<Implementation for \texttt{errhan.pas}@>@; @+ @t\2@>

end;

@ We have a few custom types and internal variables describing the
state of the Mizar error handler.

The \\{Position} type is especially important for the Parser, which
will store the metadata in the abstract syntax tree. The starchy
reader may wish to consult the \POSIX/ Standard's \href{https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap03.html#tag_03_75}{definition}
(3.75 of Volume~I) for ``column position'' which states, ``Column
positions are numbered starting from 1.'' Coincidentally, this would
imply Mizar cannot properly parse files longer than $2^{31}-1$ columns
wide (or $2^{63}-1$ columns wide for 64-bit computers).

\label{type:Position}

@<Interface for \texttt{errhan.pas}@>=
type Position = @<Declare |Position| as |record|@>;
     ErrorReport = @+ procedure(Pos:Position; ErrNr:integer); @t\2 @>

const ZeroPos : Position = (Line:0; Col:0); @#

var  CurPos:    Position; {current position}
     ErrorNbr:  integer;  {current error number}

     PutError: ErrorReport = nil; {reporter for errors}

     RTErrorCode: integer = 0; {runtime error code}
     OverflowErroor: boolean = false; {overflow error? They're horrible, treat accordingly}

@ Position is just a pair of integers recording the line and offset
(``column'').

@<Declare |Position| as |record|@>=
record Line,Col: integer end

@ The implementation begins as we would expect/hope. If we have
a \emph{preferred} error reporter already present in |PutError|, then
we just use it. If we have toggled |StopOnError| to true, then we
should end the program here (with a message).

If we want to report an error at the |CurrPos| (current position),
then we have a helper function do that for us.

The |Error| and |ErrImm| procedures are both used in the parser.

\label{ErrImm}

@<Interface for \texttt{errhan.pas}@>=
procedure @? Error(Pos:Position; ErrNr:integer); @t\2@>
procedure @? ErrImm(ErrNr:integer);

@ @<Implementation for \texttt{errhan.pas}@>=
procedure Error(Pos:Position; ErrNr:integer);
begin
   inc(ErrorNbr);
   if @@PutError <> nil then PutError(Pos,ErrNr);
   if StopOnError then 
   begin 
      DrawMessage('Stopped on first error',''); 
      Halt(1); @+
   end;
end; @#

procedure ErrImm(ErrNr:integer);
begin
 Error(CurPos,ErrNr);
end;

@ We also can write errors to a file. This requires keeping track of
the file (dubbed |Errors|) and whether it has been opened or not (in
the Boolean condition |OpenedErrors|).

Note this takes advantage of |with| to destructure |Pos| into a |Line|
and |Col| for us.

\label{WriteError}

@<Interface for \texttt{errhan.pas}@>=
procedure @? WriteError(Pos:Position; ErrNr:integer);

@ @<Implementation for \texttt{errhan.pas}@>=
var
  Errors: text; {file name for errors file}
  OpenedErrors: boolean = false; {have we opened it yet?}

procedure WriteError(Pos:Position; ErrNr:integer);
begin
 if not OpenedErrors then RunTimeError(2001);
 with Pos do WriteLn(Errors,Line,' ',Col,' ',ErrNr);
end;

@ \node{Opening an errors file.}%
We can open an errors file, which will reset the |ErrorNbr| counter to
zero and re-initialize |CurPos| to line 1 and column 1.

When |PutError| is |nil|, we initialize it to be |WriteError|.

@<Interface for \texttt{errhan.pas}@>=
procedure @? OpenErrors(FileName: string);

@ @<Implementation for \texttt{errhan.pas}@>=
procedure OpenErrors(FileName: string);
begin
   if ExtractFileExt(FileName)='' then FileName:=FileName+'.err';
   Assign(Errors,FileName); @/
   without_io_checking(Rewrite(Errors)); {Open the |FileName|}
   @<If cannot open the |FileName|, report an error and halt@>;
   @<Initialize \texttt{errhan.pas} state variables@>; 
   @<Set current position to first line, first column@>;
   if @@PutError = nil then PutError:=WriteError;
end;

@ @<If cannot open the |FileName|, report an error and halt@>=
   if IOResult <> 0 then
   begin
      DrawMessage('Can''t open errors file '''+FileName+''' for writing','');
      halt(1);
   end

@ @<Initialize \texttt{errhan.pas} state variables@>=
   OpenedErrors:=true;
   ErrorNbr:=0

@ @<Set current position to first line, first column@>=
   with CurPos do begin Line:=1; Col:=1 end

@ Appending errors to the errors file. This isn't used anywhere in Mizar.
It may be instructive for the reader to compare this to \\{OpenErrors}.

@<Interface for \texttt{errhan.pas}@>=
procedure @? AppendErrors(FileName: string);

@ @<Implementation for \texttt{errhan.pas}@>=
procedure AppendErrors(FileName: string); {unused}
begin
 if ExtractFileExt(FileName)=''  then FileName:=FileName+'.err';
 Assign(Errors,FileName); @/
 @<Initialize \texttt{errhan.pas} state variables@>; @/
 @<Set current position to first line, first column@>; @/
 without_io_checking(append(Errors));
 if IOResult<>0 then Rewrite(Errors);
end;

@ We can also close the errors file and unset the |Errors| variable,
``forgetting'' where we logged the errors. This does not appear to be
used anywhere in Mizar.

@<Interface for \texttt{errhan.pas}@>=
procedure @? EraseErrors;

@ @<Implementation for \texttt{errhan.pas}@>=
procedure EraseErrors;
begin
 if OpenedErrors then
  begin
   OpenedErrors:=false;
   close(Errors); erase(Errors);
  end;
end;

@ We can also just close the errors file. This is used
in \texttt{monitor.pas}.

@<Interface for \texttt{errhan.pas}@>=
procedure @? CloseErrors;

@ @<Implementation for \texttt{errhan.pas}@>=
procedure CloseErrors;
begin
 if OpenedErrors then
  begin
   OpenedErrors:=false;
   close(Errors);
  end;
end;

@ Like I said, overflow errors are especially problematic. If/when
they occur, we should just bail out immediately. Curiously,
Free \PASCAL/ uses the 202 error for stack overflow errors, and 203
for heap overflow errors. Mizar uses the 97 error code for overflow errors.

@<Interface for \texttt{errhan.pas}@>=
procedure @? OverflowError(ErrorCode:word);

@ @<Implementation for \texttt{errhan.pas}@>=
procedure OverflowError(ErrorCode:word);
begin
 RTErrorCode:=ErrorCode;
 OverflowErroor:=true;
 RunError(97);
end;

@ We have an assertion utility to check if a |Cond| is |true|. When it
is |false|, we should report a runtime error (i.e., update |RTErrorCode|
and invoke |RunError(98)|). Free \PASCAL/'s \\{assert} function
generates a 227 ``Assertion failed error'' error code upon failure.

\label{MizAssert}

@<Interface for \texttt{errhan.pas}@>=
procedure @? MizAssert (ErrorCode:word; Cond: Boolean);

@ @<Implementation for \texttt{errhan.pas}@>=
procedure MizAssert( ErrorCode:word; Cond: Boolean );
begin
 if not Cond then
  begin
   RTErrorCode:=ErrorCode;
   RunError(98);
  end;
end;

@ Last, we have a catchall for runtime errors encountered.


@<Interface for \texttt{errhan.pas}@>=
procedure @? RunTimeError(ErrorCode:word);

@ @<Implementation for \texttt{errhan.pas}@>=
procedure RunTimeError(ErrorCode:word);
begin
 RTErrorCode:=ErrorCode;
 RunError(99);
end;
