
@* [F] Weakly strict Mizar article.
The parser ``eats in'' a mizar article, then produces
a \texttt{.wsx} (weakly strict Mizar) \XML/ file containing the
abstract syntax tree, and also a \texttt{.frt} article containing the
formats for the article.

This strategy should be familiar to anyone who has looked into
compilers and interpreters: transform the abstract syntax tree into an
intermediate representation, then transform the intermediate
representations in various passes.

This module will transform the parse tree to an abstract syntax tree
in \XML/ format.

@^\texttt{.wsx} file@>
@:wsx file}{\texttt{.wsx} file@>
@:File, wsx}{File, \texttt{.wsx}@>
@^Weakly strict Mizar@>
@^\texttt{.frt} file@>
@:frt file}{\texttt{.frt} file@>
@:File, frt}{File, \texttt{.frt}@>

@<wsmarticle.pas@>=

@<GNU License@>@;
unit wsmarticle;

interface @|@#

uses mobjects, errhan, mscanner, syntax, abstract_syntax, xml_dict,
xml_inout; @#

@<Publicly declared types in \texttt{wsmarticle.pas}@> @;

const @|@/
@<Publicly declared constants in \texttt{wsmarticle.pas}@> @;

@<Publicly declared functions in \texttt{wsmarticle.pas}@> @; @t\2@>

@<Global variables publicly declared in \texttt{wsmarticle.pas}@> @t\1@>@; @#

implementation @|@#

uses mizenv, mconsole, librenv, scanner, xml_parser
mdebug ,info @+ end_mdebug;

@<Implementation for \texttt{wsmarticle.pas}@>@t\2@>@; @#

end.

@ \node{Exercise.} We will create a class hierarchy for the abstract
syntax trees for Mizar. A lot of this is boiler-plate. The reader is
invited to write a couple of programs which will:
\enumerate
\item read in an EBNF-like grammar and emit the class hierarchy for
its abstract syntax tree.
\item read in an EBNF-like grammar, and emit the class hierarchy for
generating the \XML/ for it.
\endenumerate

\medbreak\noindent%
After all, if you look at the sheer number of sections in this file,
it's staggeringly huge. But a lot of it is boiler-plate.

@^Exercises@>

@ @<Publicly declared types in \texttt{wsmarticle.pas}@>=

@ @<Publicly declared functions in \texttt{wsmarticle.pas}@>=

@ @<Implementation for \texttt{wsmarticle.pas}@>=

@* [S] Weakly strict text proper.
Mizar provides a grammar for its syntax in the file
\centerline{\texttt{/usr/local/doc/mizar/syntax.txt}}
It uses a variant of EBNF:
\item{$\bullet$} Terminal symbols are written \texttt{"in quotes"}
\item{$\bullet$} Production rules are separated by vertical lines ``$\pipe$''
\item{$\bullet$} Optional symbols are placed in \texttt{[brackets]}
\item{$\bullet$} Repeated items zero or more times are placed
in \texttt{\LB braces\RB}.
\item{$\bullet$} Rules end in a period ``.''

\noindent%
We will freely quote from \texttt{syntax.txt}, rearranging the rules
as needed to discuss the relevant parts of Mizar's grammar. We will
write the \texttt{syntax.txt} passages in typewriter font.

We should recall the syntax for text items:
\medbreak
{\advance\leftskip by3pc\obeylines\tt
Text-Proper = Section \LB\ Section \RB\ .\smallbreak

Section = "begin" \LB\ Text-Item \RB\ .\smallbreak

Text-Item = Reservation
\quad\pipe\ Definitional-Item 
\quad\pipe\ Registration-Item 
\quad\pipe\ Notation-Item 
\quad\pipe\ Theorem 
\quad\pipe\ Scheme-Item 
\quad\pipe\ Auxiliary-Item .\smallbreak

Definitional-Item = Definitional-Block ";" .\smallbreak

Registration-Item = Registration-Block ";" .\smallbreak

Theorem = "theorem" Compact-Statement .\smallbreak

Compact-Statement = Proposition Justification ";" .\smallbreak

Justification = Simple-Justification \pipe\ Proof .\smallbreak

Auxiliary-Item = Statement \pipe\ Private-Definition .
\par}
\medbreak\noindent%
These are the different syntactic classes for ``top-level statements''
in the text (not the environment header) of a Mizar article. The
interested reader can investigate the \texttt{syntax.txt} file more
fully to get all the block statements in Mizar. We have already made
these different kinds of blocks syntactic values of \\{BlockKind}
earlier (\section\xref{type:BlockKind}). Now we want to be able to
translate them into English. We will just skip
ahead and make these different syntactic classes into values of an
enumerated type.

@^EBNF@>
@^Grammar, for Mizar@>
@:Syntax.txt}{\texttt{syntax.txt}@>

@<Publicly declared constants in \texttt{wsmarticle.pas}@>=
   BlockName: array[BlockKind] of string = @|@/
      ('Text-Proper', {blMain}
       'Now-Reasoning', {blDiffuse}
       'Hereby-Reasoning', {blHereby}
       'Proof', {blProof}
       'Definitional-Block', {blDefinition}
       'Notation-Block', {blNotation}
       'Registration-Block', {blRegistration}
       'Case', {blCase}
       'Suppose', {blSuppose}
       'Scheme-Block' {blPublicScheme} 
      );

@ \node{Class hierarchy for blocks.}
We can now translate the grammar for blocks into a class hierarchy.
The ``text proper'' extends an abstract ``block'' statement. We will
provide factory methods ``\\{wsTextProper.NewBlock}'' and ``\\{NewItem}'' for
adding a new block (and item) contained within the caller ``block''.
We will be tracking the ``kind'' of block (\section\xref{type:BlockKind}),
and the text proper will need to track which article it belongs to.

All the various kinds of blocks are handled with this one class:
proofs, definitions, notations, registrations, cases, suppose blocks,
schemes, hereby statements, and so on. However, some of these blocks
have extra content which needs their own nodes in the abstract syntax
tree, especially Definitions
(\section\section\xref{esm:ast:definitions} \emph{et seq.}) and
Registrations (\section\section\xref{esm:ast:registrations} \emph{et seq}.).

\medbreak
\figure
\centerline{\graphics{img/classdiagram-3}}
%\centerline{\includegraphics{img/classdiagram-0.pdf}}
% \epsfbox{img/termclassUML.eps} % for non-PDF output
\caption{UML class diagram for \\{wsBlock} and related classes.}
\endfigure
\medbreak\noindent%
It is important to stress: \textbf{wsBlock instances represent all statements
which are block statements and all other statements are wsItem instances.}
Looking back at the different kinds of blocks, you see that they are
``block openers'' and will expect to have a matching ``\texttt{end}''
statement closing it.

\label{wsTextProper:ast}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   wsBlockPtr = ^wsBlock; @/
   wsBlock = object(MObject) @t\1@> @/
      nBlockKind: BlockKind; @/
      nItems: PList; {list of \\{wsItem} objects}
      nBlockPos,nBlockEndPos: Position; @/
      constructor Init(aBlokKind:BlockKind@+;@+ const aPos:Position); @t\2@>
      destructor Done; virtual; @t\2\2\2@> 
   end; @#

   @<Weakly strict Item class@>; @#

   wsTextProperPtr = ^wsTextProper; @/
   wsTextProper = object(wsBlock) @t\1@> @/
      nArticleID, nArticleExt: string; @/
      constructor Init(const aArticleID,aArticleExt:string@+;@+ const aPos:Position); @t\2@> 
      destructor Done; virtual; @t\2@>

      function NewBlock(aBlockKind:BlockKind@+;@+ const aPos:Position): wsBlockPtr; @t\2@>
      function NewItem(aItemKind:ItemKind@+;@+ const aPos:Position): wsItemPtr; @t\2\2\2@> 
   end;

@ \node{Constructor.}
We initialize using the inherited \\{wsBlock} constructor
(\section\xref{wsBlock.Init}). The ``text proper'' refers to a block
which is as top-level as possible, so we construct it as a block whose
kind is \texttt{blMain} located at \\{aPos}.

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor wsTextProper.Init(const aArticleID, aArticleExt: string;@+ const aPos:Position);
begin
   inherited Init(blMain,aPos);
   nArticleID:=aArticleID;
   nArticleExt:=aArticleExt;
end; @#

destructor wsTextProper.Done;
begin
   inherited Done;
end;

@ \node{Adding statements into a block.} we will add a block to a
``text proper'', which will then construct a block which tracks the
caller as its containing block. This requires giving the kind of the
newly minted block (\section\xref{type:BlockKind}).

Similarly, when constructing an item which is contained in the block,
we need to pass along the item kind (\section\xref{type:ItemKind}).

@<Implementation for \texttt{wsmarticle.pas}@>=
function wsTextProper.NewBlock(aBlockKind: BlockKind@+;@+ const aPos:Position): wsBlockPtr;
begin
   result:=new(WSBlockPtr,Init(aBlockKind,CurPos));
end; @#

function wsTextProper.NewItem(aItemKind:ItemKind@+;@+ const aPos:Position): wsItemPtr;
begin
   result:=new(wsItemPtr,Init(aItemKind,CurPos));
end;

@ \node{Block Constructor.} Curiously, the \\{MObject} constructor
(\section\xref{MObject.Init}) is not invoked when constructing
a \\{wsBlock}. We will also need the position (\section\xref{type:Position})
of the block in the article. The collection of items in the block is
initialized to be empty.

\label{wsBlock.Init}

@p
constructor wsBlock.Init(aBlokKind: BlockKind@+;@+ const aPos:Position);
begin
   nBlockKind:=aBlokKind;
   nBlockPos:=aPos;
   nBlockEndPos:=aPos;
   nItems:=New(PList,Init(0));
end; @#

destructor wsBlock.Done;
begin
   dispose(nItems,Done);
   inherited Done;
end;

@ \node{Text items.}
An item requires its ``kind'' (\section\xref{type:ItemKind}) for its
syntactic class.

\label{TextItem:ast}

@<Weakly strict Item class@>=
   wsItemPtr = ^wsItem; @/
   wsItem = object(MObject) @t\1@> @/
      nItemKind: ItemKind; @/
      nItemPos,nItemEndPos: Position; @/
      nContent: PObject; @/
      nBlock: wsBlockPtr; @/
      constructor Init(aItemKind:ItemKind@+;@+ const aPos:Position); @t\2@>
      destructor Done; virtual; @t\2\2\2@> 
   end;

@ \node{Constructor}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor wsItem.Init(aItemKind: ItemKind@+;@+ const aPos:Position);
begin
   nItemKind:=aItemKind;
   nItemPos:=aPos;
   nItemEndPos:=aPos;
   nContent:=nil;
   nBlock:=nil;
end;

destructor wsItem.Done;
begin
   if nBlock <> nil then dispose(nBlock,Done);
   inherited Done;
end;

@ \node{Pragmas.}
Mizar supports pragmas (analogous to conditional compilation).

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   PragmaPtr = ^PragmaObj; @/
   PragmaObj = object(MObject) @t\1@> @/
      nPragmaStr: string; @/
      constructor Init(aStr: string); @t\2\2\2@>
   end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor PragmaObj.Init(aStr: string);
begin
   nPragmaStr:=aStr;
end;

@ \node{Labels and propositions.} A proposition is just a sentence
with a label. We will need to represent both of these in our abstract
syntax tree.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   LabelPtr = ^LabelObj; @/
   LabelObj = object(MObject)  @t\1@> @/
      nLabelIdNr: integer; @/
      nLabelPos: Position; @/
      constructor Init(aLabelId:integer@+;@+ const aPos:Position); @t\2\2\2@>
   end; @#

   PropositionPtr = ^PropositionObj; @/
   PropositionObj = object(mObject)  @t\1@> @/
      nLab: LabelPtr; @/
      nSntPos: Position; @/
      nSentence: FormulaPtr; @/
      constructor Init(aLab:LabelPtr; aSentence:FormulaPtr@+;@+ const aSntPos:Position); @t\2@>
      destructor Done; virtual; @t\2\2\2@>
   end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor LabelObj.Init(aLabelId: integer@+;@+ const aPos:Position);
begin
   nLabelIdNr:=aLabelId;
   nLabelPos:=aPos;
end; @#

constructor PropositionObj.Init(alab:LabelPtr; aSentence: FormulaPtr@+;@+ const aSntPos:Position);
begin
   nLab:=aLab;
   nSntPos:=aSntPos;
   nSentence:=aSentence;
end;

destructor PropositionObj.Done;
begin
   dispose(nLab,Done);
   dispose(nSentence,Done);
end;

@ \node{References.} References are either local (i.e., from the file
being processed) or library (i.e., from the Mizar math library). The
grammar for library references is rather generous. The basic rules are
that we have theorem references,
$$\<article>\hbox{ \texttt{":"} }\<number>$$
and definition references,
$$\<article>\hbox{ \texttt{":def "} }\<number>$$
and scheme references,
$$\<article>\hbox{ \texttt{":sch "} }\<number>$$
What makes it tricky is we also allow multiple references from the
same article to just add a comma followed by the theorem number
$$\<article>\hbox{ \texttt{":"} }\<number>\ \LB\hbox{ \texttt{","}}\<number>\ \RB$$
or a comma followed by definition numbers
$$\<article>\hbox{ \texttt{":def "} }\<number>\ \LB\hbox{ \texttt{"," "def "} }\<number>\ \RB$$
So far, so good, right? Now we can go even further, mixing theorem
references and definitions references from the same article.

We recall the grammar for references:
$$\vbox{\halign{$#$\hfil\cr
\<Reference> ::= \<Local-Reference> \mid \<Library-Reference> .\cr
\<Scheme-Reference> ::= \<Local-Scheme-Reference> \mid
\<Library-Scheme-Reference> .\cr
\<Local-Reference> ::= \<Label-Identifier> .\cr
\<Local-Scheme-Reference> ::= \<Scheme-Identifier> .\cr
\<Library-Reference> ::= \<Article-Name>
\hbox{ \texttt{":"} } ( \<Theorem-Number> \mid \hbox{ \texttt{"def"} } \<Definition-Number> )\cr
\quad \LB\ \hbox{ \texttt{","} } ( \<Theorem-Number> \mid \hbox{ \texttt{"def"} }\<Definition-Number> ) \RB\ .\cr
\<Library-Scheme-Reference> ::= \<Article-Name> \hbox{ \texttt{":" "sch"} } \<Scheme-Number> .\cr
}}$$

@ \node{Class structure.} We have an abstract ``reference'' class,
which is either a local reference (to a label within the article) or a
library reference (to some result in the MML).

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ReferenceKind = (LocalReference,
                    TheoremReference,
                    DefinitionReference
                   );

   @<Inference kinds (\texttt{wsmarticle.pas})@>;
   ReferencePtr = ^ReferenceObj; @/
   ReferenceObj =
      object(MObject) @/
         nRefSort: ReferenceKind; @/
         nRefPos: Position @t\2@>; @/
      end;

@ \node{Local references.}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   LocalReferencePtr = ^LocalReferenceObj; @/
   LocalReferenceObj =
      object(ReferenceObj) @t\1@> @/
         nLabId: integer; @/
         constructor Init(aLabId:integer@+;@+ const aPos:Position); @t\2\2\2@>
      end; @#


@ \node{Constructor.} The reference constructors simply populate the
appropriate fields in the reference, and the position in the article's
text.

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor LocalReferenceObj.Init(aLabId:integer; const aPos:Position);
begin
   nRefSort:=LocalReference;
   nLabId:= aLabId;
   nRefPos:=aPos
end;

@ \node{Library references.} This is the abstract class representing
either theorem or definition references from an article.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   LibraryReferencePtr = ^LibraryReferenceObj; @/
   LibraryReferenceObj =
      object(ReferenceObj) @/
         nArticleNr: integer @t\2@> ;@/
      end;@t\1@>@;

@ \node{Theorem and definition references.} I am of a divided mind
here. On the one hand, we can see that a \\{LibraryReference} is a tagged union
already, and we do not need separate subclasses for theorem references
and definition references. On the other hand, separate subclasses
makes things easier when emitting \XML/ for the abstract syntax tree
for a Mizar article. Since it is more clear with separate subclasses,
and it is better to be clear than clever, I think this design is wiser
than the alternatives.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   TheoremReferencePtr = ^TheoremReferenceObj; @/
   TheoremReferenceObj =
      object(LibraryReferenceObj) @t\1@> @/
         nTheoNr:integer; @/
         constructor Init(aArticleNr,aTheoNr:integer@+;@+ const aPos:Position); @t\2\2\2@>
      end; @#

   DefinitionReferencePtr = ^DefinitionReferenceObj; @/
   DefinitionReferenceObj =
      object(LibraryReferenceObj) @t\1@> @/
         nDefNr:integer; @/
         constructor Init(aArticleNr,aDefNr:integer@+;@+ const aPos:Position); @t\2\2\2@>
      end;

@ \node{Constructor.} The reference constructors simply populate the
appropriate fields in the reference, and the position in the article's
text.

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor TheoremReferenceObj.Init(aArticleNr,aTheoNr:integer; const aPos:Position);
begin
   nRefSort:=TheoremReference;
   nArticleNr:=aArticleNr;
   nTheoNr:=aTheoNr;
   nRefPos:=aPos
end; @#

constructor DefinitionReferenceObj.Init(aArticleNr,aDefNr:integer; const aPos:Position);
begin
   nRefSort:=DefinitionReference;
   nArticleNr:=aArticleNr;
   nDefNr:=aDefNr;
   nRefPos:=aPos
end;

@ \node{Justifications.}
The grammar for justifications looks like:

\medbreak
{\obeylines\parindent=0pt\tt
Justification = Simple-Justification
\quad\pipe\ Proof .\smallbreak

Simple-Justification = Straightforward-Justification
\quad\pipe\ Scheme-Justification .\smallbreak

Proof = "proof" Reasoning "end" .\smallbreak

Straightforward-Justification = [ "by" References ] .\smallbreak

Scheme-Justification = "from" Scheme-Reference [ "(" References ")" ] .
\par}
\medbreak\noindent%
Proof blocks are already represented as a \\{Block} object. We just
need to represent the other kinds of justifications as nodes in the
abstract syntax tree.

@ The different kinds of inference, since a \\{Justification} is a
tagged union of sorts.

@<Inference kinds (\texttt{wsmarticle.pas})@>=
   InferenceKind = (infError,
                    infStraightforwardJustification,
                    infSchemeJustification,
                    infProof,
                    infSkippedProof)

@ \node{Class structure for justifications.}
The class hierarchy for justifications reflects the grammar we just
discussed.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   JustificationPtr = ^JustificationObj; @/
   JustificationObj =
      object(MObject) @t\1@> @/
         nInfSort: InferenceKind; @/
         nInfPos: Position; @/
         constructor Init(aInferSort:InferenceKind@+;@+ const aPos: Position); @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor JustificationObj.Init(aInferSort:InferenceKind@+;@+ const aPos: Position);
begin
   nInfSort:=aInferSort;
   nInfPos:=aPos;
end; @#

@ \node{Simple justifications.}
These are either ``\texttt{by}'' a list of references, or
``\texttt{from}'' a scheme.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   SimpleJustificationPtr = ^SimpleJustificationObj; @/
   SimpleJustificationObj =
      object(JustificationObj) @t\1@> @/
         nReferences: PList; @/
         constructor Init(aInferSort:InferenceKind@+;@+ const aPos: Position); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor SimpleJustificationObj.Init(aInferSort:InferenceKind@+;@+ const aPos: Position);
begin
   inherited Init(aInferSort,aPos);
   nReferences:=new(Plist,Init(0));
end; @#

destructor SimpleJustificationObj.Done;
begin
   dispose(nReferences,Done);
   inherited Done;
end;

@ \node{Straightforward justification.}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   StraightforwardJustificationPtr = ^StraightforwardJustificationObj; @/
   StraightforwardJustificationObj =
      object(SimpleJustificationObj) @t\1@>@/
         nLinked: boolean; @/
         nLinkPos: Position; @/
         constructor Init(const aPos:Position;@+ aLinked:boolean;@+ const aLinkPos:Position); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor StraightforwardJustificationObj.Init(const aPos:Position@t\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1@>;
 aLinked:boolean;
 const aLinkPos:Position)@t\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2@>;
begin
   inherited Init(infStraightforwardJustification,aPos);
   nLinked:=aLinked;
   nLinkPos:=aLinkPos;
end; @#

destructor StraightforwardJustificationObj.Done;
begin
   inherited Done;
end;

@ \node{Scheme justification.}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   SchemeJustificationPtr = ^SchemeJustificationObj; @/
   SchemeJustificationObj =
      object(SimpleJustificationObj) @t\1@> @/
         nSchFileNr: integer; {0 for schemes from current article and positive for library references}
         nSchemeIdNr: integer; {a number of a scheme for library reference |nSchFileNr > 0| or
                                 a number of an identifier name for scheme name from current article}
         nSchemeInfPos: Position; @/
         constructor Init(const aPos:Position;@+ aArticleNr,aNr:integer); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor SchemeJustificationObj.Init(const aPos:Position;@+ aArticleNr,aNr:integer);
begin
   inherited Init(infSchemeJustification,aPos);
   nSchFileNr:=aArticleNr;
   nSchemeIdNr:=aNr;
   nSchemeInfPos:=aPos;
end; @#

destructor SchemeJustificationObj.Done;
begin
   inherited Done;
end;

@* [S] Schemes.
The grammar for schemes looks like:
\medbreak
{\obeylines\parindent=0pt\tt%\ninett\baselineskip=11pt
Scheme-Item = Scheme-Block ";" .\smallbreak

Scheme-Block = "scheme" Scheme-Identifier "\LB" Scheme-Parameters "\RB" ":"
\quad Scheme-Conclusion ["provided" Scheme-Premise \LB "and" Scheme-Premise\RB]
\quad  ("proof" \pipe\ ";") Reasoning "end" .\smallbreak

Scheme-Identifier = Identifier .\smallbreak

Scheme-Parameters = Scheme-Segment { "," Scheme-Segment } .\smallbreak

Scheme-Conclusion = Sentence .\smallbreak

Scheme-Premise = Proposition .\smallbreak

Scheme-Segment = Predicate-Segment \pipe\ Functor-Segment .\smallbreak

Predicate-Segment =
\quad Predicate-Identifier \LB "," Predicate-Identifier\RB\ \rlap{"[" [Type-Expression-List] "]" .}\smallbreak

Predicate-Identifier = Identifier .\smallbreak

Functor-Segment =
\quad Functor-Identifier \LB "," Functor-Identifier\RB\ "(" \rlap{[Type-Expression-List] ")" Specification .}\smallbreak

Functor-Identifier = Identifier .
\par}
\medbreak\noindent%
We begin with the abstract syntax for scheme parameters.

@ \node{Class hierarchy for schemes.}
We need ``predicate segments'' and ``functor segments'' for the
second-order variable parameters to the scheme.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   SchemeSegmentKind = (PredicateSegment,FunctorSegment); @#

   SchemeSegmentPtr = ^SchemeSegmentObj; @/
   SchemeSegmentObj =
      object(MObject) @t\1@> @/
         nSegmPos: Position; @/
         nSegmSort: SchemeSegmentKind; @/
         nVars: PList; @/
         nTypeExpList: PList; @/
         constructor Init(const aPos:Position;@+ aSegmSort:SchemeSegmentKind;
                          aVars,aTypeExpList: PList); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor SchemeSegmentObj.Init(const aPos:Position@t\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1@>;
aSegmSort:SchemeSegmentKind;
                             aVars,aTypeExpList: PList@t\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2@>);
begin
   nSegmPos:=aPos;
   nSegmSort:=aSegmSort;
   nVars:=aVars;
   nTypeExpList:=aTypeExpList;
end; @#

destructor SchemeSegmentObj.Done;
begin
   dispose(nVars,Done);
   dispose(nTypeExpList,Done);
end; @# 

@ \node{Segment variables for schemes.}
We need ``predicate segments'' and ``functor segments'' for the
second-order variable parameters to the scheme.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   PredicateSegmentPtr = SchemeSegmentPtr; @/
   FunctorSegmentPtr = ^FunctorSegmentObj; @/
   FunctorSegmentObj =
      object(SchemeSegmentObj) @t\1@> @/
         nSpecification: TypePtr; @/
         constructor Init(const aPos:Position;@+
                          aVars,aTypeExpList: PList;@+ aSpecification: TypePtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor FunctorSegmentObj.Init(const aPos:Position@t\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1@>;
                                   aVars,aTypeExpList: PList; aSpecification: TypePtr@t\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2@>);
begin
   inherited Init(aPos,FunctorSegment,aVars,aTypeExpList);
   nSpecification:=aSpecification;
end; @#

destructor FunctorSegmentObj.Done;
begin
   dispose(nSpecification,Done);
   inherited Done;
end; @#

@ \node{Scheme.} A \\{Scheme} object is the parent class
of \\{MSScheme} objects in \texttt{first\_identification.pas}.
But it does not appear to be used anywhere else. This has no place in
the abstract syntax tree, for example.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   SchemePtr = ^SchemeObj; @/
   SchemeObj =
      object(MObject) @t\1@> @/
         nSchemeIdNr: integer; @/
         nSchemePos: Position; @/
         nSchemeParams: PList; @/
         nSchemeConclusion: FormulaPtr; @/
         nSchemePremises: PList; @/
         constructor Init(aIdNr:integer@+;@+ const aPos:Position;@+ aParams:PList;@+
                          aPrems:PList; aConcl:FormulaPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor SchemeObj.Init(aIdNr:integer@t\1\1\1\1\1\1\1\1\1\1\1\1@>;
const aPos:Position@t\1@>; aParams:PList;
                           aPrems:PList; aConcl:FormulaPtr@t\2\2\2\2\2\2\2\2\2\2\2\2\2@>);
begin
   nSchemeIdNr:=aIdNr;
   nSchemePos:=aPos;
   nSchemeParams:=aParams;
   nSchemeConclusion:=aConcl;
   nSchemePremises:=aPrems;
end; @#

destructor SchemeObj.Done;
begin
   dispose(nSchemeParams,Done);
   dispose(nSchemeConclusion,Done);
   dispose(nSchemePremises,Done);
end;

@ \node{Reservations.}
We can ``reserve'' an identifier and its type, so we do not need to
quantify over it for each theorem. The grammar for it:
\medbreak
{\obeylines\parindent=0pt\tt
Reservation = "reserve" Reservation-Segment \rlap{$\LB$ "," Reservation-Segment $\RB$ ";" .}\smallbreak

Reservation-Segment = Reserved-Identifiers "for" Type-Expression .\smallbreak

Reserved-Identifiers = Identifier $\LB$ "," Identifier $\RB$ .
\par}

\medbreak\noindent%
The data needed for a \texttt{reserved} node in the abstract syntax tree amounts to a list of identifiers and a type.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ReservationSegmentPtr = ^ReservationSegmentObj; @/
   ReservationSegmentObj =
      object(MObject) @t\1@> @/
         nIdentifiers: PList; @/
         nResType: TypePtr; @/
         constructor Init(aIdentifiers:PList; aType:TypePtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ReservationSegmentObj.Init(aIdentifiers:PList; aType:TypePtr);
begin
   nIdentifiers:=aIdentifiers;
   nResType:=aType;
end; @#

destructor ReservationSegmentObj.Done;
begin
   dispose(nIdentifiers,Done);
   dispose(nResType,Done);
end;

@* [S] Private definitions.
The grammar for ``private definitions'' (which introduces block-local
or article-local terms and predicates) looks like:
\medbreak
{\obeylines\parindent=0pt\tt%\tentt
Private-Definition = Constant-Definition
\quad\pipe\ Private-Functor-Definition
\quad\pipe\ Private-Predicate-Definition .\smallbreak

Constant-Definition = "set" Equating-List ";" .\smallbreak

Equating-List = Equating \LB "," Equating \RB .\smallbreak

Equating = Variable-Identifier "=" Term-Expression .\smallbreak

Private-Functor-Definition = "deffunc" Private-Functor-Pattern "=" \rlap{Term-Expression ";" .}\smallbreak

Private-Predicate-Definition = "defpred" Private-Predicate-Pattern \rlap{"means" Sentence ";" .}\smallbreak

Private-Functor-Pattern = Functor-Identifier "(" [ Type-Expression-List ] ")" .\smallbreak

Private-Predicate-Pattern = Predicate-Identifier \rlap{"[" [ Type-Expression-List ] "]" .}
\par}
\medbreak\noindent%
So we really only need to describe private predicates, private
functors, and ``constant definitions'' (which introduce an abbreviation).

@ \node{Private functors.}

\label{PrivateFunctorDefinitionObj}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   PrivateFunctorDefinitionPtr = ^PrivateFunctorDefinitionObj; @/
   PrivateFunctorDefinitionObj =
      object(MObject) @t\1@> @/
         nFuncId: VariablePtr; @/ 
         nTypeExpList: PList; @/
         nTermExpr: TermPtr; @/
         constructor Init(aFuncId:VariablePtr; aTypeExpList:Plist; aTerm:TermPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor PrivateFunctorDefinitionObj.Init(aFuncId:VariablePtr; aTypeExpList:Plist; aTerm:TermPtr);
begin
   nFuncId:=aFuncId;
   nTypeExpList:=aTypeExpList;
   nTermExpr:=aTerm;
end; @#

destructor PrivateFunctorDefinitionObj.Done;
begin
   dispose(nFuncId,Done);
   dispose(nTypeExpList,Done);
   dispose(nTermExpr,Done);
end;

@ \node{Private predicates.}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   PrivatePredicateDefinitionPtr = ^PrivatePredicateDefinitionObj; @/
   PrivatePredicateDefinitionObj =
      object(MObject) @t\1@> @/
         nPredId: VariablePtr; @/
         nTypeExpList: PList; @/
         nSentence: FormulaPtr; @/
         constructor Init(aPredId:VariablePtr; aTypeExpList:Plist; aSnt:FormulaPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor PrivatePredicateDefinitionObj.Init(aPredId:VariablePtr; aTypeExpList:Plist; aSnt:FormulaPtr);
begin
   nPredId:=aPredId;
   nTypeExpList:=aTypeExpList;
   nSentence:=aSnt;
end; @#

destructor PrivatePredicateDefinitionObj.Done;
begin
   dispose(nPredId,Done);
   dispose(nTypeExpList,Done);
   dispose(nSentence,Done);
end;

@ \node{Constant definitions.} These are little more than
abbreviations for terms, and their implementations reflects this: they
are pointers with delusions of grandeur.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ConstantDefinitionPtr = ^ConstantDefinitionObj; @/
   ConstantDefinitionObj =
      object(MObject) @t\1@> @/
         nVarId: VariablePtr; @/
         nTermExpr: TermPtr; @/
         constructor Init(aVarId:VariablePtr; aTerm:TermPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ConstantDefinitionObj.Init(aVarId:VariablePtr; aTerm:TermPtr);
begin
   nVarId:=aVarId;
   nTermExpr:=aTerm;
end; @#

destructor ConstantDefinitionObj.Done;
begin
   dispose(nVarId,Done);
   dispose(nTermExpr,Done);
end;

@* [S] Changing types.
Each term has a soft type associated with it, but we can
``\texttt{reconsider}'' or change its type. Mizar requires a proof
that the term really has the new type. The grammar for this statement:

\medbreak
{\obeylines\parindent=0pt\tt
Type-Changing-Statement =
\quad"reconsider" Type-Change-List "as" Type-Expression\rlap{ Simple-Justification ";" .}\smallbreak

Type-Change-List =
\quad(Equating \pipe\ Variable-Identifier) \rlap{\LB "," (Equating \pipe\ Variable-Identifier)\RB\ .}
\par}

\medbreak\noindent%
This requires a bit of work since we really have \emph{two} types of
reconsiderations within a single reconsider statement:
\enumerate
\item ``\texttt{reconsider} \<identifier> \texttt{as} \<type>''
\item ``\texttt{reconsider} \<identifier> = \<term> \texttt{as} \<type>''
\endenumerate
\medbreak
The trick is to represent a \texttt{Type-Change-List} as a list
of \texttt{Type-Change}s. Then a \texttt{Type-Change-Statement} is
just a \texttt{Type-Change-List} and a type.

@^Reconsider (statement)@>
@:Reconsider}{\texttt{reconsider}@>

@ \node{Class hierarchy.}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   TypeChangeSort =  (Equating,VariableIdentifier); @#

   TypeChangePtr = ^TypeChangeObj; @/
   TypeChangeObj =
      object(MObject) @t\1@> @/
         nTypeChangeKind: TypeChangeSort; @/
         nVar: VariablePtr; @/
         nTermExpr: TermPtr; @/
         constructor Init(aKind:TypeChangeSort; aVar:VariablePtr; aTerm:TermPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

   @<Example classes (\texttt{wsmarticle.pas})@>@; @#
   
   TypeChangingStatementPtr = ^TypeChangingStatementObj; @/
   TypeChangingStatementObj =
      object(MObject) @t\1@> @/
         nTypeChangeList: PList; @/
         nTypeExpr: TypePtr; @/
         nJustification: SimpleJustificationPtr; @/
         constructor Init(aTypeChangeList: PList; aTypeExpr: TypePtr;
                          aJustification:SimpleJustificationPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor TypeChangeObj.Init(aKind:TypeChangeSort; aVar:VariablePtr; aTerm:TermPtr);
begin
   nTypeChangeKind:=aKind;
   nVar:=aVar;
   nTermExpr:=aTerm;
end; @#

destructor TypeChangeObj.Done;
begin
   dispose(nVar,Done);
   if nTermExpr <> nil then
      dispose(nTermExpr,Done);
end; @#

@t\4@> @<Constructors for example statements (\texttt{wsmarticle.pas})@>@; @#

constructor TypeChangingStatementObj.Init(aTypeChangeList: PList; aTypeExpr: TypePtr;
                                          aJustification:SimpleJustificationPtr);
begin
   nTypeChangeList:=aTypeChangeList;
   nTypeExpr:=aTypeExpr;
   nJustification:=aJustification;
end;

destructor TypeChangingStatementObj.Done;
begin
   dispose(nTypeChangeList,Done);
   dispose(nTypeExpr,Done);
   dispose(nJustification,Done);
end;

@* [S] Proof steps. Most of the proof steps are handled in generic
text-item objects. But there are a few which are outside that tagged union.
In particular: existential elimination (\texttt{consider}
\<variables> \texttt{such that} \<formula>),
existential introduction (\texttt{take} \<terms>),
and concluding statements (\texttt{thus} \<formula>).

@ \node{Examples, existential introduction.} The proof step
``\texttt{take} $x$'' transforms goals of the form $\exists x\ldotp P[x]$
into a new goal $P[x]$.
The grammar for examples looks like:

\medbreak
{\obeylines\parindent=0pt\tt
Exemplification = "take" Example \LB "," Example\RB\ ";" .\smallbreak

Example = Term-Expression \pipe\ Variable-Identifier "=" Term-Expression .
\par}

@<Example classes (\texttt{wsmarticle.pas})@>=
   ExamplePtr = ^ExampleObj; @/
   ExampleObj =
      object(MObject) @t\1@> @/
         nVarId: VariablePtr; @/
         nTermExpr: TermPtr; @/
         constructor Init(aVarId:VariablePtr; aTerm:TermPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Constructors for example statements (\texttt{wsmarticle.pas})@>=
constructor ExampleObj.Init(aVarId:VariablePtr; aTerm:TermPtr);
begin
   nVarId:=aVarId;
   nTermExpr:=aTerm;
end;

destructor ExampleObj.Done;
begin
   if nVarId <> nil then dispose(nVarId,Done);
   if nTermExpr <> nil then dispose(nTermExpr,Done);
end;

@ \node{Existential elimination.} We continue plugging along with the
statements, and existential elimination (or ``choice'') statements are
the next one.

\medbreak
{\obeylines\parindent=0pt\tt
Linkable-Statement = Compact-Statement
\quad\pipe\ Choice-Statement
\quad\pipe\ Type-Changing-Statement
\quad\pipe\ Iterative-Equality .\smallbreak

Choice-Statement = "consider" Qualified-Variables "such" \rlap{Conditions Simple-Justification ";" .}
\par}

@ @<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ChoiceStatementPtr = ^ChoiceStatementObj; @/
   ChoiceStatementObj =
      object(MObject) @t\1@> @/
         nQualVars: PList; @/
         nConditions: PList; @/
         nJustification: SimpleJustificationPtr; @/
         constructor Init(aQualVars,aConds:PList; aJustification:SimpleJustificationPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ChoiceStatementObj.Init(aQualVars,aConds:PList; aJustification:SimpleJustificationPtr);
begin
   nQualVars:=aQualVars;
   nConditions:=aConds;
   nJustification:=aJustification;
end;

destructor ChoiceStatementObj.Done;
begin
   dispose(nQualVars,Done);
   dispose(nConditions,Done);
   dispose(nJustification,Done);
end;

@ \node{Conclusion statements.}
We recall the grammar for conclusion statements:
\medbreak
{\obeylines\parindent=0pt\tt
Conclusion = ( "thus" \pipe\ "hence" ) ( Compact-Statement \pipe\ Iterative-Equality )
\quad\pipe\ Diffuse-Conclusion .\smallbreak

Diffuse-Conclusion = "thus" Diffuse-Statement \pipe\ "hereby" Reasoning "end"\rlap{ ";" .}\smallbreak

Iterative-Equality =
[ Label-Identifier ":" ] Term-Expression \rlap{"=" Term-Expression Simple-Justification}
\hskip17.5pc \rlap{".=" Term-Expression Simple-Justification}
\hskip16.6pc \rlap{\LB\ ".=" Term-Expression Simple-Justification \RB\ ";" .}

\par}
\medbreak\noindent%
N{\sc OTE}: the whitespace in the \texttt{Iterative-Equality} rule is
unimportant, but that is how Mizar users often structure them (to
align the equals sign).

@ \node{Abstract base class.}
\label{RegularStatementKind}
@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   RegularStatementKind = (stDiffuseStatement,stCompactStatement,stIterativeEquality); @#

   RegularStatementPtr = ^RegularStatementObj; @/
   RegularStatementObj =
      object(MObject) @t\1@> @/
         nStatementSort: RegularStatementKind; @/
         nLab: LabelPtr; @/
         constructor Init(aStatementSort:RegularStatementKind); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor RegularStatementObj.Init(aStatementSort: RegularStatementKind);
begin
   nStatementSort:=aStatementSort;
end;

destructor RegularStatementObj.Done;
begin
   inherited Done;
end;

@ \node{Thus statement.} The conclusion of a proof (idiomatically
``\texttt{thus thesis}'') is always a ``\texttt{thus}'', which Mizar
calls a ``diffuse statement''.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   DiffuseStatementPtr = ^DiffuseStatementObj; @/
   DiffuseStatementObj =
      object(RegularStatementObj) @t\1@> @/
         constructor Init(aLab: LabelPtr; aStatementSort:RegularStatementKind); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor DiffuseStatementObj.Init(aLab: LabelPtr; aStatementSort: RegularStatementKind);
begin
   inherited Init(stDiffuseStatement);
   nLab:=aLab;
   nStatementSort:=aStatementSort;
end;

destructor DiffuseStatementObj.Done;
begin
   dispose(nLab,Done);
end;

@ \node{Compact statements.}
We recall the syntax for a compact statement is:
\medbreak
{\obeylines\parindent=0pt\tt
Compact-Statement = Proposition Justification ";" .
\par}
\medbreak

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   CompactStatementPtr =  ^CompactStatementObj; @/
   CompactStatementObj =
      object(RegularStatementObj) @t\1@> @/
         nProp: PropositionPtr; @/
         nJustification: JustificationPtr; @/
         constructor Init(aProp:PropositionPtr; aJustification:JustificationPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor CompactStatementObj.Init(aProp:PropositionPtr; aJustification:JustificationPtr);
begin
   inherited Init(stCompactStatement);
   nProp:=aProp;
   nJustification:=aJustification;
end;

destructor CompactStatementObj.Done;
begin
   if nJustification <> nil then dispose(nJustification,Done);
   inherited Done;
end;

@ \node{Iterative equality.} Chain of equations, where we keep
transforming the right-hand side until we arrive at the desired outcome.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   IterativeStepPtr = ^IterativeStepObj; @/
   IterativeStepObj =
      object(MObject) @t\1@> @/
         nIterPos: Position; @/
         nTerm: TermPtr; @/
         nJustification: SimpleJustificationPtr; @/
         constructor Init(const aPos:Position;@+ aTerm: TermPtr;@+ aJustification:JustificationPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ @<Publicly declared types in \texttt{wsmarticle.pas}@>=
   IterativeEqualityPtr = ^IterativeEqualityObj; @/
   IterativeEqualityObj =
      object(CompactStatementObj) @t\1@> @/
         nIterSteps: PList; @/
         constructor Init(aProp:PropositionPtr; aJustification:JustificationPtr; aIters: PList); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor IterativeStepObj.Init(const aPos:Position;@+ aTerm: TermPtr;@+ aJustification:JustificationPtr);
begin
   nIterPos:=aPos;
   nTerm:=aTerm;
   nJustification:=SimpleJustificationPtr(aJustification);
end;

destructor IterativeStepObj.Done;
begin
   dispose(nTerm,Done);
   dispose(nJustification,Done);
end;
@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor IterativeEqualityObj.Init(aProp:PropositionPtr;aJustification:JustificationPtr; aIters: PList);
begin
   inherited Init(aProp,aJustification);
   nStatementSort:=stIterativeEquality;
   nIterSteps:=aIters;
end;

destructor IterativeEqualityObj.Done;
begin
   dispose(nIterSteps,Done);
   inherited Done;
end;

@ \node{Remaining proof steps?}
So where are the other proof steps like \texttt{let}
or \texttt{assume}? Well, these are handled as ``generic text items''
and use the \\{TextItem} class (\section\xref{TextItem:ast}).

@* [S] Structures.
Just an aside first on ``what is a structure in Mathematics?''
Logic textbooks assume an \emph{intuitive} (i.e., not formal)
``finitary metatheory'' following Hilbert and his famous Programme in
the foundations of Mathematics. We will build a ``skyscraper'' atop
this foundation of finitary metatheory. The first thing we do is describe a
logic, the first floor in our sky scraper. This ``Logic \#1'' is the
metalogic we use to construct an axiomatic set theory, ``Set Theory \#2''.
We use ``Set Theory \#2'' to construct another floor, a ``Logic \#3'',
which then builds another floor ``Set Theory \#4'', and so on. We can
potentially iterate building as many floors as we want, but 4 is
sufficient for our purposes.

We \textbf{assert} that ``Set Theory \#2'' \emph{is} the Platonic
``mathematical reality''. Then ``Logic \#3'' is the (ambient) logic we use to do
Mathematics; it is purely ``syntactic'', a language for expressing
proofs and definitions. Mizar's proof steps, formulas, and definitions
corresponds to ``Logic \#3''. With it, we describe an axiomatic ``Set
Theory \#4'', which is Tarski--Grothendieck set theory for
Mizar. Sketching this situation out diagrammatically:

\medbreak
\figure
\centerline{\vbox{\offinterlineskip
\halign{&\quad\vrule#&\quad\hfil#\hfil\quad&\vrule#&\quad#\hfil\quad\cr
& \multispan1\hrulefill && \omit\cr
height2pt&\omit&&\omit\cr
& Set Theory \#4 & & (Where we work) [syntactic]\cr
height2pt&\omit&&\omit\cr
& \multispan1\hrulefill && \omit\cr
height2pt&\omit&&\omit\cr
&      Logic \#3 & & ``Object logic'' (Where we write proofs) [syntactic]\cr
height2pt&\omit&&\omit\cr
& \multispan1\hrulefill && \omit\cr
height2pt&\omit&&\omit\cr
& Set Theory \#2 & & ``Mathematical Reality'' [semantic]\cr
height2pt&\omit&&\omit\cr
& \multispan1\hrulefill && \omit\cr
height2pt&\omit&&\omit\cr
&      Logic \#1 & & ``Metalogic''\cr
height2pt&\omit&&\omit\cr}\hrule
\vbox{\vskip 3pt\hbox{\quad Finitary Metatheory}}
}}
%% \rightline{\vbox{\vskip-3pc\hbox{\eightrm{\eightbf Fig.~\the\fig.}
%% Mathematical Platonism as a skyscaper.}}}
\caption{Mathematical Platonism as a skyscaper.}\label{fig:platonic-skyscraper}
\endfigure

\medbreak
Now, ``mathematical objects'' live in ``Set Theory \#2''. Model theory
studies structures (objects in ``Set Theory \#2'') of theories
(described in ``Logic \#3''). Since we ``believe'' that set theory
``describes reality'', that means we just need to describe
[``syntactic''] theories using ``Set Theory \#4'' and their ``real
world occurrences'' in ``Set Theory \#2''. (Well, this is a gloss,
model theory sets up two additional floors in the skyscraper, and
studies ``models'' of theories described using Logic~\#5 and Set Theory~\#6
in Set Theory~\#4 --- and we pretend it describes the relationship
between Set Theory~\#2 and the ``syntactic floors'' of the
Mathematical skyscraper.)

How do we \emph{syntactically} describe these ``structures''? Well,
we \emph{know} they are not ``first-class citizens'' in Mizar, in the
sense that they are not ``just'' a tuple. How do we know this? Gilbert
Lee and Piotr Rudnicki's ``Alternative Aggregates in Mizar''
(in \emph{MKM 2007}, Springer, pp.327--341; \doi{10.1007/978-3-540-73086-6_26})
discuss how to implement first-class structures in Mizar. This means
that \emph{technically} structures live in Logic~\#3. Field symbols
are terms in Logic~\#3.

@^Structure, first-class@>
@^Rudnicki, Piotr@>
@^Lee, Gilbert@>
@^Hilbert's programme@>
@^Finitary metatheory@>
@^Metamathematics@>
@^Skyscraper@>

@ Why do we need this convoluted skyscraper? Without it, how do we
describe a ``true'' formula? We can only speak of a \emph{provable}
formula. Bourbaki's \emph{Theory of Sets} (I \section2.2) confuses
``provable'' with ``true'' formulas (they speak of a formula being
``false in a theory ${\cal T}$'' as being
synonymous with the formula contradicting the axioms for a theory,
and true in a theory as being synonymous for being a logical
consequence from the axioms for a theory). This only matters for
Mathematical Platonists. Formalists (like the author) would find this
discussion muddled and nearly metaphysical, generating more heat than light.

@^Bourbaki, Nicolas@>

@ \node{Aside: finitary metatheory, programming languages,
implementing proof assistants.}\hfill\break
How does that diagram in
Figure~\ref{fig:platonic-skyscraper} of the last section compare to
the \emph{actual implementation} of Mizar? Well, a proof assistant
replaces the ``finitary metatheory'' with an actual programming
language. Then, since only Mathematical Platonists care about the
``Metalogic'' and ``Mathematical reality'', we jump ahead to implement
Logic \#3 --- this is what happens in Mizar and other proof
assistants: we implement a ``purely formal'' (purely syntactic) logic
using a programming language. Curiously, this reflects Bourbaki's
approach to the foundations of Mathematics.

We should note that programming languages are strictly stronger than
finitary metatheory, since programming languages are \emph{Turing complete}.
This means they support general recursion, whereas finitary metatheory
supports only primitive recursive functions. For an example of a
``programming language'' which is equally as strong as a finitary
metatheory, see Albert R.\ Meyer and Dennis M.\ Ritchie,
``The complexity of loop programs''
(\emph{ACM '67 Proc.},
1967,
\doi{10.1145/800196.806014}).

Is Turing completeness ``too much'' for a finitary metatheory? The
short answer is: yes. Even restricting a Turing complete programming
language is ``too much'' to be finitary.
G\"{o}del's System~T was developed to preserve the ``constructive character''
while jettisoning the ``finitary character'' of Hilbert's finitary
metatheory, and System~T is not even Turing complete. See
Kurt G\"{o}del's \emph{Collected Works} (vol.\ II, Oxford University Press, \doi{10.1093/oso/9780195147216.001.0001},
1989; viz., pp.\ 245--247) for his discussion of System~T.
The interested reader should consult 
David A.\ Turner's ``Elementary strong functional programming'' (in
\emph{Int.\ Symp.\ on Funct.\ Program.\ Lang.\ in Educ.}, eds P.H.\
Hartel and R.\ Plasmeijer, Springer, pages 1--13, \doi{10.1007/3-540-60675-0_35})
for how to obtain System~T by restricting any statically typed
functional programming language.

@^Bourbaki, Nicolas@>
@:Godel, Kurt}{G\"{o}del, Kurt@>
@^Turner, David A.@>
@^Total functional programming@>
@^System T@>
@^Ritchie, Dennis M.@>
@^Meyer, Albert R.@>
@^Primitive Recursive Function@>
@^Turing complete@>
@^Finitary metatheory@>
@^LOOP programming language@>

@ \node{Grammar for structures.} We can recall the syntax for
structures and fields:

\medbreak
{\obeylines\parindent=0pt\tt
Structure-Definition =
\quad"struct" [ "(" Ancestors ")" ] Structure-Symbol [ "over" Loci ] \rlap{"(\#" Fields "\#)" ";" .}\smallbreak

Ancestors = Structure-Type-Expression \LB\ "," Structure-Type-Expression \RB\ .\smallbreak

Structure-Symbol = Symbol .\smallbreak

Loci = Locus \LB\ "," Locus \RB\ .\smallbreak

Fields = Field-Segment \LB\ "," Field-Segment \RB\ .\smallbreak

Locus = Variable-Identifier .\smallbreak

Variable-Identifier = Identifier .\smallbreak

Field-Segment = Selector-Symbol \LB\ "," Selector-Symbol \RB\ Specification .\smallbreak

Selector-Symbol = Symbol .
\par}

@ \node{Field symbol.} A ``field symbol'' refers to the identifier
used for a field in a structure, but not its type.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   FieldSymbolPtr = ^FieldSymbolObj; @/
   FieldSymbolObj =
      object(MObject) @t\1@> @/
         nFieldPos: Position; @/
         nFieldSymbol: integer; @/
         constructor Init(const aPos:Position;@+ aFieldSymbNr:integer); @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor FieldSymbolObj.Init(const aPos:Position;@+ aFieldSymbNr:integer);
begin
   nFieldPos:=aPos;
   nFieldSymbol:=aFieldSymbNr;
end;

@ \node{Field segment.} A field segment refers to a list of 1 or more
field symbols, and the associated type it has.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   FieldSegmentPtr = ^FieldSegmentObj; @/
   FieldSegmentObj =
      object(MObject) @t\1@> @/
         nFieldSegmPos: Position; @/
         nFields: PList; @/
         nSpecification: TypePtr; @/
         constructor Init(const aPos:Position;@+ aFields:PList;@+ aSpec:TypePtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor FieldSegmentObj.Init(const aPos:Position;@+ aFields:PList;@+ aSpec:TypePtr);
begin
   nFieldSegmPos:=aPos;
   nFields:=aFields;
   nSpecification:=aSpec;
end;

destructor FieldSegmentObj.Done;
begin
   dispose(nFields,Done);
   dispose(nSpecification,Done);
end;

@ \node{Locus.} A ``locus'' refers to a term or type parametrizing a
definition.

\label{Locus:ast}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   LocusPtr = ^LocusObj; @/
   LocusObj =
      object(MObject) @t\1@> @/
         nVarId: integer; @/
         nVarIdPos: Position; @/
         constructor Init(const aPos:Position;@+ aIdentNr:integer); @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor LocusObj.Init(const aPos:Position;@+ aIdentNr:integer);
begin
   nVarId:=aIdentNr;
   nVarIdPos:=aPos;
end;

@ \node{Structure definition.} Finally, structures are finite maps
from selectors to terms, with structure inheritance thrown into the
mix. They may be defined ``\texttt{over}'' a finite list of types
(e.g., a module structure is ``\texttt{over}'' a ring). Note that we
need to first introduce ``patterns'' before describing the structure
definition, since ``patterns'' are needed in definitions.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=   
   @<Pattern objects (\texttt{wsmarticle.pas})@>@; @#
   
   StructureDefinitionPtr = ^StructureDefinitionObj; @/
   StructureDefinitionObj =
      object(MObject) @t\1@> @/
         nStrPos: Position; @/
         nAncestors: PList; @/
         nDefStructPattern: ModePatternPtr; @/
         nSgmFields: PList; @/
         constructor Init(const aPos:Position;@+ aAncestors:PList;@+ aStructSymb:integer;
                          aOverArgs:PList;@+ aFields:PList); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor StructureDefinitionObj.Init(const aPos:Position;@+ aAncestors:PList;
                                       @t\hskip14.6667pc @> aStructSymb:integer;@+ aOverArgs:PList;@+ aFields:PList);
begin
   nStrPos:=aPos;
   nAncestors:=aAncestors;
   nDefStructPattern:=new(ModePatternPtr,Init(aPos,aStructSymb,aOverArgs));
   nDefStructPattern^.nPatternSort:=itDefStruct;
   nSgmFields:=aFields;
end;

destructor StructureDefinitionObj.Done;
begin
   dispose(nAncestors,Done);
   dispose(nDefStructPattern,Done);
   dispose(nSgmFields,Done);
end;

@* [S] Patterns.
A ``\emph{Pattern\/}'' in Mizar is a format with the type information
for all the arguments around a term. The notion of a
``\emph{Pattern\/}'' also refers to the definiendum of a definition.
The syntax of patterns
\medbreak
{\obeylines\parindent=0pt\tt
Mode-Pattern = Mode-Symbol [ "of" Loci ] . \smallbreak

Attribute-Pattern = Locus "is" [ Attribute-Loci ] Attribute-Symbol .\smallbreak

Attribute-Loci = Loci \pipe\ "(" Loci ")" .\smallbreak

Predicate-Pattern = [ Loci ] Predicate-Symbol [ Loci ] .\smallbreak

Functor-Pattern = [ Functor-Loci ] Functor-Symbol [ Functor-Loci ]
\quad\pipe\ Left-Functor-Bracket Loci Right-Functor-Bracket .\smallbreak

Functor-Loci = Locus \pipe\ "(" Loci ")" .
\par}


@ \node{Base class for patterns.}

@<Pattern objects (\texttt{wsmarticle.pas})@>=
   PatternPtr = ^PatternObj; @/
   PatternObj =
      object(mObject) @t\1@> @/
         nPatternPos: Position; @/
         nPatternSort: ItemKind; @/
         constructor Init(const aPos:Position;@+ aSort:ItemKind); @t\2\2\2@>
      end; @#

@ @<Implementation for \texttt{wsmarticle.pas}@>=
constructor PatternObj.Init(const aPos:Position;@+ aSort:ItemKind);
begin
   nPatternPos:=aPos;
   nPatternSort:=aSort;
end;

@ \node{Mode patterns.} The syntax for ``mode patterns'' looks like:

\medbreak
{\obeylines\parindent=0pt\tt
Mode-Pattern = Mode-Symbol [ "of" Loci ] .
\par}

@<Pattern objects (\texttt{wsmarticle.pas})@>=
   ModePatternPtr = ^ModePatternObj; @/
   ModePatternObj =
      object(PatternObj) @t\1@> @/
         nModeSymbol: Integer; @/
         nArgs: PList; @/
         constructor Init(const aPos:Position;@+ aSymb:integer;@+ aArgs:PList); @t\2@>
         destructor Done; virtual;  @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ModePatternObj.Init(const aPos:Position;@+ aSymb:integer;@+ aArgs:PList);
begin
   inherited Init(aPos,itDefMode);
   nModeSymbol:=aSymb;
   nArgs:=aArgs;
end; @#

destructor ModePatternObj.Done;
begin
   dispose(nArgs,Done);
end;

@ \node{Attribute patterns.} Attributes can have loci prefixing the
attribute symbol, but \emph{not} suffixing the attribute symbol.

\medbreak
{\obeylines\parindent=0pt\tt
Attribute-Pattern = Locus "is" [ Attribute-Loci ] Attribute-Symbol .\smallbreak

Attribute-Loci = Loci \pipe\ "(" Loci ")" .

\par}

@<Pattern objects (\texttt{wsmarticle.pas})@>=
   AttributePatternPtr = ^AttributePatternObj; @/
   AttributePatternObj =
      object(PatternObj) @t\1@> @/
         nAttrSymbol: Integer; @/
         nArg: LocusPtr; @/
         nArgs: PList; @/
         constructor Init(const aPos:Position;@+ aArg:LocusPtr;@+ aSymb:integer;@+ aArgs:PList); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor AttributePatternObj.Init(const aPos:Position;@+ aArg:LocusPtr;@+ aSymb:integer;@+ aArgs:PList);
begin
   inherited Init(aPos,itDefAttr);
   nAttrSymbol:=aSymb;
   nArg:=aArg;
   nArgs:=aArgs;
end;

destructor AttributePatternObj.Done;
begin
   dispose(nArg,Done);
   dispose(nArgs,Done);
end;

@ \node{Predicate patterns.} Predicates can have loci on either side
of the predicate symbol, without requiring parentheses (unlike functors).

\medbreak
{\obeylines\parindent=0pt\tt
Predicate-Pattern = [ Loci ] Predicate-Symbol [ Loci ] .
\par}

@<Pattern objects (\texttt{wsmarticle.pas})@>=
   PredicatePatternPtr = ^PredicatePatternObj; @/
   PredicatePatternObj =
      object(PatternObj) @t\1@> @/
         nPredSymbol: Integer; @/
         nLeftArgs,nRightArgs: PList; @/
         constructor Init(const aPos:Position;@+ aLArgs:PList;@+ aSymb:integer;@+ aRArgs:PList); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor PredicatePatternObj.Init(const aPos:Position;
@t\qquad @> aLArgs:PList;@+ aSymb:integer;@+ aRArgs:PList);
begin
   inherited Init(aPos,itDefPred);
   nPredSymbol:=aSymb;
   nLeftArgs:=aLArgs;
   nRightArgs:=aRArgs;
end;

destructor PredicatePatternObj.Done;
begin
   dispose(nLeftArgs,Done);
   dispose(nRightArgs,Done);
end;

@ \node{Functor pattern.} Functors can have loci on either side. If
more than one locus is used on one side, then it must be placed in
parentheses and comma-separated. The syntax:

\medbreak
{\obeylines\parindent=0pt\tt
Functor-Pattern = [ Functor-Loci ] Functor-Symbol [ Functor-Loci ]
\quad\pipe\ Left-Functor-Bracket Loci Right-Functor-Bracket .\smallbreak

Functor-Loci = Locus \pipe\ "(" Loci ")" .
\par}

@<Pattern objects (\texttt{wsmarticle.pas})@>=
   FunctorSort = (InfixFunctor,CircumfixFunctor); @#

   FunctorPatternPtr = ^FunctorPatternObj; @/
   FunctorPatternObj =
      object(PatternObj) @t\1@> @/
         nFunctKind: FunctorSort; @/
         constructor Init(const aPos:Position;@+ aKind: FunctorSort); @t\2\2\2@>
      end; @#

   CircumfixFunctorPatternPtr = ^CircumfixFunctorPatternObj; @/
   CircumfixFunctorPatternObj =
      object(FunctorPatternObj) @t\1@> @/
         nLeftBracketSymb,nRightBracketSymb: integer; @/
         nArgs: PList; @/
         constructor Init(const aPos:Position;@+ aLBSymb,aRBSymb:integer;@+ aArgs:PList); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

   InfixFunctorPatternPtr = ^InfixFunctorPatternObj; @/
   InfixFunctorPatternObj =
      object(FunctorPatternObj) @t\1@> @/
         nOperSymb: integer; @/
         nLeftArgs,nRightArgs: PList; @/
         constructor Init(const aPos:Position;@+ aLArgs:PList;@+ aSymb:integer;@+ aRArgs:PList); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor FunctorPatternObj.Init(const aPos:Position;@+ aKind:FunctorSort);
begin
   inherited Init(aPos,itDefFunc);
   nFunctKind:=aKind;
end;

constructor CircumfixFunctorPatternObj.Init(const aPos:Position;@+ aLBSymb,aRBSymb:integer;@+ aArgs:PList);
begin
   inherited Init(aPos,CircumfixFunctor);
   nLeftBracketSymb:=aLBSymb;
   nRightBracketSymb:=aRBSymb;
   nArgs:=aArgs;
end;

destructor CircumfixFunctorPatternObj.Done;
begin
   dispose(nArgs,Done);
end;

constructor InfixFunctorPatternObj.Init(const aPos:Position;@+ aLArgs:PList;@+ aSymb:integer;@+ aRArgs:PList);
begin
   inherited Init(aPos,InfixFunctor);
   nOperSymb:=aSymb;
   nLeftArgs:=aLArgs;
   nRightArgs:=aRArgs;
end;

destructor InfixFunctorPatternObj.Done;
begin
   dispose(nLeftArgs,Done);
   dispose(nRightArgs,Done);
end;

@* [S] Definitions.
In Mizar, we can redefine an existing
definition (either changing the type of a term or ``the right hand
side'' of a definition) \emph{or} we can introduce a new
definition. There are 5 different things we can introduce: structures,
modes [types], functors [terms], predicates, and attributes. Rather
than bombard the reader with a long chunk of grammar, let us divide it
up into easy-to-digest pieces. The basic block structure of a
definition is the same for all these situations, its grammar looks like:

\label{esm:ast:definitions}

\medbreak
{\obeylines\parindent=0pt\ninett\baselineskip=11pt%\tt
Definitional-Item = Definitional-Block ";" .\smallbreak

Definitional-Block = "definition" \LB\ Definition-Item \pipe\ Definition \pipe\ Redefinition \RB\ "end" .\smallbreak

Definition-Item = Loci-Declaration \pipe\ Permissive-Assumption \pipe\ Auxiliary-Item .\smallbreak

Loci-Declaration = "let" Qualified-Variables [ "such" Conditions ] ";" .\smallbreak

Permissive-Assumption = Assumption .\smallbreak

Definition = Structure-Definition
\quad\pipe\ Mode-Definition
\quad\pipe\ Functor-Definition
\quad\pipe\ Predicate-Definition
\quad\pipe\ Attribute-Definition .\par}

@ \node{Redefinitions.} Redefinitions allow us to alter the type or
meaning of a definition. This isn't willy-nilly, the user still needs
to prove the redefined version is logically equivalent to the initial
definition. 

\medbreak
{\obeylines\parindent=0pt\ninett\baselineskip=11pt%\tt
Redefinition =
\quad"redefine" \rlap{( Mode-Definition \pipe\ Functor-Definition \pipe\ Predicate-Definition \pipe\ Attribute-Definition ) .}
\par}

@ \node{Structure definitions.} Structures intuitively correspond to
new ``gadgets'' (sets equipped with extra structure), which is often
presented in Mathematics as ``just another tuple''. Mizar allows
structures to inherit other structures, so a topological group extends
a topological space structure \emph{and} a magma structure (since a
group in Mizar is a magma with some extra properties).

\medbreak
{\obeylines\parindent=0pt\ninett\baselineskip=11pt%\tt
Structure-Definition =
\quad"struct" [ "(" Ancestors ")" ] Structure-Symbol \rlap{[ "over" Loci ] "(\#" Fields "\#)" ";" .}\smallbreak

Ancestors = Structure-Type-Expression \LB\ "," Structure-Type-Expression \RB\ .\smallbreak

Structure-Symbol = Symbol .\smallbreak

Loci = Locus \LB\ "," Locus \RB\ .\smallbreak

Fields = Field-Segment \LB\ "," Field-Segment \RB\ .\smallbreak

Locus = Variable-Identifier .\smallbreak

Variable-Identifier = Identifier .\smallbreak

Field-Segment = Selector-Symbol \LB\ "," Selector-Symbol \RB\ Specification .\smallbreak

Selector-Symbol = Symbol .\smallbreak

Specification = "->" Type-Expression .\par}




@ \node{Definiens.} Recall the grammar
for \texttt{Definiens}
looks like:
\medbreak
{\obeylines\parindent=0pt\tt
Definiens = Simple-Definiens \pipe\ Conditional-Definiens .\smallbreak

Simple-Definiens = [ ":" Label-Identifier ":" ] ( Sentence \pipe\ Term-Expression ) .\smallbreak

Label-Identifier = Identifier .\smallbreak

Conditional-Definiens = [ ":" Label-Identifier ":" ] Partial-Definiens-List
\quad[ "otherwise" ( Sentence \pipe\ Term-Expression ) ] .\smallbreak

Partial-Definiens-List = Partial-Definiens \LB\ "," Partial-Definiens \RB\ .\smallbreak

Partial-Definiens = ( Sentence \pipe\ Term-Expression ) "if" Sentence .\smallbreak
\par}
\medbreak\noindent%
We begin with a base class for definiens. This is extended
by \\{SimpleDefiniens} and \\{ConditionalDefiniens} classes.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   HowToDefine = (dfEmpty,dfMeans,dfEquals); @/
   DefiniensSort = (SimpleDefiniens,ConditionalDefiniens); @#

   DefiniensPtr = ^DefiniensObj; @/
   DefiniensObj =
      object(MObject) @t\1@> @/
         nDefSort: DefiniensSort; @/
         nDefPos: Position; @/
         nDefLabel: LabelPtr; @/
         constructor Init(const aPos: Position;@+ aLab:LabelPtr;@+ aKind:DefiniensSort); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor DefiniensObj.Init(const aPos: Position;@+ aLab:LabelPtr;@+ aKind:DefiniensSort);
begin
   nDefSort:=aKind;
   nDefPos:=aPos;
   nDefLabel:=aLab;
end;

destructor DefiniensObj.Done;
begin
   if nDefLabel <> nil then
      dispose(nDefLabel,Done);
end;

@ \node{Definiens expression.} These nodes in the abstract syntax tree
describe ``the right hand side'' of a definition. A simple definiens
is just a pointer to one definiens expression object, for example.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   DefExpressionPtr = ^DefExpressionObj; @/
   DefExpressionObj =
      object(MObject) @t\1@> @/
         nExprKind: ExpKind; @/
         nExpr: PObject; @/
         constructor Init(aKind:ExpKind; aExpr:PObject); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor DefExpressionObj.Init(aKind:ExpKind; aExpr:Pobject);
begin
   nExprKind:=aKind;
   nExpr:=aExpr;
end;

destructor DefExpressionObj.Done;
begin
   dispose(nExpr,Done);
end;

@ \node{Simple definiens.}
This is the ``default'' definiens, i.e., the definiens which are not
``by cases''.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   SimpleDefiniensPtr = ^SimpleDefiniensObj; @/
   SimpleDefiniensObj =
      object(DefiniensObj) @t\1@> @/
         nExpression: DefExpressionPtr; @/
         constructor Init(const aPos: Position;@+ aLab:LabelPtr;@+ aDef:DefExpressionPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor SimpleDefiniensObj.Init(const aPos:Position;@+ aLab:LabelPtr;@+ aDef:DefExpressionPtr);
begin
   inherited Init(aPos,aLab,SimpleDefiniens);
   nExpression:=aDef;
end;

destructor SimpleDefiniensObj.Done;
begin
   dispose(nExpression,Done);
   inherited Done;
end;

@ \node{Definition for particular case.}
We have ``\<sentence or term> \texttt{if} \<guard condition>'' represented by a couple
of pointers: one to the ``sentence or term'' definiens, and the second
to the ``guard'' condition.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   PartDefPtr = ^PartDefObj; @/
   PartDefObj =
      object(MObject) @t\1@> @/
         nPartDefiniens: DefExpressionPtr; @/
         nGuard: FormulaPtr; @/
         constructor Init(aPartDef:DefExpressionPtr; aGuard:FormulaPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor PartDefObj.Init(aPartDef:DefExpressionPtr; aGuard:FormulaPtr);
begin
   nGuard:=aGuard;
   nPartDefiniens:=aPartDef;
end;

destructor PartDefObj.Done;
begin
   dispose(nPartDefiniens,Done);
   dispose(nGuard,Done);
end;

@ \node{Conditional definiens.} A conditional definiens consists of a
finite list of pointers to \\{PartDef} objects, and a pointer to the
default ``\texttt{otherwise}'' definien.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ConditionalDefiniensPtr = ^ConditionalDefiniensObj; @/
   ConditionalDefiniensObj =
      object(DefiniensObj) @t\1@> @/
         nConditionalDefiniensList: PList; @/
         nOtherwise: DefExpressionPtr; @/
         constructor Init(const aPos:Position;@+ aLab:LabelPtr;@+ aPartialDefs:PList; aOtherwise:DefExpressionPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ConditionalDefiniensObj.Init(const aPos:Position;
@t\qquad @> aLab:LabelPtr;@+ aPartialDefs:PList;@+ aOtherwise:DefExpressionPtr);
begin
   inherited Init(aPos,aLab,ConditionalDefiniens);
   nConditionalDefiniensList:=aPartialDefs;
   nOtherwise:=aOtherwise;
end;

destructor ConditionalDefiniensObj.Done;
begin
   if nOtherwise <> nil then dispose(nOtherwise,Done);
   dispose(nConditionalDefiniensList,Done);
   inherited Done;
end;

@ \node{Mode definitions.} Mizar was heavily inspired by \ALGOL/, and
even borrows \ALGOL/'s terminology for types (``modes''). These are
``soft types'', which are predicates in the ambient logic.

However, we need to establish the well-definedness of types (i.e.,
they are inhabited by at least one term), or else we end up in ``free
logic''. For example, if \texttt{EmptyType} is a hypothetical empty
type, then \texttt{for x being EmptyType holds P[x]} is always true,
and \texttt{ex x being EmptyType st P[x]} is always false. The clever
Mizar user can abuse this, and end up compromising the soundness of
classical logic. To avert catastrophe, we require proving there exists
at least one term of the newly defined type.

\medbreak
{\obeylines\parindent=0pt\ninett\baselineskip=11pt%\tt
Mode-Definition = "mode" Mode-Pattern
\quad( [ Specification ] [ "means" Definiens ] ";" Correctness-Conditions \pipe\ "is" Type-Expression ";" )
\quad\LB\ Mode-Property \RB\ .\smallbreak

Mode-Pattern = Mode-Symbol [ "of" Loci ] .\smallbreak

Mode-Symbol = Symbol \pipe\ "set" .\smallbreak

Mode-Synonym = "synonym" Mode-Pattern "for" Mode-Pattern ";" .\smallbreak

Mode-Property = "sethood" Justification ";" .\par}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ModeDefinitionSort = (defExpandableMode,defStandardMode); @#

   ModeDefinitionPtr = ^ModeDefinitionObj; @/
   ModeDefinitionObj =
      object(MObject) @t\1@> @/
         nDefKind: ModeDefinitionSort; @/
         nDefModePos: Position; @/
         nDefModePattern: ModePatternPtr; @/
         nRedefinition: boolean; @/
         constructor Init(const aPos: Position;@+ aDefKind:ModeDefinitionSort;@+ aRedef: boolean;
                          aPattern: ModePatternPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ModeDefinitionObj.Init(const aPos:@+ Position;@+ aDefKind:ModeDefinitionSort;
@t\hskip13.3333pc@>                          aRedef: boolean;@+ aPattern: ModePatternPtr);
begin
   nDefKind:=aDefKind;
   nDefModePos:=aPos;
   nRedefinition:=aRedef;
   nDefModePattern:=aPattern;
end;

destructor ModeDefinitionObj.Done;
begin
   dispose(nDefModePattern,Done);
end;

@ \node{Expandable mode definitions.} These are simple
``abbreviations'' of modes which are of the form ``\texttt{mode}
\<type name> \texttt{is} $\langle\textit{adjective\/}_{1}\rangle$
$\cdots$ $\langle\textit{adjective\/}_{n}\rangle$ \<type>'',
i.e., just a stack of adjectives atop a type.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ExpandableModeDefinitionPtr =  ^ExpandableModeDefinitionObj; @/
   ExpandableModeDefinitionObj =
      object(ModeDefinitionObj) @t\1@> @/
         nExpansion: TypePtr; @/
         constructor Init(const aPos:Position;@+ aPattern:ModePatternPtr;@+ aExp:TypePtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ExpandableModeDefinitionObj.Init(const aPos: Position;
 @t\qquad @> aPattern: ModePatternPtr;@+ aExp:TypePtr);
begin
   inherited Init(aPos,defExpandableMode,false,aPattern);
   nExpansion:=aExp;
end;

destructor ExpandableModeDefinitionObj.Done;
begin
   dispose(nExpansion,Done);
   inherited Done;
end;

@ \node{Standard mode definitions.}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   StandardModeDefinitionPtr =  ^StandardModeDefinitionObj; @/
   StandardModeDefinitionObj =
      object(ModeDefinitionObj) @t\1@> @/
         nSpecification: TypePtr; @/
         nDefiniens: DefiniensPtr; @/
         constructor Init(const aPos:Position;@+ aRedef:boolean;@+ aPattern:ModePatternPtr;
                          aSpec:TypePtr;@+ aDef:DefiniensPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor StandardModeDefinitionObj.Init(const aPos: Position; @t\qquad @>  aRedef: boolean;@+
                                          aPattern: ModePatternPtr;@+ aSpec:TypePtr;@+
                                           aDef:DefiniensPtr);
begin
   inherited Init(aPos,defStandardMode,aRedef,aPattern);
   nSpecification:=aSpec;
   nDefiniens:=aDef;
end;

destructor StandardModeDefinitionObj.Done;
begin
   dispose(nSpecification,Done);
   dispose(nDefiniens,Done);
   inherited Done;
end;

@ \node{Attribute definitions.} Attributes, like predicates, do not
need to worry about correctness conditions. It's only when we want to
use them like adjectives on a type that we need to worry, but that's
a \texttt{registration} block concern.

\medbreak
{\obeylines\parindent=0pt\ninett\baselineskip=11pt%\tt
Attribute-Definition = "attr" Attribute-Pattern "means" Definiens \rlap{";"\ Correctness-Conditions .}\smallbreak

Attribute-Pattern = Locus "is" [ Attribute-Loci ] Attribute-Symbol .

\par}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   AttributeDefinitionPtr = ^AttributeDefinitionObj; @/
   AttributeDefinitionObj =
      object(MObject) @t\1@> @/
         nDefAttrPos: Position; @/
         nDefAttrPattern: AttributePatternPtr; @/
         nRedefinition: boolean; @/
         nDefiniens: DefiniensPtr; @/
         constructor Init(const aPos:Position;@+ aRedef:boolean;@+ aPattern:AttributePatternPtr;
                          aDef:DefiniensPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor AttributeDefinitionObj.Init(const aPos: Position;
@t\qquad @> aRedef: boolean;@+
                                        aPattern:AttributePatternPtr;@+ aDef:DefiniensPtr);
begin
   nDefAttrPos:=aPos;
   nRedefinition:=aRedef;
   nDefAttrPattern:=aPattern;
   nDefiniens:=aDef;
end; @#

destructor AttributeDefinitionObj.Done;
begin
   dispose(nDefAttrPattern,Done);
   dispose(nDefiniens,Done);
end;

@ \node{Predicate definitions.} Predicates are among the less
demanding of the definitions: they are always well-defined, so we do
not need to worry about correctness conditions.

\medbreak
{\obeylines\parindent=0pt\ninett\baselineskip=11pt%\tt
Predicate-Definition = "pred" Predicate-Pattern [ "means" Definiens ] ";" Correctness-Conditions \LB\ Predicate-Property \RB\ .\smallbreak

Predicate-Pattern = [ Loci ] Predicate-Symbol [ Loci ] .\smallbreak

Predicate-Property = ("symmetry" \pipe\ "asymmetry" \pipe\ "connectedness" \pipe\ "reflexivity" \pipe\ "irreflexivity")
\quad Justification ";" .\smallbreak

Predicate-Synonym = "synonym" Predicate-Pattern "for" Predicate-Pattern ";" .\smallbreak

Predicate-Antonym = "antonym" Predicate-Pattern "for" Predicate-Pattern ";" .\smallbreak

Predicate-Symbol = Symbol \pipe\ "=" .\par}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   PredicateDefinitionPtr = ^PredicateDefinitionObj; @/
   PredicateDefinitionObj =
      object(MObject) @t\1@> @/
         nDefPredPos: Position; @/
         nDefPredPattern: PredicatePatternPtr; @/
         nRedefinition: boolean; @/
         nDefiniens: DefiniensPtr; @/
         constructor Init(const aPos:Position;@+ aRedef:boolean;@+ aPattern:PredicatePatternPtr;
                          aDef:DefiniensPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor PredicateDefinitionObj.Init(const aPos: Position;
@t\qquad @> aRedef: boolean;@+ aPattern:PredicatePatternPtr;@+ aDef:DefiniensPtr);
begin
   nDefPredPos:=aPos;
   nRedefinition:=aRedef;
   nDefPredPattern:=aPattern;
   nDefiniens:=aDef;
end; @#

destructor PredicateDefinitionObj.Done;
begin
   dispose(nDefPredPattern,Done);
   dispose(nDefiniens,Done);
end;

@ \node{Functor definitions.} We can also define new terms. Well, they
introduce ``term constructors'' (constructors for terms). Mizar calls
these guys ``functors''.

Functor definitions need to establish the well-definedness of the new
term constructor. What this means depends on whether we define the new
term using ``means'' or ``equals'', i.e.,
\enumerate
\item ``\<new term> \texttt{means} \<formula>''
  requires proving the existence and uniqueness of the new term;
\item ``\<new term> \texttt{equals} \<term expression>''
  requires proving the new term has the given type.
\endenumerate
Why do we need to prove well-definedness? Well, classical logic
requires proving there exists a model for a theory, so our hands are
tied. If we removed this restriction, then we'd end up with something
called ``free logic'', which is\dots weird.

\medbreak
{\obeylines\parindent=0pt\ninett\baselineskip=11pt%\tt
Functor-Definition = "func" Functor-Pattern [ Specification ]
\quad[ ( "means" \pipe\ "equals" ) Definiens ] ";"
\quad Correctness-Conditions \LB\ Functor-Property \RB\ .\smallbreak

Functor-Pattern = [ Functor-Loci ] Functor-Symbol [ Functor-Loci ]
\quad\pipe\ Left-Functor-Bracket Loci Right-Functor-Bracket .\smallbreak

Functor-Property = ( "commutativity" \pipe\ "idempotence" \pipe\ "involutiveness" \pipe\ "projectivity" )
\quad Justification ";" .\smallbreak

Functor-Synonym = "synonym" Functor-Pattern "for" Functor-Pattern ";" .\smallbreak

Functor-Loci = Locus \pipe\ "(" Loci ")" .\smallbreak

Functor-Symbol = Symbol .\smallbreak

Left-Functor-Bracket = Symbol \pipe\ "\LB" \pipe\ "[" .\smallbreak

Right-Functor-Bracket = Symbol \pipe\ "\RB" \pipe\ "]" .\par}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   FunctorDefinitionPtr = ^FunctorDefinitionObj; @/
   FunctorDefinitionObj =
      object(MObject) @t\1@> @/
         nDefFuncPos: Position; @/
         nDefFuncPattern: FunctorPatternPtr; @/
         nRedefinition: boolean; @/
         nSpecification: TypePtr; @/
         nDefiningWay: HowToDefine; @/
         nDefiniens: DefiniensPtr; @/
         constructor Init(const aPos:Position;@+ aRedef:boolean;@+ aPattern:FunctorPatternPtr;
                          aSpec:TypePtr;@+ aDefWay:HowToDefine;@+ aDef:DefiniensPtr); @t\2@>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor FunctorDefinitionObj.Init(const aPos: Position; @+
aRedef: boolean;
 @t\qquad @>                                     aPattern:FunctorPatternPtr;@+ aSpec: TypePtr;@+
                                      aDefWay:HowToDefine;@+ aDef:DefiniensPtr);
begin
   nDefFuncPos:=aPos;
   nRedefinition:=aRedef;
   nDefFuncPattern:=aPattern;
   nSpecification:=aSpec;
   nDefiningWay:=aDefWay;
   nDefiniens:=aDef;
end;

destructor FunctorDefinitionObj.Done;
begin
   dispose(nDefFuncPattern,Done);
   dispose(nDefiniens,Done);
end;

@ \node{Notation block.} We can recall the syntax for notation blocks.

\medbreak
{\obeylines\parindent=0pt\tt
Notation-Block = "notation" \LB\ Loci-Declaration \pipe\ Notation-Declaration \RB\ "end" .\smallbreak

Notation-Declaration = Mode-Synonym
\quad\pipe\ Functor-Synonym
\quad\pipe\ Attribute-Synonym \pipe\ Attribute-Antonym
\quad\pipe\ Predicate-Synonym \pipe\ Predicate-Antonym .\smallbreak

Mode-Synonym = "synonym" Mode-Pattern "for" Mode-Pattern ";" .\smallbreak

Functor-Synonym = "synonym" Functor-Pattern "for" Functor-Pattern ";" .\smallbreak

Predicate-Synonym = "synonym" Predicate-Pattern "for" Predicate-Pattern ";" .\smallbreak

Predicate-Antonym = "antonym" Predicate-Pattern "for" Predicate-Pattern ";" .\smallbreak

Attribute-Synonym = "synonym" Attribute-Pattern "for" Attribute-Pattern ";" .\smallbreak

Attribute-Antonym = "antonym" Attribute-Pattern "for" Attribute-Pattern ";" .
\par}
\medbreak\noindent%
The reader will observe all these notation items relate a new pattern
which is either a synonym or antonym for an old pattern. That is to
say, we only need two patterns to store as data in a notation item
node in the abstract syntax tree.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   NotationDeclarationPtr = ^NotationDeclarationObj; @/
   NotationDeclarationObj =
      object(mObject) @t\1@> @/
         nNotationPos: Position; @/
         nNotationSort: ItemKind; @/
         nOriginPattern,nNewPattern: PatternPtr; @/
         constructor Init(const aPos:Position;@+ aNSort:ItemKind;@+ aNewPatt,aOrigPatt:PatternPtr);@t\2 @>
         destructor Done; virtual; @t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor NotationDeclarationObj.Init(const aPos:Position;@+ aNSort:ItemKind;
@t\qquad @> aNewPatt,aOrigPatt:PatternPtr);
begin
   nNotationPos:=aPos;
   nNotationSort:=aNSort;
   nOriginPattern:=aOrigPatt;
   nNewPattern:=aNewPatt;
end;

destructor NotationDeclarationObj.Done;
begin
   dispose(nOriginPattern,Done);
   dispose(nNewPattern,Done);
end;

@ \node{Assumptions in a definition block.} The syntax for assumptions
in a definition block looks like:

\medbreak
{\obeylines\parindent=0pt\tt
Assumption = Single-Assumption \pipe\ Collective-Assumption \pipe\ Existential-Assumption .\smallbreak

Single-Assumption = "assume" Proposition ";" .\smallbreak

Collective-Assumption = "assume" Conditions ";" .\smallbreak

Existential-Assumption = "given" Qualified-Variables [ "such" Conditions ] \rlap{";"\ .}\smallbreak

Conditions = "that" Proposition \LB\ "and" Proposition \RB\ .\smallbreak

Proposition = [ Label-Identifier ":" ] Sentence .\smallbreak

Sentence = Formula-Expression .
\par}

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   AssumptionKind = (SingleAssumption,CollectiveAssumption,ExistentialAssumption); @#

   AssumptionPtr = ^AssumptionObj; @/
   AssumptionObj =
      object(MObject) @t\1@> @/
         nAssumptionPos: Position; @/
         nAssumptionSort: AssumptionKind; @/
         constructor Init(const aPos:Position;@+ aSort:AssumptionKind);@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor AssumptionObj.Init(const aPos:Position;@+ aSort:AssumptionKind);
begin
   nAssumptionPos:=aPos;
   nAssumptionSort:=aSort;
end;

@ \node{Single assumption.} When a definition has a single assumption,
i.e., a single (usually labeled) formula.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   SingleAssumptionPtr = ^SingleAssumptionObj; @/
   SingleAssumptionObj =
      object(AssumptionObj) @t\1@> @/
         nProp: PropositionPtr; @/
         constructor Init(const aPos:Position;@+ aProp:PropositionPtr); @t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor SingleAssumptionObj.Init(const aPos:Position;@+ aProp:PropositionPtr);
begin
   inherited Init(aPos,SingleAssumption);
   nProp:=aProp;
end;

destructor SingleAssumptionObj.Done;
begin
   dispose(nProp,Done);
end;

@ \node{Collective assumption.} This describes the case when the
assumption is ``\texttt{assume} $C_{1}$ \texttt{and}
\dots \texttt{and} $C_{n}$''.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   CollectiveAssumptionPtr = ^CollectiveAssumptionObj; @/
   CollectiveAssumptionObj =
      object(AssumptionObj) @t\1@> @/
         nConditions: PList; @/
         constructor Init(const aPos:Position;@+ aProps:PList); @t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor CollectiveAssumptionObj.Init(const aPos:Position;@+ aProps:PList);
begin
   inherited Init(aPos,CollectiveAssumption);
   nConditions:=aProps;
end;

destructor CollectiveAssumptionObj.Done;
begin
   dispose(nConditions,Done);
end;

@ \node{Existential assumption.}
I must confess I am surprised to see an existential assumption node
being a subclass of a collective assumption node.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ExistentialAssumptionPtr = ^ExistentialAssumptionObj; @/
   ExistentialAssumptionObj =
      object(CollectiveAssumptionObj) @t\1@> @/
         nQVars: PList; @/
         constructor Init(const aPos:Position;@+ aQVars,aProps:PList); @t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ExistentialAssumptionObj.Init(const aPos:Position;@+ aQVars,aProps:PList);
begin
   AssumptionObj.Init(aPos,CollectiveAssumption);
   nConditions:=aProps;
   nQVars:=aQVars;
end;

destructor ExistentialAssumptionObj.Done;
begin
   dispose(nQVars,Done);
   inherited Done;
end;

@ \node{Correctness conditions.} % section 132, pg 39
The syntax for correctness conditions:

\medbreak
{\obeylines\parindent=0pt\ninett\baselineskip=11pt%\tt

Correctness-Conditions = \LB Correctness-Condition\RB\ \rlap{[\ "correctness"\ Justification ";" ] .}\smallbreak

Correctness-Condition =
\quad( "existence" \pipe\ "uniqueness" \pipe\ "coherence" \pipe\ "compatibility" \pipe\ "consistency" \pipe\ "reducibility" ) 
\quad Justification ";" .
\par}
\medbreak\noindent%
We begin with an abstract base class for correctness conditions.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   CorrectnessPtr =^CorrectnessObj; @/
   CorrectnessObj =
      object(MObject) @t\1@> @/
         nCorrCondPos: Position; @/
         nJustification: JustificationPtr; @/
         constructor Init(const aPos:Position;@+ aJustification:JustificationPtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor CorrectnessObj.Init(const aPos:Position;@+ aJustification:JustificationPtr);
begin
   nCorrCondPos:=aPos;
   nJustification:=aJustification;
end;

destructor CorrectnessObj.Done;
begin
   dispose(nJustification,Done);
end;

@ \node{Correctness condition.} For the correctness condition
associated with a definition or registration, we have
this \\{CorrectnessCondition} object. When we need multiple
correctness conditions, we extend it with a subclass.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   CorrectnessConditionPtr =^CorrectnessConditionObj; @/
   CorrectnessConditionObj =
      object(CorrectnessObj) @t\1@> @/
         nCorrCondSort: CorrectnessKind; @/
         constructor Init(const aPos:Position;@+ aSort:CorrectnessKind;@+
                          aJustification:JustificationPtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor CorrectnessConditionObj.Init(const aPos:Position;
 @t\qquad @> aSort:CorrectnessKind; @+
                          aJustification:JustificationPtr);
begin
   inherited Init(aPos,aJustification);
   nCorrCondSort:=aSort;
end;

destructor CorrectnessConditionObj.Done;
begin
   inherited Done;
end;

@ \node{Multiple correctness conditions.}
For, e.g., functors which require proving both ``existence'' and
``uniqueness'', we have a \\{CorrectnessConditions} class. This
extends the [singular] \\{CorrectnessCondition} class.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   CorrectnessConditionsSet = set of CorrectnessKind; @#

   CorrectnessConditionsPtr =^CorrectnessConditionsObj; @/
   CorrectnessConditionsObj =
      object(CorrectnessObj) @t\1@> @/
         nConditions: CorrectnessConditionsSet; @/
         constructor Init(const aPos:Position;@+ const aConds: CorrectnessConditionsSet;
                          aJustification:JustificationPtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor CorrectnessConditionsObj.Init(const aPos:Position;
 const aConds: CorrectnessConditionsSet;
   @t\qquad @>                            aJustification:JustificationPtr);
begin
   inherited Init(aPos,aJustification);
   nConditions:=aConds;
end;

destructor CorrectnessConditionsObj.Done;
begin
   inherited Done;
end;

@ \node{Definition properties.} The grammar for properties in a
definition looks like:
\medbreak
{\obeylines\parindent=0pt\tt
Mode-Property = "sethood" Justification ";" .\smallbreak

Functor-Property = ("commutativity" \pipe\ "idempotence" \pipe\ "involutiveness" \pipe\ "projectivity")
\quad Justification ";" .\smallbreak

Predicate-Property = ("symmetry" \pipe\ "asymmetry" \pipe\ "connectedness" \pipe\ "reflexivity" \rlap{\pipe\ "irreflexivity")}
\quad Justification ";" .
\par}
\medbreak\noindent%
We see these are all, more or less, ``the same'': we have a ``kind''
of property and a justification. We recall
(\section\xref{PropertyKind}) that we have already introduced the
``kind'' of properties. So the class describing a definition property
node in the abstract syntax tree is:

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   PropertyPtr =^PropertyObj; @/
   PropertyObj =
      object(MObject) @t\1@> @/
         nPropertyPos: Position; @/
         nPropertySort: PropertyKind; @/
         nJustification: JustificationPtr; @/
         constructor Init(const aPos:Position;@+ aSort:PropertyKind;@+ aJustification:JustificationPtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=

constructor PropertyObj.Init(const aPos:Position;@+ aSort:PropertyKind;
 @t\qquad @>                 aJustification:JustificationPtr);
begin
   nPropertyPos:=aPos;
   nPropertySort:=aSort;
   nJustification:=aJustification;
end;

destructor PropertyObj.Done;
begin
   inherited Done;
end;

@* [S] Registrations.
There are three ``main'' types of registrations, which are ``cluster
registrations'' (because they all involve the ``\texttt{cluster}'' keyword):
\enumerate
\item Existential registrations are of the form ``\texttt{cluster}
\<attributes> \texttt{for} \<type>''
and establishes that a given attribute can act as an adjective for the
type.
\item Conditional registrations are of the form
``\texttt{cluster}
$\langle\textit{attribute}_{1}\rangle$ \texttt{->} $\langle\textit{attribute}_{2}\rangle$ \texttt{for} \<type>''
which tells Mizar that when $\langle\textit{attribute}_{1}\rangle$ is
established for a term, then Mizar can automatically add
$\langle\textit{attribute}_{2}\rangle$ for the term
\item Functorial registrations are of the form
``\texttt{cluster}
\<term> \texttt{->} \<attribute> [\texttt{for} \<type>]''
which will automatically add an attribute to a term.
\endenumerate
\medbreak\noindent%
We also have three lesser registrations which are still important:
\enumerate
\item Sethood registrations, establishes a type can be used as a set
in a Fraenkel term.
\item Reduction registration, which allows Mizar's term rewriting
module to use this rule when reasoning about things.
\item Identification registration, which allows Mizar to identify
terms of different types.
\endenumerate

\label{esm:ast:registrations}

\medbreak
{\obeylines\parindent=0pt\ninett\baselineskip=11pt
Cluster-Registration = Existential-Registration
\quad\pipe\ Conditional-Registration
\quad\pipe\ Functorial-Registration .\smallbreak

Existential-Registration = "cluster" Adjective-Cluster "for" \rlap{Type-Expression ";" }
\quad Correctness-Conditions . \smallbreak

Adjective-Cluster = \LB\ Adjective \RB\ .\smallbreak

Adjective = [ "non" ] [ Adjective-Arguments ] Attribute-Symbol .\smallbreak

Conditional-Registration = "cluster" Adjective-Cluster "->" \rlap{Adjective-Cluster "for" Type-Expression ";"}
\quad Correctness-Conditions .\smallbreak

Functorial-Registration = "cluster" Term-Expression "->" \rlap{Adjective-Cluster [ "for" Type-Expression ] ";"}
\quad Correctness-Conditions .\smallbreak

Identify-Registration = "identify" Functor-Pattern "with" Functor-Pattern
\qquad [ "when" Locus "=" Locus \LB\ "," Locus "=" Locus \RB\ ] ";"
\quad Correctness-Conditions .\smallbreak

Property-Registration = "sethood" "of" Type-Expression Justification ";" .\smallbreak

Reduction-Registration = "reduce" Term-Expression "to" Term-Expression ";"
\quad Correctness-Conditions .
\par}

@ \node{Cluster registration.} We have a base class for the three
types of cluster registrations.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ClusterRegistrationKind = (ExistentialRegistration,ConditionalRegistration,
                              FunctorialRegistration); @#

   ClusterPtr = ^ClusterObj; @/
   ClusterObj =
      object(MObject) @t\1@> @/
         nClusterPos: Position; @/
         nClusterKind: ClusterRegistrationKind; @/
         nConsequent: PList; @/
         nClusterType: TypePtr; @/
         constructor Init(const aPos: Position;@+ aKind:ClusterRegistrationKind;@+ aCons:PList; aTyp:TypePtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ClusterObj.Init(const aPos: Position;
@t\qquad @> aKind:ClusterRegistrationKind;@+ aCons:PList;@+ aTyp:TypePtr);
begin
   nClusterPos:=aPos;
   nClusterKind:=aKind;
   nConsequent:=aCons;
   nClusterType:=aTyp;
end;

destructor ClusterObj.Done;
begin
   dispose(nConsequent,Done);
end;

@ \node{Existential cluster.} We register the fact there always exists
a term of a given type satisfying an attribute (e.g., ``empty'' for
``set'' means there always exists an empty set;
registering the existential cluster ``non empty'' for ``set'' means
there always exists a nonempty set).
This means the attribute may henceforth be used as an adjective on the type.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   EClusterPtr = ^EClusterObj; @/
   EClusterObj =
      object(ClusterObj) @t\1@> @/
         constructor Init(const aPos: Position;@+ aCons:PList;@+ aTyp:TypePtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}
There are no additional fields to an existential cluster object, so it
literally passes the parameters onto the superclass's constructor.

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor EClusterObj.Init(const aPos: Position;@+ aCons:PList;@+ aTyp:TypePtr);
begin
   ClusterObj.Init(aPos,ExistentialRegistration,aCons,aTyp);
end;

destructor EClusterObj.Done;
begin
   if nClusterType <> nil then dispose(nClusterType,Done);
   inherited Done;
end;

@ \node{Conditional cluster.} For example ``empty sets'' are always
``finite sets''. This requires tracking the antecedent (``empty''),
and the superclass tracks the consequents (``finite'').

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   CClusterPtr = ^CClusterObj; @/
   CClusterObj =
      object(ClusterObj) @t\1@> @/
         nAntecedent: PList; @/
         constructor Init(const aPos: Position;@+ aAntec,aCons:PList;@+ aTyp:TypePtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor CClusterObj.Init(const aPos:Position;@+ aAntec,aCons:PList;@+ aTyp:TypePtr);
begin
   ClusterObj.Init(aPos,ConditionalRegistration,aCons,aTyp);
   nAntecedent:=aAntec;
end;

destructor CClusterObj.Done;
begin
   dispose(nAntecedent,Done);
   inherited Done;
end;

@ \node{Functorial cluster.} The generic form a functorial
registrations associated to a term some cluster of adjectives. We need
to track the term, but the superclass can manage the cluster of
adjectives. 

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   FClusterPtr = ^FClusterObj; @/
   FClusterObj =
      object(ClusterObj) @t\1@> @/
         nClusterTerm: TermPtr; @/
         constructor Init(const aPos: Position;@+ aTrm:TermPtr;@+ aCons:PList;@+ aTyp:TypePtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor FClusterObj.Init(const aPos: Position;
@t\qquad @> aTrm:TermPtr;@+ aCons:PList;@+ aTyp:TypePtr);
begin
   ClusterObj.Init(aPos,FunctorialRegistration,aCons,aTyp);
   nClusterTerm:=aTrm;
end;

destructor FClusterObj.Done;
begin
   if nClusterTerm <> nil then Dispose(nClusterTerm,Done);
   if nClusterType <> nil then dispose(nClusterType,Done);
   inherited Done;
end;


@ \node{Loci equality.} This is used in identification registrations.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   LociEqualityPtr = ^LociEqualityObj; @/
   LociEqualityObj =
      object(mObject) @t\1@> @/
         nEqPos: Position; @/
         nLeftLocus,nRightLocus: LocusPtr; @/
         constructor Init(const aPos:Position;@+ aLeftLocus,aRightLocus:LocusPtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor LociEqualityObj.Init(const aPos:Position;@+ aLeftLocus,aRightLocus:LocusPtr);
begin
   nEqPos:=aPos;
   nLeftLocus:=aLeftLocus;
   nRightLocus:=aRightLocus;
end;

destructor LociEqualityObj.Done;
begin
   Dispose(nLeftLocus,Done);
   dispose(nRightLocus,Done);
end;

@ \node{Identification registration.}
Term identification was first introduced in
Artur Korni\l{}owicz's ``How to define terms in Mizar effectively''
(in A.\ Grabowski and A.\ Naumowicz (eds.),
\emph{Computer Reconstruction of the Body of Mathematics},
issue of \emph{Studies in Logic, Grammar and
Rhetoric} \textbf{18} no.31 (2009), pp. 67--77). See also \section2.7
of Adam Grabowski,
Artur Korni\l{}owicz, and
Adam Naumowicz's ``Mizar in a Nutshell'' (\doi{10.6092/issn.1972-5787/1980})
for user-oriented details.
@^Grabowski, Adam@>
@:Kornilowicz, Artur}{Korni\l{}owicz, Artur@>
@^Naumowicz, Adam@>

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   IdentifyRegistrationPtr = ^IdentifyRegistrationObj; @/
   IdentifyRegistrationObj =
      object(mObject) @t\1@> @/
         nIdentifyPos: Position; @/
         nOriginPattern,nNewPattern: PatternPtr; @/
         nEqLociList:PList; @/
         constructor Init(const aPos:Position;@+ aNewPatt,aOrigPatt:PatternPtr;@+ aEqList:PList);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor IdentifyRegistrationObj.Init(const aPos:Position;
@t\qquad @> aNewPatt,aOrigPatt:PatternPtr;@+ aEqList:PList);
begin
   nIdentifyPos:=aPos;
   nOriginPattern:=aOrigPatt;
   nNewPattern:=aNewPatt;
   nEqLociList:=aEqList;
end;

destructor IdentifyRegistrationObj.Done;
begin
   dispose(nOriginPattern,Done);
   dispose(nNewPattern,Done);
   if nEqLociList <> nil then
      dispose(nEqLociList,Done);
end;


@ \node{Property registration.} These were introduced in Mizar to
facilitated registering ``\texttt{sethood}'' for types. Thus far, only the
``\texttt{sethood}'' property is handled in this registration.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   PropertyRegistrationPtr = ^PropertyRegistrationObj; @/
   PropertyRegistrationObj =
      object(mObject) @t\1@> @/
         nPropertyPos: Position; @/
         nPropertySort: PropertyKind; @/
         constructor Init(const aPos:Position;@+ aKind:PropertyKind);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor PropertyRegistrationObj.Init(const aPos:Position;@+ aKind:PropertyKind);
begin
   nPropertyPos:=aPos;
   nPropertySort:=aKind;
end;

destructor PropertyRegistrationObj.Done;
begin
end;


@ \node{Sethood registration.}
Artur Korni\l{}owicz's ``Sethood Property in Mizar''
(in \emph{Joint Proc.\ FMM and LML Workshops}, 2019,
\href{https://ceur-ws.org/Vol-2634/FMM3.pdf}{{\tt ceur-ws.org/Vol-2634/FMM3.pdf}})
introduces this ``sethood'' property. It's the first (and, so far, only)
property registration in Mizar.

@:Kornilowicz, Artur}{Korni\l{}owicz, Artur@>

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   SethoodRegistrationPtr = ^SethoodRegistrationObj; @/
   SethoodRegistrationObj =
      object(PropertyRegistrationObj) @t\1@> @/
         nSethoodType: TypePtr; @/
         nJustification: JustificationPtr; @/
         constructor Init(const aPos:Position;@+ aKind:PropertyKind;@+ aType:TypePtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end; @#

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor SethoodRegistrationObj.Init(const aPos:Position;
@t\qquad @> aKind:PropertyKind;@+ aType:TypePtr);
begin
   inherited Init(aPos,aKind);
   nSethoodType:=aType;
   nJustification:=nil;
end;

destructor SethoodRegistrationObj.Done;
begin
   dispose(nSethoodType,Done);
   dispose(nJustification,Done);
   inherited Done;
end;


@ \node{Reduce registration.}
These were introduced, I think, in Artur Korni\l{}owicz's ``On rewriting rules in Mizar''
(\emph{J.\ Autom.\ Reason.} \textbf{50} no.2 (2013) 203--210,
\doi{10.1007/s10817-012-9261-6}). These extend the checker with new
term rewriting rules.

@^Term rewriting@>
@:Kornilowicz, Artur}{Korni\l{}owicz, Artur@>

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   ReduceRegistrationPtr = ^ReduceRegistrationObj; @/
   ReduceRegistrationObj =
      object(MObject) @t\1@> @/
         nReducePos: Position; @/
         nOriginTerm,nNewTerm:TermPtr; @/
         constructor Init(const aPos:Position;@+ aOrigTerm,aNewTerm:TermPtr);@t\2 @>
         destructor Done; virtual;@t\2\2\2@>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor ReduceRegistrationObj.Init(const aPos:Position;@+ aOrigTerm,aNewTerm:TermPtr);
begin
   nReducePos:=aPos;
   nOriginTerm:=aOrigTerm;
   nNewTerm:=aNewTerm;
end;

destructor ReduceRegistrationObj.Done;
begin
   dispose(nOriginTerm,Done);
   dispose(nNewTerm,Done);
end;

@* [S] Helper functions.
Capitlization checks if the first character $c$ is lowercase. If so,
then set the leading character to be |c := c - (ord('a') - ord('A'))|.
But it leaves the rest of the string untouched.

@<Implementation for \texttt{wsmarticle.pas}@>=
function CapitalizeName(aName: string): string;
begin
   result:=aName;
   if aName[1] in ['a'..'z'] then
      dec(Result[1], ord('a') - ord('A'))
end;

@ Uncapitalizing works in the opposite direction, setting the first
letter $c$ of a string to be |c := c + (ord('a') - ord('A'))|.
Observe capitalizing and uncapitalizing are ``nearly inverses'' of
each other: |CapitalizeName(UncapitalizeName(CapitalizeName(s)))=CapitalizeName(s)|,
and similarly we find\hfill\break
|UncapitalizeName(CapitalizeName(UncapitalizeName(s)))=UncapitalizeName(s)|. 

@<Implementation for \texttt{wsmarticle.pas}@>=
function UncapitalizeName(aName: string): string;
begin
   result:=aName;
   if aName[1] in ['A'..'Z'] then
      inc(Result[1], ord('a') - ord('A'))
end;

@ We will be populating global variables tracking names of
identifiers, modes, and other syntactic classes.

@<Global variables publicly declared in \texttt{wsmarticle.pas}@>=
var
   IdentifierName,AttributeName,StructureName,ModeName,PredicateName,FunctorName,SelectorName,LeftBracketName,RightBracketName,MMLIdentifierName: array of string;

@ We will want to initialize these global variables based on previous
passes of the scanner.

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure InitScannerNames;
var i,lCnt,lNr: integer;
lDct: text;
lInFile: XMLInStreamPtr;
lKind,lDummy:AnsiChar; lString: string;
begin
   @<Populate global variables with \XML/ entities@>;
   @<Reset reserved keywords@>; @/
   {Identifiers}
   @<Initialize identifier names from \texttt{.idx} file@>;
end;

@ We need to initialize the length for each of these arrays. Even a
crude approximation works, like the total number of lines in
the \texttt{.dct} file. Then we transform each line of the \\{lDct}
(dictionary file) into appropriate entries of the relevant array.

@:dct file}{\texttt{.dct} file@>
@:File, dct}{File, \texttt{.dct}@>

@<Populate global variables with \XML/ entities@>=
   assign(lDct,MizFileName+'.dct');
   reset(lDct);
   lCnt:=0;
   while not seekEof(lDct) do
   begin
      readln(lDct);
      inc(lCnt);
   end;
   setlength(AttributeName,lCnt);
   setlength(StructureName,lCnt);
   setlength(ModeName,lCnt);
   setlength(PredicateName,lCnt);
   setlength(FunctorName,lCnt);
   setlength(SelectorName,lCnt);
   setlength(LeftBracketName,lCnt);
   setlength(RightBracketName,lCnt);
   setlength(MMLIdentifierName,lCnt);
   reset(lDct);
   while not seekEof(lDct) do
   begin
      readln(lDct,lKind,lNr,lDummy,lString);
      @<Store \XML/ version of vocabulary word@>;
   end;
   close(lDct)

@ We have read in from the ``\texttt{.dct}'' file one line. The first
148 lines of a ``\texttt{.dct}'' file consists of the reserved
keywords for Mizar. A random example of the last few lines of such a file look like:

\medbreak
{\obeylines\parindent=0pt\advance\leftskip3pc\tt
A36 VECTSP\_4
A37 ORDINAL1
A38 CARD\_FIL
A39 RANKNULL
A40 VECTSP\_1
A41 VECTSP\_6
A42 VECTSP13
A43 ALGSTR\_0
A44 HALLMAR1
A45 MATROID0\par}

\medbreak\noindent%
So we read the first leading letter of a line into \\{lKind}, then the
number into \\{lNr}, the space is stuffed into \\{lDummy}, and the
remainder of the line is placed in \\{lString}.

@:dct file}{\texttt{.dct} file@>
@:File, dct}{File, \texttt{.dct}@>

@<Store \XML/ version of vocabulary word@>=
      case lKind of
         'A': MMLIdentifierName[lNr]:=QuoteStrForXML(lString);
         'G': StructureName[lNr]:=QuoteStrForXML(lString);
         'M': ModeName[lNr]:=QuoteStrForXML(lString);
         'K': LeftBracketName[lNr]:=QuoteStrForXML(lString);
         'L': RightBracketName[lNr]:=QuoteStrForXML(lString);
         'O': FunctorName[lNr]:=QuoteStrForXML(lString);
         'R': PredicateName[lNr]:=QuoteStrForXML(lString);
         'U': SelectorName[lNr]:=QuoteStrForXML(lString);
         'V': AttributeName[lNr]:=QuoteStrForXML(lString);
      endcases

@ \node{Preserve reserved keywords.}
We want to prevent the user from ``overwriting'' or ``shadowing''
the builtin primitive reserved words. This should probably be
documented in the user-manual somewhere. The reserved words are:
``\texttt{strict}'',  ``\texttt{set}'',``\texttt{=}'', and the
brackets \texttt{[\hskip1pt]}, braces \texttt{\LB\hskip1pt\RB}, and
parentheses \texttt{(\hskip1pt)}. Curiously, ``\texttt{object}'' is
not considered a `primitive' worth preserving.

@<Reset reserved keywords@>=
   AttributeName[StrictSym]:='strict';
   ModeName[SetSym]:='set';
   PredicateName[EqualitySym]:='=';
   LeftBracketName[SquareBracket]:='[';
   LeftBracketName[CurlyBracket]:='{';
   LeftBracketName[RoundedBracket]:='(';
   RightBracketName[SquareBracket]:=']';
   RightBracketName[CurlyBracket]:='}';
   RightBracketName[RoundedBracket]:=')'

@ The \texttt{.idx} file provides numbers for the local labels and
article names referenced in an article.

@:idx File}{\texttt{.idx} File@>
@:File, idx}{File, \texttt{.idx}@>

@<Initialize identifier names from \texttt{.idx} file@>=
   assign(lDct,MizFileName+'.idx');
   reset(lDct);
   lCnt:=0;
   while not seekEof(lDct) do
   begin
      readln(lDct);
      inc(lCnt);
   end;
   close(lDct); @#
   setlength(IdentifierName,lCnt);
   IdentifierName[0]:='';
   lInFile:=new(XMLInStreamPtr,OpenFile(MizFileName+'.idx'));
   lInFile^.NextElementState;
   lInFile^.NextElementState;
   while (lInFile.nState = eStart) and (lInFile.nElName = XMLElemName[elSymbol]) do
   begin
      lNr:=lInFile^.GetIntAttr('nr');
      lString:=lInFile^.GetAttr('name');
      IdentifierName[lNr]:=lString;
      lInFile^.NextElementState;
      lInFile^.NextElementState;
   end;
   dispose(lInFile,Done)

@ We will want to obtain the name for an article ID number, provided
it is a legal number (i.e., less than the dictionary for article ID numbers).
This function looks up its entry in the \\{IdentifierName} array.

@<Implementation for \texttt{wsmarticle.pas}@>=
function IdentRepr(aIdNr:integer):string;
begin
   mizassert(2000,aIdNr <= length(IdentifierName));
   if aIdNr > 0 then
      IdentRepr := IdentifierName[aIdNr]
   else IdentRepr := '';
end;

@* [S] Writing WSM XML files.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   OutWSMizFilePtr = ^OutWSMizFileObj; @/
   OutWSMizFileObj =
      object(XMLOutStreamObj) @t\1 @> @/
         nDisplayInformationOnScreen: boolean; @/
         nMizarAppearance: boolean; @/
         constructor OpenFile(const aFileName:string );@t\2@>
         constructor OpenFileWithXSL(const aFileName:string );@t\2@>
         destructor Done; virtual;@t\2@>

         procedure Out_TextProper(aWSTextProper:WSTextProperPtr); virtual;@t\2@>
         procedure Out_Block(aWSBlock:WSBlockPtr); virtual;@t\2@>
         procedure Out_Item(aWSItem:WSItemPtr); virtual;@t\2@>

         procedure Out_ItemContentsAttr(aWSItem:WSItemPtr); virtual;@t\2@>
         procedure Out_ItemContents(aWSItem:WSItemPtr); virtual;@t\2@>

         procedure Out_Variable( aVar: VariablePtr); virtual;@t\2@>
         procedure Out_ReservedVariable( aVar: VariablePtr); virtual;@t\2@>@#

         procedure Out_TermList ( aTrmList:PList ); virtual;@t\2@>
         procedure Out_Adjective(aAttr:AdjectiveExpressionPtr ); virtual;@t\2@>
         procedure Out_AdjectiveList( aCluster: PList ); virtual;@t\2@>
         procedure Out_Type ( aTyp: TypePtr ); virtual;@t\2@>
         procedure Out_ImplicitlyQualifiedVariable( aSegm: ImplicitlyQualifiedSegmentPtr); virtual;@t\2@>
         procedure Out_VariableSegment( aSegm: QualifiedSegmentPtr); virtual;@t\2@>
         procedure Out_PrivatePredicativeFormula ( aFrm: PrivatePredicativeFormulaPtr ); virtual;@t\2@>
         procedure Out_Formula ( aFrm:FormulaPtr ); virtual;@t\2@>
         procedure Out_Term ( aTrm: TermPtr ); virtual;@t\2@>
         procedure Out_SimpleTerm ( aTrm: SimpleTermPtr ); virtual;@t\2@>
         procedure Out_PrivateFunctorTerm ( aTrm: PrivateFunctorTermPtr ); virtual;@t\2@>
         procedure Out_InternalSelectorTerm ( aTrm: InternalSelectorTermPtr ); virtual;@t\2@>

         procedure Out_TypeList ( aTypeList: PList ); virtual;@t\2@>

         procedure Out_Locus( aLocus: LocusPtr); virtual;@t\2@>
         procedure Out_Loci( aLoci: PList); virtual;@t\2@>
         procedure Out_Pattern(aPattern: PatternPtr); virtual;@t\2@>@#

         procedure Out_Label(aLab:LabelPtr); virtual;@t\2@>
         procedure Out_Definiens(aDef:DefiniensPtr); virtual;@t\2@>@#

         procedure Out_ReservationSegment(aRes:ReservationSegmentPtr); virtual;@t\2@>
         procedure Out_SchemeNameInSchemeHead(aSch: SchemePtr); virtual;@t\2@>
         procedure Out_CompactStatement(aCStm:CompactStatementPtr; aBlock:wsBlockPtr); virtual;@t\2@>
         procedure Out_RegularStatement(aRStm:RegularStatementPtr; aBlock:wsBlockPtr); virtual;@t\2@>
         procedure Out_Proposition(aProp:PropositionPtr); virtual;@t\2@>
         procedure Out_LocalReference(aRef: LocalReferencePtr); virtual;@t\2@>
         procedure Out_References(aRefs: PList); virtual;@t\2@>
         procedure Out_Link(aInf: JustificationPtr); virtual;@t\2@>
         procedure Out_SchemeJustification(aInf: SchemeJustificationPtr); virtual;@t\2@>
         procedure Out_Justification(aInf: JustificationPtr; aBlock:wsBlockPtr); virtual;@t\2\2\2@>
      end;

@ \node{Constructor.} The constructor 
\\{OutWSMizFileObj.OpenFileWithXSL} is not used anywhere, nor is the
associated ``\texttt{wsmiz.xml}'' file present anywhere.

Importantly, the \\{nMizarAppearance} field controls whether the \XML/
generated includes the raw lexeme string as an attribute in the \XML/
elements or not.

The constructor \\{OpenFileWithXSL} is never used. The \XML/
stylesheet \texttt{wsmiz.xml} does not seem to be present in the Mizar
distribution. 

\label{OutWSMizFileObj.OpenFileWithXSL}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor OutWSMizFileObj.OpenFile(const aFileName:string);
begin
   inherited OpenFile( aFileName);
   nMizarAppearance:=false;
   nDisplayInformationOnScreen:=false;
end;

constructor OutWSMizFileObj.OpenFileWithXSL(const aFileName:string);
begin
   inherited OpenFile( aFileName);
   OutString('<?xml-stylesheet type="text/xml" href="file://'+MizFiles+'wsmiz.xml"?>'+#10);
   nMizarAppearance:=false;
end;

destructor OutWSMizFileObj.Done;
begin
   inherited Done;
end;

@ We can write the \XML/ for a \\{wsTextProper} object
(\section\xref{wsTextProper:ast}). This writes out the start tag, the
children, and the end-tag for the ``text proper'' and its
contents. The RNG compact schema for this looks like:

\medbreak
{\schema
TextProper = element Text-Proper \LB
\idnr{\quad},
\pos{\quad},
\quad  Item*
\RB\par}
@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_TextProper(aWSTextProper:WSTextProperPtr);
var i: integer;
begin
   with aWSTextProper^ do
   begin {Write the start-tag}
      Out_XElStart(BlockName[blMain]);
      Out_XAttr( XMLAttrName[atArticleId], nArticleId);
      Out_XAttr( XMLAttrName[atArticleExt], nArticleExt);
      Out_PosAsAttrs(nBlockPos);
      Out_XAttrEnd; 
      for i := 0 to nItems^.Count - 1 do
         Out_Item(nItems.Items^[i]); {...then write the children}
      Out_XElEnd( BlockName[blMain]);
   end;
end;

@ Writing a block out as \XML/ works similarly: write the start-tag,
then its children elements, then the end-tag.

\medbreak
{\schema
Block = element Block \LB
\quad attribute kind \LB\ "Text-Proper" \pipe\ "Now-Reasoning"
\qquad\pipe\ "Hereby-Reasoning" \pipe\ "Definitional-Block"
\qquad\pipe\ "Notation-Block" \pipe\ "Registration-Block" \pipe\ "Case"
\qquad\pipe\ "Suppose" \pipe\ "Scheme-Block" \RB,
\idnr{\quad},
\pos{\quad},
\quad  Item*
\RB\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Block(aWSBlock:WSBlockPtr);
var i: integer;
begin
   with aWSBlock^ do
   begin {write the start-tag}
      Out_XElStart( XMLElemName[elBlock]);
      Out_XAttr( XMLAttrName[atKind], BlockName[nBlockKind]);
      CurPos:=nBlockPos;
      Out_PosAsAttrs(nBlockPos);
      Out_XIntAttr( XMLAttrName[atPosLine], nBlockEndPos.Line);
      Out_XIntAttr( XMLAttrName[atPosCol], nBlockEndPos.Col);
      Out_XAttrEnd;
      for i := 0 to nItems^.Count - 1 do
      begin
         Out_Item(nItems^.Items^[i]); @+
      end; {Then write the children}
      Out_XElEnd( XMLElemName[elBlock]);
   end;
end;

@ Writing a term list to  \XML/ amounts to just writing the terms
as \XML/ elements. They will be contained in a parent element, so
there will be no ambiguity in their role.

\medbreak
{\schema
Term-List = ( Term* )
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_TermList ( aTrmList:PList );
var i: integer;
begin
   for i:=0 to aTrmList^.Count-1 do
      Out_Term(aTrmList^.Items^[i]);
end;

@ The \XML/ for an adjective boils down to two cases:

Case 1 (negated attribute). Write a \texttt{<NegatedAdjective>} tag
around the \XML/ produced from case 2 for the positive version of the attribute.

Case 2 (positive attribute). Write the adjective, and its children are
the [term] arguments to the adjective (if any --- if there are none,
then an empty-element will be produced).

\medbreak
{\schema
PositiveAdjective = element Adjective \LB
\quad attribute nr \LB\ xsd:integer \RB,
\quad attribute name \LB\ text \RB,
\spelling{\quad}?,
\pos{\quad}
\quad Term*
\RB
Adjective = PositiveAdjective \pipe\ element NegatedAdjective \LB
\pos{\quad},
\quad PositiveAdjective
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Adjective(aAttr:AdjectiveExpressionPtr);
begin
   case aAttr^.nAdjectiveSort of
      wsAdjective:
         begin
            Out_XElStart( XMLElemName[elAdjective]);
            with AdjectivePtr(aAttr)^ do
            begin
               Out_XIntAttr( XMLAttrName[atNr],nAdjectiveSymbol );
               if nMizarAppearance then
                  Out_XAttr( XMLAttrName[atSpelling], AttributeName[nAdjectiveSymbol]);
               Out_PosAsAttrs(nAdjectivePos);
               if nArgs^.Count = 0 then
                  Out_XElEnd0
               else
               begin
                  Out_XAttrEnd;
                  Out_TermList( nArgs );
                  Out_XElEnd( XMLElemName[elAdjective]);
               end;
            end;
         end;
      wsNegatedAdjective:
         begin
            Out_XElStart( XMLElemName[elNegatedAdjective]);
            with NegatedAdjectivePtr(aAttr)^ do
            begin
               Out_PosAsAttrs(nAdjectivePos);
               Out_XAttrEnd;
               Out_Adjective( nArg );
            end;
            Out_XElEnd( XMLElemName[elNegatedAdjective]);
         end;
   endcases;
end;

@ Writing an adjective list to \XML/ amounts to stuffing all the
adjectives into an element. If there are no adjectives, it is the
empty-element.

\medbreak
{\schema
Adjective-Cluster = element Adjective-Cluster \LB
\quad attribute count \LB\ xsd:integer \RB,
\quad Adjective*
\RB\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_AdjectiveList(aCluster: PList);
var i: integer;
begin
   Out_XElStart( XMLElemName[elAdjectiveCluster]);
   if aCluster^.Count = 0 then begin Out_XElEnd0; exit; end;
   Out_XAttrEnd;
   with aCluster^ do
      for i:=0 to Count-1 do
         Out_Adjective( Items^[i]);
   Out_XElEnd( XMLElemName[elAdjectiveCluster]);
end;

@* [s] Emitting XML for types.
Writing the \XML/ for a Mizar type.

\medbreak
{\schema
StandardType = element Standard-Type \LB
\quad attribute nr \LB\ xsd:integer \RB,
\spelling{\quad}?,
\pos{\quad},
\quad Term*
\RB
StructureType = element Structure-Type \LB
\quad attribute nr \LB\ xsd:integer \RB,
\spelling{\quad}?,
\pos{\quad},
\quad Term*
\RB
ClusteredType = element Clustered-Type \LB
\pos{\quad},
\quad Adjective-Cluster,
\quad Type,
\RB
Type = StandardType \pipe\ StructureType \pipe\ ClusteredType
\par}

@d print_arguments(#) == if  nArgs^.Count = 0 then Out_XElEnd0
            else begin
               Out_XAttrEnd;
               Out_TermList( nArgs );
               Out_XElEnd( TypeName[#] );
            end

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Type ( aTyp: TypePtr);
begin
   with aTyp^ do
      case aTyp^.nTypeSort of
         wsStandardType:
            with StandardTypePtr(aTyp)^ do
         begin
            Out_XElStart( TypeName[wsStandardType] );
            Out_XIntAttr( XMLAttrName[atNr], nModeSymbol );
            if nMizarAppearance then
               Out_XAttr( XMLAttrName[atSpelling], ModeName[nModeSymbol]);
            Out_PosAsAttrs(nTypePos);
            print_arguments(wsStandardType);
         end;
         wsStructureType:
            with StructTypePtr(aTyp)^ do
         begin
            Out_XElStart( TypeName[wsStructureType] );
            Out_XIntAttr( XMLAttrName[atNr], nStructSymbol );
            if nMizarAppearance then
               Out_XAttr( XMLAttrName[atSpelling], StructureName[nStructSymbol]);
            Out_PosAsAttrs(nTypePos);
            print_arguments(wsStructureType);
         end;
         wsClusteredType:
            with ClusteredTypePtr(aTyp)^ do
         begin
            Out_XElStart( TypeName[wsClusteredType] );
            Out_PosAsAttrs(nTypePos);
            Out_XAttrEnd;
            Out_AdjectiveList(nAdjectiveCluster);
            Out_Type(nType);
            Out_XElEnd( TypeName[wsClusteredType] );
         end;
         wsErrorType:
            begin
               Out_XElWithPos(TypeName[wsErrorType],nTypePos);
            end;
      endcases;
end;

@ Printing a variable as an \XML/ element.

\medbreak
{\schema
Variable = element Variable \LB
\idnr{\quad},
\spelling{\quad}?,
\pos{\quad}
\RB\par}

\label{OutWSMizFileObj.Out_Variable}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Variable( aVar: VariablePtr);
begin
   with aVar ^ do
   begin
      Out_XElStart( XMLElemName[elVariable]);
      Out_XIntAttr( XMLAttrName[atIdNr], nIdent);
      if nMizarAppearance then
         Out_XAttr( XMLAttrName[atSpelling], IdentRepr(nIdent));
      Out_PosAsAttrs(nVarPos);
      Out_XElEnd0
   end;
end;

@ Variables introduced using ``\texttt{reserve}'' are just printed out
like any other variable.

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_ReservedVariable( aVar: VariablePtr);
begin
   Out_Variable(aVar);
end;

@ Implicitly qualified variables (i.e., variables which
are \texttt{reserved} with a type, then used in, e.g., a quantified
formula) are just variables appearing as children of an ``implicitly
qualified'' \XML/ element.

{\tt\obeylines
VariableSegment \pipe= element Implicitly-Qualified-Segment \LB
\pos{\quad},
\quad Variable
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_ImplicitlyQualifiedVariable( aSegm: ImplicitlyQualifiedSegmentPtr);
begin
   Out_XElStart( SegmentKindName[ikImplQualifiedSegm]);
   Out_PosAsAttrs(aSegm^.nSegmPos);
   Out_XAttrEnd;
   Out_Variable( aSegm^.nIdentifier);
   Out_XElEnd( SegmentKindName[ikImplQualifiedSegm]);
end;

@ Qualified variable segments are either implicitly qualified (hence
we use the previous function) or explicitly qualified (which look like
``\<variable list> \texttt{being} \<type>'').

Explicitly qualified segments are an \XML/ element with two children (a
``variables'' \XML/ element, and a ``type'' \XML/ element). 

\medbreak
{\schema
VariableSegment \pipe= element Explicitly-Qualified-Segment \LB
\pos{\quad},
\quad element Variables \LB\ Variable* \RB,
\quad Type
\RB
\par}

\label{OutWSMizFileObj.Out_VariableSegment}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_VariableSegment( aSegm: QualifiedSegmentPtr);
var i: integer;
begin
   case aSegm^.nSegmentSort of
      ikImplQualifiedSegm:
         Out_ImplicitlyQualifiedVariable(ImplicitlyQualifiedSegmentPtr(aSegm));
      ikExplQualifiedSegm:
         with ExplicitlyQualifiedSegmentPtr(aSegm)^ do
      begin
         Out_XElStart(SegmentKindName[ikExplQualifiedSegm]);
         Out_PosAsAttrs(nSegmPos);
         Out_XAttrEnd;
         Out_XElStart0( XMLElemName[elVariables]);
         for i:=0 to nIdentifiers^.Count-1 do
            Out_Variable( nIdentifiers^.Items^[i]);
         Out_XElEnd( XMLElemName[elVariables]);
         Out_Type(nType);
         Out_XElEnd( SegmentKindName[ikExplQualifiedSegm]);
      end;
   endcases;
end;

@ Private predicates have the \XML/ schema

{\tt\obeylines
Private-Predicate-Formula = element Private-Predicate-Formula \LB
\idnr{\quad},
\spelling{\quad}?,
\pos{\quad},
\quad  Term-List?
\RB\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_PrivatePredicativeFormula ( aFrm: PrivatePredicativeFormulaPtr );
begin
   with PrivatePredicativeFormulaPtr(aFrm)^ do
   begin
      Out_XElStart(FormulaName[wsPrivatePredicateFormula]);
      Out_XIntAttr( XMLAttrName[atIdNr], nPredIdNr);
      if nMizarAppearance then
         Out_XAttr( XMLAttrName[atSpelling], IdentRepr(nPredIdNr));
      Out_PosAsAttrs(nFormulaPos);
      if nArgs^.Count = 0 then Out_XElEnd0
      else begin
         Out_XAttrEnd;
         Out_TermList( nArgs);
         Out_XElEnd( FormulaName[wsPrivatePredicateFormula]);
      end;
   end;
end;

@* [s] Emitting XML for formulas.
The \XML/ schema for formulas looks something like:

\medbreak
{\schema
Formula = NegatedFormula
\pipe\ ConjunctiveFormula
\pipe\ DisjunctiveFormula
\pipe\ ConditionalFormula
\pipe\ BiconditionalFormula
\pipe\ FlexaryConjunctiveFormula
\pipe\ FlexaryDisjunctiveFormula
\pipe\ Predicative-Formula
\pipe\ RightSideOf-Predicative-Formula
\pipe\ Multi-Predicative-Formula
\pipe\ Attributive-Formula
\pipe\ Qualifying-Formula
\pipe\ Universal-Quantifier-Formula
\pipe\ Existential-Quantifier-Formula
\pipe\ element Contradiction \LB
\pos{\qquad}\ \RB
\pipe\ element Thesis \LB
\pos{\qquad}\ \RB
\pipe\ element Formula-Error \LB
\pos{\qquad}\ \RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Formula ( aFrm: FormulaPtr );
var i: integer;
begin
   case aFrm^.nFormulaSort of
      wsNegatedFormula:
         @<Emit XML for negated formula (WSM)@>;
      wsConjunctiveFormula:
         @<Emit XML for conjunction (WSM)@>;
      wsDisjunctiveFormula:
         @<Emit XML for disjunction (WSM)@>;
      wsConditionalFormula:
         @<Emit XML for conditional formula (WSM)@>;
      wsBiconditionalFormula:
         @<Emit XML for biconditional formula (WSM)@>;
      wsFlexaryConjunctiveFormula:
         @<Emit XML for flexary-conjunction (WSM)@>;
      wsFlexaryDisjunctiveFormula:
         @<Emit XML for flexary-disjunction (WSM)@>;
      wsPredicativeFormula:
         @<Emit XML for predicative formula (WSM)@>;
      wsRightSideOfPredicativeFormula:
         @<Emit XML for right-side of predicative formula (WSM)@>;
      wsMultiPredicativeFormula:
         @<Emit XML for multi-predicative formula (WSM)@>;
      wsPrivatePredicateFormula:
         Out_PrivatePredicativeFormula(PrivatePredicativeFormulaPtr(aFrm));
      wsAttributiveFormula:
         @<Emit XML for attributive formula (WSM)@>;
      wsQualifyingFormula:
         @<Emit XML for qualifying formula (WSM)@>;
      wsUniversalFormula:
         @<Emit XML for universal formula (WSM)@>;
      wsExistentialFormula:
         @<Emit XML for existential formula (WSM)@>;
      wsContradiction:
         begin
            Out_XElWithPos(FormulaName[wsContradiction],aFrm^.nFormulaPos);
         end;
      wsThesis:
         begin
            Out_XElWithPos(FormulaName[wsThesis],aFrm^.nFormulaPos);
         end;
      wsErrorFormula:
         begin
            Out_XElWithPos(FormulaName[wsErrorFormula],aFrm^.nFormulaPos);
         end;
   endcases;
end;

@


\medbreak
{\schema
NegatedFormula = element Negated-Formula \LB
\pos{\quad},
\quad Formula
\RB\par}

@<Emit XML for negated formula (WSM)@>=
         begin
            Out_XElStart(FormulaName[wsNegatedFormula]);
            Out_PosAsAttrs(aFrm^.nFormulaPos);
            Out_XAttrEnd;
            Out_Formula( NegativeFormulaPtr(aFrm)^.nArg);
            Out_XElEnd( FormulaName[wsNegatedFormula]);
         end

@

\medbreak
{\schema
ConjunctiveFormula = element Conjunctive-Formula \LB
\pos{\quad},
\quad Formula,
\quad Formula
\RB
\par}

@<Emit XML for conjunction (WSM)@>=
         begin
            Out_XElStart( FormulaName[wsConjunctiveFormula]);
            Out_PosAsAttrs(aFrm^.nFormulaPos);
            Out_XAttrEnd;
            Out_Formula(BinaryFormulaPtr(aFrm)^.nLeftArg);
            Out_Formula(BinaryFormulaPtr(aFrm)^.nRightArg);
            Out_XElEnd( FormulaName[wsConjunctiveFormula]);
         end

@

\medbreak
{\schema
DisjunctiveFormula = element Disjunctive-Formula \LB
\pos{\quad},
\quad Formula,
\quad Formula
\RB
\par}

@<Emit XML for disjunction (WSM)@>=
         begin
            Out_XElStart( FormulaName[wsDisjunctiveFormula]);
            Out_PosAsAttrs(aFrm^.nFormulaPos);
            Out_XAttrEnd;
            Out_Formula(BinaryFormulaPtr(aFrm)^.nLeftArg);
            Out_Formula(BinaryFormulaPtr(aFrm)^.nRightArg);
            Out_XElEnd( FormulaName[wsDisjunctiveFormula]);
         end

@

\medbreak
{\schema
ConditionalFormula = element Conditional-Formula \LB
\pos{\quad},
\quad Formula,
\quad Formula
\RB
\par}

@<Emit XML for conditional formula (WSM)@>=
         begin
            Out_XElStart( FormulaName[wsConditionalFormula]);
            Out_PosAsAttrs(aFrm^.nFormulaPos);
            Out_XAttrEnd;
            Out_Formula(BinaryFormulaPtr(aFrm)^.nLeftArg);
            Out_Formula(BinaryFormulaPtr(aFrm)^.nRightArg);
            Out_XElEnd( FormulaName[wsConditionalFormula]);
         end

@
\medbreak
{\schema
BiconditionalFormula = element Biconditional-Formula \LB
\pos{\quad},
\quad Formula,
\quad Formula
\RB
\par}

@<Emit XML for biconditional formula (WSM)@>=
         begin
            Out_XElStart( FormulaName[wsBiconditionalFormula]);
            Out_PosAsAttrs(aFrm^.nFormulaPos);
            Out_XAttrEnd;
            Out_Formula(BinaryFormulaPtr(aFrm)^.nLeftArg);
            Out_Formula(BinaryFormulaPtr(aFrm)^.nRightArg);
            Out_XElEnd( FormulaName[wsBiconditionalFormula]);
         end
@

\medbreak
{\schema
FlexaryConjunctiveFormula = element FlexaryConjunctive-Formula \LB
\pos{\quad},
\quad Formula,
\quad Formula
\RB
\par}

@<Emit XML for flexary-conjunction (WSM)@>=
         begin
            Out_XElStart( FormulaName[wsFlexaryConjunctiveFormula]);
            Out_PosAsAttrs(aFrm^.nFormulaPos);
            Out_XAttrEnd;
            Out_Formula(BinaryFormulaPtr(aFrm)^.nLeftArg);
            Out_Formula(BinaryFormulaPtr(aFrm)^.nRightArg);
            Out_XElEnd( FormulaName[wsFlexaryConjunctiveFormula]);
         end

@

\medbreak
{\schema
FlexaryDisjunctiveFormula = element FlexaryDisjunctive-Formula \LB
\pos{\quad},
\quad Formula,
\quad Formula
\RB
\par}

@<Emit XML for flexary-disjunction (WSM)@>=
         begin
            Out_XElStart( FormulaName[wsFlexaryDisjunctiveFormula]);
            Out_PosAsAttrs(aFrm^.nFormulaPos);
            Out_XAttrEnd;
            Out_Formula(BinaryFormulaPtr(aFrm)^.nLeftArg);
            Out_Formula(BinaryFormulaPtr(aFrm)^.nRightArg);
            Out_XElEnd( FormulaName[wsFlexaryDisjunctiveFormula]);
         end

@


\medbreak
{\schema
Predicative-Formula = element Predicative-Formula \LB
\quad attribute nr \LB\ xsd:integer \RB,
\spelling{\quad}?,
\pos{\quad},
\quad element Arguments \LB\ Term-List? \RB,
\quad element Arguments \LB\ Term-List? \RB
\RB
\par}

@<Emit XML for predicative formula (WSM)@>=
         with PredicativeFormulaPtr(aFrm)^ do
      begin
         Out_XElStart(FormulaName[wsPredicativeFormula]);
         Out_XIntAttr( XMLAttrName[atNr], nPredNr);
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], PredicateName[nPredNr]);
         Out_PosAsAttrs(nFormulaPos);
         Out_XAttrEnd;
         if nLeftArgs^.Count = 0 then
            Out_XEl1(XMLElemName[elArguments])
         else
         begin
            Out_XElStart0(XMLElemName[elArguments]);
            Out_TermList( nLeftArgs);
            Out_XElEnd( XMLElemName[elArguments]);
         end;
         if nRightArgs^.Count = 0 then
            Out_XEl1(XMLElemName[elArguments])
         else
         begin
            Out_XElStart0(XMLElemName[elArguments]);
            Out_TermList( nRightArgs);
            Out_XElEnd( XMLElemName[elArguments]);
         end;
         Out_XElEnd( FormulaName[wsPredicativeFormula]);
      end

@

\medbreak
{\schema
RightSideOf-Predicative-Formula = element RightSideOf-Predicative-Formula \LB
\quad attribute nr \LB\ xsd:integer \RB,
\spelling{\quad}?,
\pos{\quad},
\quad element Arguments \LB\ Term-List? \RB
\RB
\par}

@<Emit XML for right-side of predicative formula (WSM)@>=
         with RightSideOfPredicativeFormulaPtr(aFrm)^ do
      begin
         Out_XElStart(FormulaName[wsRightSideOfPredicativeFormula]);
         Out_XIntAttr( XMLAttrName[atNr], nPredNr);
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], PredicateName[nPredNr]);
         Out_PosAsAttrs(nFormulaPos);
         Out_XAttrEnd;
         if nRightArgs^.Count = 0 then
            Out_XEl1(XMLElemName[elArguments])
         else
         begin
            Out_XElStart0(XMLElemName[elArguments]);
            Out_TermList( nRightArgs);
            Out_XElEnd( XMLElemName[elArguments]);
         end;
         Out_XElEnd( FormulaName[wsRightSideOfPredicativeFormula])
      end
@

\medbreak
{\schema
Multi-Predicative-Formula = element Multi-Predicative-Formula \LB
\pos{\quad},
\quad Formula*
\RB

\par}

@<Emit XML for multi-predicative formula (WSM)@>=
         with MultiPredicativeFormulaPtr(aFrm)^ do
      begin
         Out_XElStart( FormulaName[wsMultiPredicativeFormula]);
         Out_PosAsAttrs(aFrm^.nFormulaPos);
         Out_XAttrEnd;
         for i:=0 to nScraps.Count - 1 do
            Out_Formula(nScraps^.Items^[i]);
         Out_XElEnd( FormulaName[wsMultiPredicativeFormula])
      end

@

\medbreak
{\schema
Attributive-Formula = element Attributive-Formula \LB
\pos{\quad},
\quad Term,
\quad Adjective-Cluster.element
\RB\par}

@<Emit XML for attributive formula (WSM)@>=
         with AttributiveFormulaPtr(aFrm)^ do
      begin
         Out_XElStart(FormulaName[wsAttributiveFormula]);
         Out_PosAsAttrs(nFormulaPos);
         Out_XAttrEnd;
         Out_Term(nSubject);
         Out_AdjectiveList(nAdjectives);
         Out_XElEnd( FormulaName[wsAttributiveFormula]);
      end

@

\medbreak
{\schema
Qualifying-Formula = element Qualifying-Formula \LB
\pos{\quad},
\quad Term,
\quad Type,
\quad Formula
\RB\par}

@<Emit XML for qualifying formula (WSM)@>=
         with QualifyingFormulaPtr(aFrm)^ do
      begin
         Out_XElStart(FormulaName[wsQualifyingFormula]);
         Out_PosAsAttrs(nFormulaPos);
         Out_XAttrEnd;
         Out_Term(nSubject);
         Out_Type(nType);
         Out_XElEnd( FormulaName[wsQualifyingFormula]);
      end

@

\medbreak
{\schema
Universal-Quantifier-Formula = element Universal-Quantifier-Formula \LB
\pos{\quad},
\quad Variable-Segment,
\quad Formula
\RB\par}

@<Emit XML for universal formula (WSM)@>=
         with QuantifiedFormulaPtr( aFrm)^ do
      begin
         Out_XElStart(FormulaName[wsUniversalFormula]);
         Out_PosAsAttrs(nFormulaPos);
         Out_XAttrEnd;
         Out_VariableSegment(QuantifiedFormulaPtr(aFrm)^.nSegment);
         Out_Formula(QuantifiedFormulaPtr(aFrm)^.nScope);
         Out_XElEnd( FormulaName[wsUniversalFormula]);
      end

@

\medbreak
{\schema
Existential-Quantifier-Formula = element Existential-Quantifier-Formula \LB
\pos{\quad},
\quad Variable-Segment,
\quad Formula
\RB\par}

@<Emit XML for existential formula (WSM)@>=
         with QuantifiedFormulaPtr( aFrm)^ do
      begin
         Out_XElStart(FormulaName[wsExistentialFormula]);
         Out_PosAsAttrs(nFormulaPos);
         Out_XAttrEnd;
         Out_VariableSegment(QuantifiedFormulaPtr(aFrm)^.nSegment);
         Out_Formula(QuantifiedFormulaPtr(aFrm)^.nScope);
         Out_XElEnd( FormulaName[wsExistentialFormula]);
      end

@* [s] Emitting XML for Terms.
We begin with simple terms.

\medbreak
{\schema
Term \pipe= element Simple-Term \LB
\idnr{\quad},
\spelling{\quad}?,
\pos{\quad}
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_SimpleTerm ( aTrm: SimpleTermPtr );
begin
   Out_XElStart( TermName[wsSimpleTerm]);
   Out_XIntAttr( XMLAttrName[atIdNr], aTrm^.nIdent);
   if nMizarAppearance then
      Out_XAttr( XMLAttrName[atSpelling], IdentRepr(aTrm^.nIdent));
   Out_PosAsAttrs(aTrm^.nTermPos);
   Out_XElEnd0;
end;

@ \node{Terms: Private functors.}

\medbreak
{\schema
Term \pipe= element Private-Functor-Term \LB
\idnr{\quad},
\spelling{\quad}?,
\pos{\quad},
\quad element Arguments \LB\ Term-List \RB?
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_PrivateFunctorTerm ( aTrm: PrivateFunctorTermPtr );
begin
   with PrivateFunctorTermPtr(aTrm)^ do
   begin
      Out_XElStart(TermName[wsPrivateFunctorTerm]);
      Out_XIntAttr( XMLAttrName[atIdNr], nFunctorIdent);
      if nMizarAppearance then
         Out_XAttr( XMLAttrName[atSpelling], IdentRepr(nFunctorIdent));
      Out_PosAsAttrs(nTermPos);
      if nArgs^.Count = 0 then Out_XElEnd0
      else begin
         Out_XAttrEnd;
         Out_TermList( nArgs);
         Out_XElEnd( TermName[wsPrivateFunctorTerm]);
      end;
   end;
end;

@ \node{Terms: internal selectors.}

\medbreak
{\schema
Term \pipe= element Internal-Selector-Term \LB
\quad attribute nr \LB\ text \RB,
\spelling{\quad}?,
\pos{\quad}
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_InternalSelectorTerm ( aTrm: InternalSelectorTermPtr );
begin
   with aTrm^ do
   begin
      Out_XElStart(TermName[wsInternalSelectorTerm]);
      Out_XIntAttr( XMLAttrName[atNr], nSelectorSymbol);
      if nMizarAppearance then
         Out_XAttr( XMLAttrName[atSpelling], SelectorName[nSelectorSymbol]);
      Out_PosAsAttrs(nTermPos);
      Out_XElEnd0;
   end;
end;

@ \node{Terms: numerals, anaphoric ``it'', error.}

\medbreak
{\schema
Term \pipe= element Numeral \LB
\qquad attribute number \LB\ xsd:int \RB,
\pos{\qquad}
\quad \RB
\par}

\medbreak
{\schema
Term \pipe= element It-Term \LB
\pos{\qquad}
\quad \RB
Term \pipe= element Error-Term \LB\ \RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Term ( aTrm: TermPtr );
var i: integer;
begin
   case aTrm^.nTermSort of
      wsPlaceholderTerm:
         @<Emit XML for placeholder (WSM)@>;
      wsSimpleTerm:
         Out_SimpleTerm(SimpleTermPtr(aTrm));
      wsNumeralTerm:
         begin;
            Out_XElStart(TermName[wsNumeralTerm]);
            Out_XIntAttr(XMLAttrName[atNumber], NumeralTermPtr(aTrm)^.nValue);
            Out_PosAsAttrs(aTrm^.nTermPos);
            Out_XElEnd0;
         end;
      wsInfixTerm:
         @<Emit XML for infix term (WSM)@>;
      wsCircumfixTerm:
         @<Emit XML for circumfix term (WSM)@>;
      wsPrivateFunctorTerm:
         Out_PrivateFunctorTerm(PrivateFunctorTermPtr(aTrm));
      wsAggregateTerm:
         @<Emit XML for aggregate term (WSM)@>;
      wsSelectorTerm:
         @<Emit XML for selector term (WSM)@>;
      wsInternalSelectorTerm:
         Out_InternalSelectorTerm(InternalSelectorTermPtr(aTrm));
      wsForgetfulFunctorTerm:
         @<Emit XML for forgetful functor (WSM)@>;
      wsInternalForgetfulFunctorTerm:
         @<Emit XML for internal forgetful functor (WSM)@>;
      wsFraenkelTerm:
         @<Emit XML for Fraenkel term (WSM)@>;
      wsSimpleFraenkelTerm:
         @<Emit XML for simple Fraenkel term (WSM)@>;
      wsQualificationTerm:
         @<Emit XML for qualification term (WSM)@>;
      wsExactlyTerm:
         @<Emit XML for exactly qualification term (WSM)@>;
      wsGlobalChoiceTerm:
         @<Emit XML for global choice term (WSM)@>;
      wsItTerm:
         Out_XElWithPos(TermName[wsItTerm],aTrm^.nTermPos);
      wsErrorTerm:
         Out_XEl1( TermName[wsErrorTerm]);
   endcases;
end;

@ \node{Terms: placeholders.}

\medbreak
{\schema
Term \pipe= element Placeholder-Term \LB
\quad attribute nr \LB\ text \RB,
\spelling{\quad}?,
\pos{\quad}
\RB\par}

@<Emit XML for placeholder (WSM)@>=
         begin
            Out_XElStart( TermName[wsPlaceholderTerm]);
            Out_XIntAttr( XMLAttrName[atNr], PlaceholderTermPtr(aTrm)^.nLocusNr);
            if nMizarAppearance then
               Out_XAttr( XMLAttrName[atSpelling], QuoteStrForXML(PlaceHolderName[PlaceholderTermPtr(aTrm)^.nLocusNr]));
            Out_PosAsAttrs(aTrm^.nTermPos);
            Out_XElEnd0;
         end

@ \node{Terms: infixed.}

\medbreak
{\schema
Term \pipe= element Infix-Term \LB
\quad attribute nr \LB\ text \RB,
\spelling{\quad}?,
\pos{\quad},
\quad element Arguments \LB\ Term-List? \RB,
\quad element Arguments \LB\ Term-List? \RB
\RB\par}

@<Emit XML for infix term (WSM)@>=
         with InfixTermPtr(aTrm)^ do
      begin
         Out_XElStart(TermName[wsInfixTerm]);
         Out_XIntAttr( XMLAttrName[atNr], nFunctorSymbol);
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], FunctorName[nFunctorSymbol]);
         Out_PosAsAttrs(nTermPos);
         Out_XAttrEnd;
         if nLeftArgs^.Count = 0 then
            Out_XEl1(XMLElemName[elArguments])
         else
         begin
            Out_XElStart0(XMLElemName[elArguments]);
            Out_TermList( nLeftArgs);
            Out_XElEnd( XMLElemName[elArguments]);
         end;
         if nRightArgs^.Count = 0 then
            Out_XEl1(XMLElemName[elArguments])
         else
         begin
            Out_XElStart0(XMLElemName[elArguments]);
            Out_TermList( nRightArgs);
            Out_XElEnd(XMLElemName[elArguments]);
         end;
         Out_XElEnd(TermName[wsInfixTerm]);
      end

@ \node{Terms: brackets.}

\medbreak
{\schema
Term \pipe= element Circumfix-Term \LB
\quad attribute nr \LB\ text \RB,
\spelling{\quad}?,
\pos{\quad},
\quad element Right-Circumflex-Symbol \LB
\qquad attribute nr \LB\ text \RB,
\spelling{\qquad}?,
\pos{\qquad}
\quad \RB,
\quad element Arguments \LB\ Term-List? \RB
\RB\par}

@<Emit XML for circumfix term (WSM)@>=
         with CircumfixTermPtr(aTrm)^ do
      begin
         Out_XElStart(TermName[wsCircumfixTerm]);
         Out_XIntAttr( XMLAttrName[atNr], nLeftBracketSymbol);
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], LeftBracketName[nLeftBracketSymbol]);
         Out_PosAsAttrs(nTermPos);
         Out_XAttrEnd;
         Out_XElStart(XMLElemName[elRightCircumflexSymbol]);
         Out_XIntAttr( XMLAttrName[atNr], nRightBracketSymbol);
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], RightBracketName[nRightBracketSymbol]);
         Out_PosAsAttrs(nTermPos);
         Out_XElEnd0;
         Out_TermList( nArgs);
         Out_XElEnd( TermName[wsCircumfixTerm]);
      end

@ \node{Terms: structure instances.}

\medbreak
{\schema
Term \pipe= element Aggregate-Term \LB
\quad attribute nr \LB\ text \RB,
\spelling{\quad}?,
\pos{\quad},
\quad element Arguments \LB\ Term-List \RB?
\RB\par}

@<Emit XML for aggregate term (WSM)@>=
         with AggregateTermPtr(aTrm)^ do
      begin
         Out_XElStart(TermName[wsAggregateTerm]);
         Out_XIntAttr( XMLAttrName[atNr], nStructSymbol);
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], StructureName[nStructSymbol]);
         Out_PosAsAttrs(nTermPos);
         if nArgs^.Count = 0 then Out_XElEnd0
         else begin
            Out_XAttrEnd;
            Out_TermList( nArgs);
            Out_XElEnd( TermName[wsAggregateTerm]);
         end;
      end

@ \node{Terms: selectors.}

\medbreak
{\schema
Term \pipe= element Selector-Term \LB
\quad attribute nr \LB\ text \RB,
\spelling{\quad}?,
\pos{\quad},
\quad Term
\RB\par}

@<Emit XML for selector term (WSM)@>=
         with SelectorTermPtr(aTrm)^ do
      begin
         Out_XElStart(TermName[wsSelectorTerm]);
         Out_XIntAttr( XMLAttrName[atNr], nSelectorSymbol);
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], SelectorName[nSelectorSymbol]);
         Out_PosAsAttrs(nTermPos);
         Out_XAttrEnd;
         Out_Term( nArg);
         Out_XElEnd( TermName[wsSelectorTerm]);
      end

@ \node{Terms: forgetful functors.}

\medbreak
{\schema
Term \pipe= element Forgetful-Functor-Term \LB
\quad attribute nr \LB\ text \RB,
\spelling{\quad}?,
\pos{\quad},
\quad Term
\RB\par}

@<Emit XML for forgetful functor (WSM)@>=
         with ForgetfulFunctorTermPtr(aTrm)^ do
      begin
         Out_XElStart(TermName[wsForgetfulFunctorTerm]);
         Out_XIntAttr( XMLAttrName[atNr], nStructSymbol);
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], StructureName[nStructSymbol]);
         Out_PosAsAttrs(nTermPos);
         Out_XAttrEnd;
         Out_Term( nArg);
         Out_XElEnd( TermName[wsForgetfulFunctorTerm]);
      end

@ \node{Terms: internal forgetful functors.}

\medbreak
{\schema
Term \pipe= element Internal-Forgetful-Functor-Term \LB
\quad attribute nr \LB\ text \RB,
\spelling{\quad}?,
\pos{\quad},
\RB\par}

@<Emit XML for internal forgetful functor (WSM)@>=
         with InternalForgetfulFunctorTermPtr(aTrm)^ do
      begin
         Out_XElStart(TermName[wsInternalForgetfulFunctorTerm]);
         Out_XIntAttr( XMLAttrName[atNr], nStructSymbol);
         Out_PosAsAttrs(nTermPos);
         Out_XElEnd0;
      end

@ \node{Terms: Fraenkel operators.}

\medbreak
{\schema
Term \pipe= element Fraenkel-Term \LB
\pos{\quad},
\quad Variable-Segment*,
\quad Term,
\quad Formula
\RB\par}

@^Fraenkel term@>

@<Emit XML for Fraenkel term (WSM)@>=
         with FraenkelTermPtr(aTrm)^ do
      begin
         Out_XElStart( TermName[wsFraenkelTerm]);
         Out_PosAsAttrs(nTermPos);
         Out_XAttrEnd;
         for i := 0 to nPostqualification^.Count - 1 do
            Out_VariableSegment(nPostqualification^.Items^[i]);
         Out_Term(nSample);
         Out_Formula(nFormula);
         Out_XElEnd( TermName[wsFraenkelTerm]);
      end

@ \node{Terms: Simple Fraenkel expressions.}

\medbreak
{\schema
Term \pipe= element Simple-Fraenkel-Term \LB
\pos{\quad},
\quad Variable-Segment*,
\quad Term
\RB\par}

@<Emit XML for simple Fraenkel term (WSM)@>=
         with SimpleFraenkelTermPtr(aTrm)^ do
      begin
         Out_XElStart( TermName[wsSimpleFraenkelTerm]);
         Out_PosAsAttrs(nTermPos);
         Out_XAttrEnd;
         for i := 0 to nPostqualification^.Count - 1 do
            Out_VariableSegment(nPostqualification^.Items^[i]);
         Out_Term(nSample);
         Out_XElEnd( TermName[wsSimpleFraenkelTerm]);
      end

@ \node{Terms: qualification.}

\medbreak
{\schema
Term \pipe= element Qualification-Term \LB
\pos{\quad},
\quad Term,
\quad Type
\RB\par}

@<Emit XML for qualification term (WSM)@>=
         with QualifiedTermPtr(aTrm)^ do
      begin
         Out_XElStart( TermName[wsQualificationTerm]);
         Out_PosAsAttrs(nTermPos);
         Out_XAttrEnd;
         Out_Term(nSubject);
         Out_Type(nQualification);
         Out_XElEnd( TermName[wsQualificationTerm]);
      end

@ \node{Terms: exactly qualified.}

\medbreak
{\schema
Term \pipe= element Exactly-Qualification-Term \LB
\pos{\quad},
\quad Term
\RB\par}

@<Emit XML for exactly qualification term (WSM)@>=
         with ExactlyTermPtr(aTrm)^ do
      begin
         Out_XElStart( TermName[wsQualificationTerm]);
         Out_PosAsAttrs(nTermPos);
         Out_XAttrEnd;
         Out_Term(nSubject);
         Out_XElEnd( TermName[wsQualificationTerm]);
      end

@ \node{Terms: global choice expressions.}

\medbreak
{\schema
Term \pipe= element Global-Choice-Term \LB
\pos{\quad},
\quad Type
\RB\par}

@^Choice operator@>

@<Emit XML for global choice term (WSM)@>=
         begin
            Out_XElStart(TermName[wsGlobalChoiceTerm]);
            Out_PosAsAttrs(aTrm^.nTermPos);
            Out_XAttrEnd;
            Out_Type(ChoiceTermPtr(aTrm)^.nChoiceType);
            Out_XElEnd(TermName[wsGlobalChoiceTerm]);
         end

@* [s] Emitting XML for text items.
Type-lists are needed for text items.

\medbreak
{\schema
Type-List = element Type-List \LB
\quad Type*
\RB
\par}
@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_TypeList ( aTypeList: PList );
var i: integer;
begin
   Out_XElStart0(XMLElemName[elTypeList]);
   for i:=0 to aTypeList^.Count-1 do
      Out_Type(aTypeList^.Items^[i]);
   Out_XElEnd( XMLElemName[elTypeList]);
end;

@ \node{Locus.}

\medbreak
{\schema
Locus = element Locus \LB
\idnr{\quad},
\spelling{\quad}?,
\pos{\quad}
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Locus( aLocus: LocusPtr);
begin
   with aLocus ^ do
   begin
      Out_XElStart( XMLElemName[elLocus]);
      Out_XIntAttr( XMLAttrName[atIdNr], nVarId);
      if nMizarAppearance then
         Out_XAttr( XMLAttrName[atSpelling], IdentRepr(nVarId));
      Out_PosAsAttrs(nVarIdPos);
      Out_XElEnd0
   end;
end;

@

\medbreak
{\schema
Loci = element Loci \LB\ Locus* \RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Loci( aLoci: PList);
var i: integer;
begin
   if (aLoci = nil) or (aLoci^.Count = 0) then
      Out_XEl1(XMLElemName[elLoci])
   else
   begin
      Out_XElStart0(XMLElemName[elLoci]);
      for i:=0 to aLoci^.Count-1 do
         Out_Locus(aLoci^.Items^[i]);
      Out_XElEnd( XMLElemName[elLoci]);
   end;
end;

@ \node{Patterns.}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Pattern(aPattern: PatternPtr);
begin
   case aPattern^.nPatternSort of
      itDefPred:
         @<Emit XML for predicate pattern (WSM)@>;
      itDefFunc:
         begin
            case FunctorPatternPtr(aPattern)^.nFunctKind of
               InfixFunctor:
                  @<Emit XML for infix functor pattern (WSM)@>;
               CircumfixFunctor:
                  @<Emit XML for bracket functor pattern (WSM)@>;
            endcases;
         end;
      itDefMode:
         @<Emit XML for mode pattern (WSM)@>;
      end;
      itDefAttr:
         @<Emit XML for attribute pattern (WSM)@>;
   endcases;
end;

@

\medbreak
{\schema
Predicate-Pattern = element Predicate-Pattern \LB
\quad attribute nr \LB\ xsd:integer \RB,
\spelling{\quad}?,
\pos{\quad},
\quad Loci,
\quad Loci
\RB
\par}

@<Emit XML for predicate pattern (WSM)@>=
         with PredicatePatternPtr(aPattern)^ do
      begin
         Out_XElStart(DefPatternName[itDefPred]);
         Out_XIntAttr( XMLAttrName[atNr], nPredSymbol );
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], PredicateName[nPredSymbol]);
         Out_PosAsAttrs(nPatternPos);
         Out_XAttrEnd;
         Out_Loci(nLeftArgs);
         Out_Loci(nRightArgs);
         Out_XElEnd( DefPatternName[itDefPred]);
      end

@
\medbreak
{\schema
Operation-Functor-Pattern = element Operation-Functor-Pattern \LB
\quad attribute nr \LB\ xsd:integer \RB,
\spelling{\quad}?,
\pos{\quad},
\quad Loci,
\quad Loci
\RB
\par}

@<Emit XML for infix functor pattern (WSM)@>=
                  with InfixFunctorPatternPtr(aPattern)^ do
               begin
                  Out_XElStart(FunctorPatternName[InfixFunctor]);
                  Out_XIntAttr( XMLAttrName[atNr], nOperSymb);
                  if nMizarAppearance then
                     Out_XAttr( XMLAttrName[atSpelling], FunctorName[nOperSymb]);
                  Out_PosAsAttrs(nPatternPos);
                  Out_XAttrEnd;
                  Out_Loci(nLeftArgs);
                  Out_Loci(nRightArgs);
                  Out_XElEnd( FunctorPatternName[InfixFunctor]);
               end

@

\medbreak
{\schema
Bracket-Functor-Pattern = element Bracket-Functor-Pattern \LB
\quad attribute nr \LB\ xsd:integer \RB,
\spelling{\quad}?,
\pos{\quad},
\quad element Right−Circumflex−Symbol \LB
\qquad attribute nr \LB\ xsd:integer \RB,
\spelling{\qquad }?
\quad \RB,
\quad Loci
\RB
\par}

@<Emit XML for bracket functor pattern (WSM)@>=
                  with CircumfixFunctorPatternPtr(aPattern)^ do
               begin
                  Out_XElStart(FunctorPatternName[CircumfixFunctor]);
                  Out_XIntAttr( XMLAttrName[atNr], nLeftBracketSymb);
                  if nMizarAppearance then
                     Out_XAttr( XMLAttrName[atSpelling], LeftBracketName[nLeftBracketSymb]);
                  Out_PosAsAttrs(nPatternPos);
                  Out_XAttrEnd;
                  Out_XElStart(XMLElemName[elRightCircumflexSymbol]);
                  Out_XIntAttr( XMLAttrName[atNr], nRightBracketSymb);
                  if nMizarAppearance then
                     Out_XAttr( XMLAttrName[atSpelling], RightBracketName[nRightBracketSymb]);
                  Out_XAttrEnd;
                  Out_XElEnd(XMLElemName[elRightCircumflexSymbol]);
                  Out_Loci(nArgs);
                  Out_XElEnd( FunctorPatternName[CircumfixFunctor]);
               end

@

\medbreak
{\schema
Mode-Pattern = element Mode-Pattern \LB
\quad attribute nr \LB\ xsd:integer \RB,
\spelling{\quad}?,
\pos{\quad},
\quad Loci
\RB
\par}

@<Emit XML for mode pattern (WSM)@>=
         with ModePatternPtr(aPattern)^ do
      begin
         Out_XElStart(DefPatternName[itDefMode]);
         Out_XIntAttr( XMLAttrName[atNr], nModeSymbol);
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], ModeName[nModeSymbol]);
         Out_PosAsAttrs(nPatternPos);
         Out_XAttrEnd;
         Out_Loci(nArgs);
         Out_XElEnd(DefPatternName[itDefMode])

@
I am confused why there is both a locus and loci elements in an
attribute pattern.

\medbreak
{\schema
Attribute-Pattern = element Attribute-Pattern \LB
\quad attribute nr \LB\ xsd:integer \RB,
\spelling{\quad}?,
\pos{\quad},
\quad Locus,
\quad Loci
\RB
\par}

@<Emit XML for attribute pattern (WSM)@>=
         with AttributePatternPtr(aPattern)^ do
      begin
         Out_XElStart(DefPatternName[itDefAttr]);
         Out_XIntAttr( XMLAttrName[atNr], nAttrSymbol );
         if nMizarAppearance then
            Out_XAttr( XMLAttrName[atSpelling], AttributeName[nAttrSymbol]);
         Out_PosAsAttrs(nPatternPos);
         Out_XAttrEnd;
         Out_Locus(nArg);
         Out_Loci(nArgs);
         Out_XElEnd( DefPatternName[itDefAttr]);
      end

@

\medbreak
{\schema
Label = element Label \LB
\idnr{\quad},
\spelling{\quad}?,
\pos{\quad},
\quad Locus,
\quad Loci
\RB
\par}
@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Label(aLab:LabelPtr);
begin
   if (aLab <> nil) { |and (aLab.nLabelIdNr > 0)| } then
   begin
      Out_XElStart( XMLElemName[elLabel]);
      Out_XIntAttr( XMLAttrName[atIdNr], aLab^.nLabelIdNr);
      if nMizarAppearance then
         Out_XAttr( XMLAttrName[atSpelling], IdentRepr(aLab^.nLabelIdNr));
      Out_PosAsAttrs(aLab^.nLabelPos);
      Out_XElEnd0
   end;
end;

@ \node{Emitting XML for definiens.}

\medbreak
{\schema
Definiens = element Definiens \LB
\quad attribute kind \LB\ "Simple-Definiens" \RB,
\quad attribute shape \LB\ text \RB?,
\quad Label,
\quad (Term \pipe\ Formula)
\RB\ \pipe\ element Definiens \LB
\quad attribute kind \LB\ "Conditional-Definiens" \RB,
\quad attribute shape \LB\ text \RB?,
\quad Label,
\quad element Partial-Definiens \LB\ (Term \pipe\ Formula)* \RB,
\quad (Term \pipe\ Formula)?
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Definiens(aDef:DefiniensPtr);
var i: integer;
lExprKind: ExpKind;
begin
   if aDef <> nil then
      with DefiniensPtr(aDef)^ do
   begin
      Out_XElStart( XMLElemName[elDefiniens]);
      Out_PosAsAttrs(nDefPos);
      case nDefSort of
         SimpleDefiniens:
            with SimpleDefiniensPtr(aDef)^,nExpression^ do
         begin
            Out_XAttr( XMLAttrName[atKind],DefiniensKindName[SimpleDefiniens]);
            Out_XAttr( XMLAttrName[atShape],ExpName[nExprKind]);
            Out_XAttrEnd;
            Out_Label(nDefLabel);
            case nExprKind of
               exTerm: Out_Term(TermPtr(nExpr));
               exFormula: Out_Formula(FormulaPtr(nExpr));
            endcases;
         end;
         
         ConditionalDefiniens:
            with ConditionalDefiniensPtr(aDef)^ do
         begin
            Out_XAttr( XMLAttrName[atKind],DefiniensKindName[ConditionalDefiniens]);
            lExprKind:=exFormula;
            if nOtherwise <> nil then
               lExprKind:=nOtherwise^.nExprKind
            else if nConditionalDefiniensList^.Count > 0 then
               lExprKind:=PartDefPtr(nConditionalDefiniensList^.Items^[0])^.nPartDefiniens^.nExprKind;
            Out_XAttr( XMLAttrName[atShape],ExpName[lExprKind]);
            Out_XAttrEnd;
            Out_Label(nDefLabel);
            for i:=0 to nConditionalDefiniensList^.Count-1 do
               with PartDefPtr(nConditionalDefiniensList^.Items^[I])^ do
            begin
               Out_XElStart0(XMLElemName[elPartialDefiniens]);
               with nPartDefiniens^ do
                  case nExprKind of
                     exTerm: Out_Term(TermPtr(nExpr));
                     exFormula: Out_Formula(FormulaPtr(nExpr));
                  endcases;
               Out_Formula(nGuard);
               Out_XElEnd(XMLElemName[elPartialDefiniens]);
            end;
            if nOtherwise <> nil then
               with nOtherwise^ do
                  case nExprKind of
                     exTerm: Out_Term(TermPtr(nExpr));
                     exFormula: Out_Formula(FormulaPtr(nExpr));
                  endcases;
         end;
      endcases;
      Out_XElEnd( XMLElemName[elDefiniens]);
   end;
end;

@

\medbreak
{\schema
Proposition = element Proposition \LB
\quad Label,
\quad Formula
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Proposition(aProp:PropositionPtr);
begin
   Out_XElStart(XMLElemName[elProposition]);
   Out_XAttrEnd;
   Out_Label(aProp^.nLab);
   Out_Formula(aProp^.nSentence);
   Out_XElEnd( XMLElemName[elProposition]);
end;

@

\medbreak
{\schema
Local-Reference = element Local-Reference \LB
\pos{\quad},
\idnr{\quad},
\spelling{\quad}?
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_LocalReference(aRef: LocalReferencePtr);
begin
   with LocalReferencePtr(aRef)^ do
   begin
      Out_XElStart(ReferenceKindName[LocalReference]);
      Out_PosAsAttrs(nRefPos);
      Out_XIntAttr( XMLAttrName[atIdNr], nLabId);
      if nMizarAppearance then
         Out_XAttr( XMLAttrName[atSpelling], IdentRepr(nLabId));
      Out_XElEnd0;
   end;
end;
@

\medbreak
{\schema
References = (Local-Reference
\quad\pipe\ element Theorem-Reference \LB
\pos{\qquad},
\qquad attribute at \LB\ xsd:integer \RB,
\spelling{\qquad}?,
\qquad attribute nr \LB\ xsd:integer \RB
\RB\ \pipe\ element Definition-Reference \LB
\pos{\qquad},
\qquad attribute at \LB\ xsd:integer \RB,
\spelling{\qquad}?,
\qquad attribute nr \LB\ xsd:integer \RB
\RB)*
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_References(aRefs: PList);
var i: integer;
begin
   for i:= 0 to aRefs^.Count-1 do
      with ReferencePtr(aRefs^.Items^[i])^ do
         case nRefSort of
            LocalReference:
               Out_LocalReference(aRefs^.Items^[i]);
            TheoremReference:
               begin
                  Out_XElStart(ReferenceKindName[TheoremReference]);
                  Out_PosAsAttrs(nRefPos);
                  Out_XIntAttr( XMLAttrName[atNr], TheoremReferencePtr(aRefs^.Items^[i])^.nArticleNr);
                  if nMizarAppearance then
                     Out_XAttr( XMLAttrName[atSpelling], MMLIdentifierName[TheoremReferencePtr(aRefs^.Items^[i])^.nArticleNr]);
                  Out_XIntAttr( XMLAttrName[atNumber], TheoremReferencePtr(aRefs^.Items^[i])^.nTheoNr);
                  Out_XElEnd0;
               end;
            DefinitionReference:
               begin
                  Out_XElStart(ReferenceKindName[DefinitionReference]);
                  Out_PosAsAttrs(nRefPos);
                  Out_XIntAttr( XMLAttrName[atNr], DefinitionReferencePtr(aRefs^.Items^[i])^.nArticleNr);
                  if nMizarAppearance then
                     Out_XAttr( XMLAttrName[atSpelling], MMLIdentifierName[TheoremReferencePtr(aRefs^.Items^[i])^.nArticleNr]);
                  Out_XIntAttr( XMLAttrName[atNumber], DefinitionReferencePtr(aRefs^.Items^[i])^.nDefNr);
                  Out_XElEnd0;
               end;
         endcases;
end;

@

\medbreak
{\schema
Link = element Link \LB
\pos{\quad}
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Link(aInf: JustificationPtr);
begin
   with StraightforwardJustificationPtr(aInf)^ do
      if nLinked then
      begin
         Out_XElStart(XMLElemName[elLink]);
         Out_PosAsAttrs(nLinkPos);
         Out_XElEnd0;
      end;
end;
@

\medbreak
{\schema
Scheme-Justification = element Scheme-Justification \LB
\quad attribute nr \LB\ xsd:integer \RB,
\idnr{\quad},
\spelling{\quad}?,
\pos{\quad},
\quad attribute poscol \LB\ xsd:integer \RB,
\quad attribute posline \LB\ xsd:integer \RB,
\quad References
\RB\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_SchemeJustification(aInf: SchemeJustificationPtr);
begin
   with aInf^ do
   begin
      Out_XElStart(InferenceName[infSchemeJustification]);
      Out_XIntAttr( XMLAttrName[atNr],nSchFileNr);
      Out_XIntAttr( XMLAttrName[atIdNr],nSchemeIdNr);
      if nMizarAppearance then
         if nSchFileNr > 0 then
            Out_XAttr( XMLAttrName[atSpelling], MMLIdentifierName[nSchFileNr])
         else if nSchemeIdNr > 0 then
            Out_XAttr( XMLAttrName[atSpelling], IdentRepr(nSchemeIdNr));
      Out_PosAsAttrs(nInfPos);
      Out_XIntAttr( XMLAttrName[atPosLine], nSchemeInfPos.Line);
      Out_XIntAttr( XMLAttrName[atPosCol], nSchemeInfPos.Col);
      Out_XAttrEnd;
      Out_References(nReferences);
      Out_XElEnd(InferenceName[infSchemeJustification]);
   end;
end;

@

\medbreak
{\schema
Justification =
(\ element Straightforward-Justification \LB
\pos{\qquad},
\qquad(Link, References)?
\quad\RB
\pipe\ Scheme-Justification
\pipe\ element Inference-Error \LB
\pos\qquad
\quad\RB
\pipe\ element Skipped-Proof \LB
\pos\qquad
\quad\RB
\pipe\ Block \# {\rm proof block}
)\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Justification(aInf: JustificationPtr; aBlock:wsBlockPtr);
begin
   case aInf^.nInfSort of
      infStraightforwardJustification:
         with StraightforwardJustificationPtr(aInf)^ do
      begin
         Out_XElStart(InferenceName[infStraightforwardJustification]);
         Out_PosAsAttrs(nInfPos);
         if not nLinked and (nReferences^.Count=0) then
            Out_XElEnd0
         else
         begin
            Out_XAttrEnd;
            Out_Link(aInf);
            Out_References(nReferences);
            Out_XElEnd(InferenceName[infStraightforwardJustification]);
         end;
      end;
      infSchemeJustification:
         Out_SchemeJustification(SchemeJustificationPtr(aInf));
      infError:
         Out_XElWithPos(InferenceName[infError],aInf^.nInfPos);
      infSkippedProof:
         Out_XElWithPos(InferenceName[infSkippedProof],aInf^.nInfPos);
      infProof:
         Out_Block(aBlock);
   endcases;
end;
@

\medbreak
{\schema
Compact-Statement = (Proposition, Justification)
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_CompactStatement(aCStm:CompactStatementPtr; aBlock:wsBlockPtr);
begin
   with aCStm^ do
   begin
      Out_Proposition(nProp);
      Out_Justification(nJustification,aBlock);
   end;
end;

@

\medbreak
{\schema
Regular-Statement =
( (Label, Block)
\pipe\ Compact-Statement
\pipe\ (Compact-Statement,
\quad\ element Iterative-Step \LB
\pos{\qquad\ },
\qquad\ Term,
\qquad\ Justification
\quad\ \RB)*
)\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_RegularStatement(aRStm:RegularStatementPtr; aBlock:wsBlockPtr);
var i: integer;
begin
   case aRStm^.nStatementSort of
      stDiffuseStatement:
         begin
            Out_Label(DiffuseStatementPtr(aRStm)^.nLab);
            Out_Block(aBlock);
         end;
      stCompactStatement:
         Out_CompactStatement(CompactStatementPtr(aRStm),aBlock);
      stIterativeEquality:
         begin
            Out_CompactStatement(CompactStatementPtr(aRStm),nil);
            with IterativeEqualityPtr(aRStm)^ do
               for i := 0 to nIterSteps^.Count - 1 do
                  with IterativeStepPtr(nIterSteps^.Items^[i])^ do
               begin
                  Out_XElStart(XMLElemName[elIterativeStep]);
                  Out_PosAsAttrs(nIterPos);
                  Out_XAttrEnd;
                  Out_Term(nTerm);
                  Out_Justification(nJustification,nil);
                  Out_XElEnd(XMLElemName[elIterativeStep]);
               end;
         end;
   endcases;
end;

@

\medbreak
{\schema
Variables = element Variables \LB
\quad Variable*
\RB
\par}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_ReservationSegment(aRes:ReservationSegmentPtr);
var i: integer;
begin
   with aRes^ do
   begin
      Out_XElStart0( XMLElemName[elVariables]);
      for i:=0 to nIdentifiers^.Count-1 do
         Out_ReservedVariable( nIdentifiers^.Items^[i]);
      Out_XElEnd( XMLElemName[elVariables]);
      Out_Type(nResType);
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_SchemeNameInSchemeHead(aSch: SchemePtr);
begin
   Out_XIntAttr( XMLAttrName[atIdNr], aSch^.nSchemeIdNr);
   if nMizarAppearance then
      Out_XAttr( XMLAttrName[atSpelling], IdentRepr(aSch^.nSchemeIdNr));
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_ItemContentsAttr(aWSItem:WSItemPtr);
begin
   with aWSItem^ do
   begin
      CurPos:=nItemPos;
      if nDisplayInformationOnScreen then
         DisplayLine(CurPos.Line,ErrorNbr);
      case nItemKind of
         itDefinition, itSchemeBlock, itSchemeHead, itTheorem, itAxiom,
         itReservation:;
         itSection:;
         itConclusion,
         itRegularStatement:
            case RegularStatementPtr(nContent)^.nStatementSort of
               stDiffuseStatement:
                  Out_XAttr( XMLAttrName[atShape], RegularStatementName[stDiffuseStatement]);
               stCompactStatement:
                  Out_XAttr( XMLAttrName[atShape], RegularStatementName[stCompactStatement]);
               stIterativeEquality:
                  Out_XAttr( XMLAttrName[atShape], RegularStatementName[stIterativeEquality]);
            endcases;
         itChoice, itReconsider,
         itPrivFuncDefinition, itPrivPredDefinition, itConstantDefinition,
         itGeneralization, itLociDeclaration,itExistentialAssumption, itExemplification,
         itPerCases, itCaseBlock:;
         itCaseHead, itSupposeHead,
         itAssumption:;
         itCorrCond:
            Out_XAttr( XMLAttrName[atCondition],
                       CorrectnessName[CorrectnessConditionPtr(nContent)^.nCorrCondSort]);
         itCorrectness:
            Out_XAttr( XMLAttrName[atCondition],CorrectnessName[syCorrectness]);
         itProperty:
            Out_XAttr( XMLAttrName[atProperty],PropertyName[PropertyPtr(nContent)^.nPropertySort]);
         itDefFunc:
            Out_XAttr( XMLAttrName[atShape],DefiningWayName[FunctorDefinitionPtr(nContent)^.nDefiningWay]);
         itDefPred, itDefMode, itDefAttr,
         itDefStruct,
         itPredSynonym, itPredAntonym, itFuncNotation, itModeNotation,
         itAttrSynonym, itAttrAntonym,
         itCluster,
         itIdentify, itReduction:;
         itPropertyRegistration:
            Out_XAttr( XMLAttrName[atProperty],PropertyName[PropertyPtr(nContent)^.nPropertySort]);
         itPragma:
            Out_XAttr( XMLAttrName[atSpelling],QuoteStrForXML(PragmaPtr(nContent)^.nPragmaStr));
      endcases;
   end;
end;

@ \node{Emitting XML for item contents.} This is used to expedite
emitting the \XML/ for a text-item (\section\xref{OutWSMizFileObj.Out_Item}).

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_ItemContents(aWSItem:WSItemPtr);
var i,j: integer;
s: CorrectnessKind;
begin
   with aWSItem^ do
   begin
      case nItemKind of
         itDefinition:
            Out_Block(nBlock);
         itSchemeBlock:
            Out_Block(nBlock);
         itSchemeHead:
            @<Emit XML for schema (WSM)@>;
         itTheorem:
            Out_CompactStatement(CompactStatementPtr(nContent),nBlock);
         itAxiom:
            begin

            end;
         itReservation:
            Out_ReservationSegment(ReservationSegmentPtr(nContent));
         itSection:;
         itConclusion,
         itRegularStatement:
            Out_RegularStatement(RegularStatementPtr(nContent),nBlock);
         itChoice:
            @<Emit XML for \texttt{consider} contents (WSM)@>;
         itReconsider:
            @<Emit XML for \texttt{reconsider} contents (WSM)@>; @#
@t\4@>         @<Emit XML for definition-related items (WSM)@>; @#
         itPredSynonym, itPredAntonym, itFuncNotation, itModeNotation,
         itAttrSynonym, itAttrAntonym:
            with NotationDeclarationPtr(nContent)^ do
         begin
            Out_Pattern(nOriginPattern);
            Out_Pattern(nNewPattern);
         end;
@t\4@>         @<Emit XML for registration-related items (WSM)@>; @#
         itPragma: ;
         itIncorrItem:;
      end;
   endcases;
end;

@

\medbreak
{\schema
Item-contents \pipe= Scheme-contents
Scheme-contents = element Scheme \LB
\idnr{\quad},
\spelling{\quad}?,
\quad element Schematic-Variables \LB
\qquad\llap{(}element Predicate-Segment \LB
\pos{\qquad\quad},
\qquad\quad element Variables \LB\ Variable* \RB,
\qquad\quad Type
\qquad\RB\ \pipe\ element Functor-Segment \LB
\pos{\qquad\quad},
\qquad\quad element Variables \LB\ Variable* \RB,
\qquad\quad Type-List,
\qquad\quad element Type-Specification \LB\ Type \RB
\qquad\RB)*
\quad \RB,
\quad Formula,
\quad element Provisional-Formulas \LB\ Proposition* \RB?
\RB
\par}

@<Emit XML for schema (WSM)@>=
            with SchemePtr(nContent)^ do
         begin
            Out_XElStart( XMLElemName[elScheme]);
            Out_SchemeNameInSchemeHead(SchemePtr(nContent));
            Out_XElEnd0;
            Out_XElStart0(XMLElemName[elSchematicVariables]);
            for j:=0 to nSchemeParams^.Count-1 do
               case SchemeSegmentPtr(nSchemeParams.Items^[j])^.nSegmSort of
                  PredicateSegment:
                     with PredicateSegmentPtr(nSchemeParams.Items^[j])^ do
                  begin
                     Out_XElStart( SchemeSegmentName[PredicateSegment]);
                     Out_PosAsAttrs(nSegmPos);
                     Out_XAttrEnd;
                     Out_XElStart0( XMLElemName[elVariables]);
                     for i:=0 to nVars^.Count-1 do
                        Out_Variable( nVars.Items^[i]);
                     Out_XElEnd( XMLElemName[elVariables]);
                     Out_TypeList(nTypeExpList);
                     Out_XElEnd( SchemeSegmentName[PredicateSegment]);
                  end;
                  FunctorSegment:
                     with FunctorSegmentPtr(nSchemeParams.Items^[j])^ do
                  begin
                     Out_XElStart( SchemeSegmentName[FunctorSegment]);
                     Out_PosAsAttrs(nSegmPos);
                     Out_XAttrEnd;
                     Out_XElStart0( XMLElemName[elVariables]);
                     for i:=0 to nVars^.Count-1 do
                        Out_Variable( nVars.Items^[i]);
                     Out_XElEnd( XMLElemName[elVariables]);
                     Out_TypeList(nTypeExpList);
                     Out_XElStart0( XMLElemName[elTypeSpecification]);
                     Out_Type(nSpecification);
                     Out_XElEnd( XMLElemName[elTypeSpecification]);
                     Out_XElEnd( SchemeSegmentName[FunctorSegment]);
                  end;
               endcases;
            Out_XElEnd( XMLElemName[elSchematicVariables]);
            Out_Formula(nSchemeConclusion);
            if (nSchemePremises <> nil) and (nSchemePremises^.Count > 0) then
            begin
               Out_XElStart0( XMLElemName[elProvisionalFormulas]);
               for i:=0 to nSchemePremises^.Count-1 do
                  Out_Proposition(nSchemePremises^.Items^[i]);
               Out_XElEnd( XMLElemName[elProvisionalFormulas]);
            end;
         end

@

\medbreak
{\schema
Item-contents \pipe= Consider-Statement-contents
Consider-Statement-contents =
\quad\llap{(\ }Variable-Segment*,
\quad element Conditions \LB\ Proposition \RB,
\quad Justification
)\par}

@<Emit XML for \texttt{consider} contents (WSM)@>=
            with ChoiceStatementPtr(nContent)^ do
         begin
            for i:= 0 to  nQualVars^.Count-1 do
               Out_VariableSegment( nQualVars^.Items^[i]);
            Out_XElStart0( XMLElemName[elConditions]);
            for i:=0 to nConditions^.Count-1 do
               Out_Proposition(nConditions^.Items^[i]);
            Out_XElEnd( XMLElemName[elConditions]);
            Out_Justification(nJustification,nil);
         end

@
\medbreak
{\schema
Item-contents \pipe= Type-Changing-Statement-contents
Type-Changing-Statement-contents =
((element Equality \LB
\qquad Variable,
\qquad Term
\quad\RB\ \pipe\ Variable),
\ Type)
\par}

@<Emit XML for \texttt{reconsider} contents (WSM)@>=
            with TypeChangingStatementPtr(nContent)^ do
         begin
            for i:=0 to nTypeChangeList^.Count-1 do
               case TypeChangePtr(nTypeChangeList.Items^[i])^.nTypeChangeKind of
                  Equating:
                     begin
                        Out_XElStart0( XMLElemName[elEquality]);
                        Out_Variable(TypeChangePtr(nTypeChangeList.Items^[i])^.nVar);
                        Out_Term(TypeChangePtr(nTypeChangeList.Items^[i])^.nTermExpr);
                        Out_XElEnd( XMLElemName[elEquality]);
                     end;
                  VariableIdentifier:
                     begin
                        Out_Variable(TypeChangePtr(nTypeChangeList.Items^[i])^.nVar);
                     end;
               endcases;
            Out_Type(nTypeExpr);
            Out_Justification(nJustification,nil);
         end

@
We will need to recall \\{Out\_Variable} (\section\xref{OutWSMizFileObj.Out_Variable})
fr \\{PrivateFunctorDefinitionObj} (\section\xref{PrivateFunctorDefinitionObj}).

\medbreak
{\schema
Item-contents \pipe=
\quad (Variable, Type-List, Term) \# {\rm private functors and predicates}
\pipe\ (Variable, Term) \hphantom{st, Terms } \# {\rm constants}
\pipe\ Variable-Segment \hphantom{st, Terms } \# {\rm loci}
\par}

@<Emit XML for definition-related items (WSM)@>=
         itPrivFuncDefinition:
            with PrivateFunctorDefinitionPtr(nContent)^ do
         begin
            Out_Variable(nFuncId);
            Out_TypeList(nTypeExpList);
            Out_Term(nTermExpr);
         end;
         itPrivPredDefinition:
            with PrivatePredicateDefinitionPtr(nContent)^ do
         begin
            Out_Variable(nPredId);
            Out_TypeList(nTypeExpList);
            Out_Formula(nSentence);
         end;
         itConstantDefinition:
            with ConstantDefinitionPtr(nContent)^ do
         begin
            Out_Variable(nVarId);
            Out_Term(nTermExpr);
         end;
         itLociDeclaration,
         itGeneralization:
            Out_VariableSegment( QualifiedSegmentPtr(nContent));
         itCaseHead,itSupposeHead,
         itAssumption:
            @<Emit XML for assumptions item (WSM)@>;
@

\medbreak
{\schema
Item-contents \pipe=
( Variable-Segment*,
\quad element Conditions \LB\ Proposition* \RB\ )
\par}

@<Emit XML for definition-related items (WSM)@>=
         itExistentialAssumption:
            with ExistentialAssumptionPtr(nContent)^ do
         begin
            for i:= 0 to  nQVars^.Count-1 do
               Out_VariableSegment( nQVars^.Items^[i]);
            Out_XElStart0( XMLElemName[elConditions]);
            for i:=0 to nConditions^.Count-1 do
               Out_Proposition(nConditions^.Items^[i]);
            Out_XElEnd( XMLElemName[elConditions]);
         end;
@

\medbreak
{\schema
Item-contents \pipe= (\ Variable?, Term? ) \# {\rm Exemplification}
\qquad\qquad\qquad\qquad\pipe\ Justification\quad\qquad\ \# \rlap{\rm per cases,\ correctness-condition}
\qquad\qquad\qquad\qquad\pipe\ Block\qquad\qquad\qquad\quad\ \# \rlap{\rm case\ block}
\par}

@<Emit XML for definition-related items (WSM)@>=
         itExemplification:
            with ExamplePtr(nContent)^ do
         begin
            if nVarId <> nil then
               Out_Variable(nVarId);
            if nTermExpr <> nil then
               Out_Term(nTermExpr);
         end;
         itPerCases:
            Out_Justification(JustificationPtr(nContent),nil);
         itCaseBlock:
            Out_Block(nBlock);
         itCorrCond:
            Out_Justification(CorrectnessConditionPtr(nContent)^.nJustification,nBlock);
@

\medbreak
{\schema
Item-contents \pipe=
\quad element CorrectnessConditions \LB\ \# {\rm sic!}
\qquad element Correctness \LB\ attribute condition \LB\ text \RB\ \RB*,
\qquad\quad Justification \RB
\pipe Justification \# {\rm Property}
\par}

@<Emit XML for definition-related items (WSM)@>=
         itCorrectness:
            begin
               Out_XElStart0( XMLElemName[elCorrectnessConditions]);
               for s in CorrectnessConditionsPtr(nContent)^.nConditions do
               begin
                  Out_XElStart(ItemName[itCorrectness]);
                  Out_XAttr( XMLAttrName[atCondition],CorrectnessName[s]);
                  Out_XElEnd0;
               end;
               Out_XElEnd( XMLElemName[elCorrectnessConditions]);
               Out_Justification(CorrectnessPtr(nContent)^.nJustification,nBlock);
            end;
         itProperty:
            Out_Justification(PropertyPtr(nContent)^.nJustification,nBlock);
@

\medbreak
{\schema
Item-contents \pipe=
(\ element Redefine \LB\ \RB?,
\quad Pattern,
\quad element Standard-Mode \LB\ Type \RB,
\quad \pipe\ element Expandable-Mode \LB
\qquad\quad element Type-Specification \LB\ Type \RB?,
\qquad\quad Definiens
\qquad \RB)
\par}

@<Emit XML for definition-related items (WSM)@>=
         itDefMode:
            with ModeDefinitionPtr(nContent)^ do
         begin
            if nRedefinition then
               Out_XEl1(XMLElemName[elRedefine]);
            Out_Pattern(nDefModePattern);
            case nDefKind of
               defExpandableMode:
                  begin
                     Out_XElStart0( ModeDefinitionSortName[defExpandableMode]);
                     Out_Type(ExpandableModeDefinitionPtr(nContent)^.nExpansion);
                     Out_XElEnd( ModeDefinitionSortName[defExpandableMode]);
                  end;
               defStandardMode:
                  with StandardModeDefinitionPtr(nContent)^ do
               begin
                  Out_XElStart0( ModeDefinitionSortName[defStandardMode]);
                  if nSpecification <> nil then
                  begin
                     Out_XElStart0( XMLElemName[elTypeSpecification]);
                     Out_Type(nSpecification);
                     Out_XElEnd( XMLElemName[elTypeSpecification]);
                  end;
                  Out_Definiens(nDefiniens);
                  Out_XElEnd( ModeDefinitionSortName[defStandardMode]);
               end;
            endcases;
         end;
@

\medbreak
{\schema
Item-contents \pipe=
(element Redefine \LB\ \RB?,
\ Pattern,
\ Definiens)
\par}

@<Emit XML for definition-related items (WSM)@>=
         itDefAttr:
            with AttributeDefinitionPtr(nContent)^ do
         begin
            if nRedefinition then
               Out_XEl1(XMLElemName[elRedefine]);
            Out_Pattern(nDefAttrPattern);
            Out_Definiens(nDefiniens);
         end;
         itDefPred:
            with PredicateDefinitionPtr(nContent)^ do
         begin
            if nRedefinition then
               Out_XEl1(XMLElemName[elRedefine]);
            Out_Pattern(nDefPredPattern);
            Out_Definiens(nDefiniens);
         end;
@

\medbreak
{\schema
Item-contents \pipe=
(element Redefine \LB\ \RB?,
 Pattern,
 element Type-Specification \LB\ Type \RB?,
 Definiens)
\par}

@<Emit XML for definition-related items (WSM)@>=
         itDefFunc:
            with FunctorDefinitionPtr(nContent)^ do
         begin
            if nRedefinition then
               Out_XEl1(XMLElemName[elRedefine]);
            Out_Pattern(nDefFuncPattern);
            if nSpecification <> nil then
            begin
               Out_XElStart0( XMLElemName[elTypeSpecification]);
               Out_Type(nSpecification);
               Out_XElEnd( XMLElemName[elTypeSpecification]);
            end;
            Out_Definiens(nDefiniens);
         end;
@

\medbreak
{\schema
Item-contents \pipe=
(element Ancestors \LB\ Type* \RB,
\quad\ attribute nr \LB\ xsd:integer \RB,
\spelling{\quad\ }?,
\pos{\quad\ },
\quad\ Loci,
\quad\ (element Field-Segment \LB
\pos{\quad\qquad},
\qquad\quad(element Selector \LB
\qquad\qquad attribute nr \LB\ xsd:integer \RB,
\spelling{\qquad\qquad}?,
\pos{\qquad\qquad}
\quad\qquad \RB)*,
\qquad\quad Type
\quad\ )*
\ \RB,

\par}

@<Emit XML for definition-related items (WSM)@>=
         itDefStruct:
            with StructureDefinitionPtr(nContent)^ do
         begin
            Out_XElStart0( XMLElemName[elAncestors]);
            for i := 0 to nAncestors^.Count - 1 do
               Out_Type(nAncestors^.Items^[i]);
            Out_XElEnd( XMLElemName[elAncestors]);
            Out_XElStart(DefPatternName[itDefStruct]);
            Out_XIntAttr( XMLAttrName[atNr],nDefStructPattern^.nModeSymbol);
            if nMizarAppearance then
               Out_XAttr( XMLAttrName[atSpelling], StructureName[nDefStructPattern^.nModeSymbol]);
            Out_PosAsAttrs(nStrPos);
            Out_XAttrEnd;
            Out_Loci(nDefStructPattern^.nArgs);
            for i := 0 to nSgmFields^.Count - 1 do
               with FieldSegmentPtr(nSgmFields^.Items^[i])^ do
            begin
               Out_XElStart(XMLElemName[elFieldSegment]);
               Out_PosAsAttrs(nFieldSegmPos);
               Out_XAttrEnd;
               for j := 0 to nFields^.Count - 1 do
                  with FieldSymbolPtr(nFields^.Items^[j])^ do
               begin
                  Out_XElStart( XMLElemName[elSelector]);
                  Out_XIntAttr( XMLAttrName[atNr], nFieldSymbol);
                  if nMizarAppearance then
                     Out_XAttr( XMLAttrName[atSpelling], SelectorName[nFieldSymbol]);
                  Out_PosAsAttrs(nFieldPos);
                  Out_XElEnd0
               end;
               Out_Type(nSpecification);
               Out_XElEnd(XMLElemName[elFieldSegment]);
            end;
            Out_XElEnd( DefPatternName[itDefStruct]);
         end

@

\medbreak
{\schema
Item-contents \pipe= (element Single-Assumption \LB
\pos{\quad},
\quad Proposition
\RB\ \pipe\ element Collective-Assumption \LB
\pos{\quad},
\quad element Conditions \LB\ Proposition* \RB
\RB)\par}

@<Emit XML for assumptions item (WSM)@>=
            case AssumptionPtr(nContent)^.nAssumptionSort of
               SingleAssumption:
                  begin
                     Out_XElStart( AssumptionKindName[SingleAssumption]);
                     Out_PosAsAttrs(AssumptionPtr(nContent)^.nAssumptionPos);
                     Out_XAttrEnd;
                     Out_Proposition(SingleAssumptionPtr(nContent)^.nProp);
                     Out_XElEnd( AssumptionKindName[SingleAssumption]);
                  end;
               CollectiveAssumption:
                  begin
                     Out_XElStart( AssumptionKindName[CollectiveAssumption]);
                     Out_PosAsAttrs(AssumptionPtr(nContent)^.nAssumptionPos);
                     Out_XAttrEnd;
                     Out_XElStart0( XMLElemName[elConditions]);
                     with CollectiveAssumptionPtr(nContent)^ do
                        for i:=0 to nConditions^.Count-1 do
                           Out_Proposition(nConditions^.Items^[i]);
                     Out_XElEnd( XMLElemName[elConditions]);
                     Out_XElEnd( AssumptionKindName[CollectiveAssumption]);
                  end;
            endcases

@ We have cluster registrations and non-cluster registrations.

\medbreak
{\schema
Existential-Registration-content = element Existential-Registration \LB
\pos{\quad},
\quad Adjective-Cluster,
\quad Type
\RB
Conditional-Registration-content = element Conditional-Registration \LB
\pos{\quad},
\quad Adjective-Cluster, Adjective-Cluster,
\quad Type
\RB
Functorial-Registration-content = element Functorial-Registration \LB
\pos{\quad},
\quad Term,
\quad Adjective-Cluster,
\quad Type?
\RB
\par}

@<Emit XML for registration-related items (WSM)@>=
         itCluster:
            case ClusterPtr(nContent)^.nClusterKind of
               ExistentialRegistration :
                  with EClusterPtr(nContent)^ do
               begin
                  Out_XElStart( ClusterRegistrationName[ExistentialRegistration]);
                  Out_PosAsAttrs(nClusterPos);
                  Out_XAttrEnd;
                  Out_AdjectiveList(nConsequent);
                  Out_Type(nClusterType);
                  Out_XElEnd(ClusterRegistrationName[ExistentialRegistration]);
               end;
               ConditionalRegistration :
                  with CClusterPtr(nContent)^ do
               begin
                  Out_XElStart( ClusterRegistrationName[ConditionalRegistration]);
                  Out_PosAsAttrs(nClusterPos);
                  Out_XAttrEnd;
                  Out_AdjectiveList(nAntecedent);
                  Out_AdjectiveList(nConsequent);
                  Out_Type(nClusterType);
                  Out_XElEnd(ClusterRegistrationName[ConditionalRegistration]);
               end;
               FunctorialRegistration:
                  with FClusterPtr(nContent)^ do
               begin
                  Out_XElStart( ClusterRegistrationName[FunctorialRegistration]);
                  Out_PosAsAttrs(nClusterPos);
                  Out_XAttrEnd;
                  Out_Term(nClusterTerm);
                  Out_AdjectiveList(nConsequent);
                  if nClusterType <> nil then
                     Out_Type(nClusterType);
                  Out_XElEnd(ClusterRegistrationName[FunctorialRegistration]);
               end;
            endcases;
@

\medbreak
{\schema
Identify-Registration-content =
(Pattern, Pattern,
\quad  element LociEquality \LB
\pos{\qquad\quad},
\quad\qquad Locus, Locus
\quad\quad\RB*
\quad\RB)
Sethood-Registration-content = (Type, Justification)
Reduction-Registration-content = (Term, Term)
\par}

@<Emit XML for registration-related items (WSM)@>=
         itIdentify:
            with IdentifyRegistrationPtr(nContent)^ do
         begin
            Out_Pattern(nOriginPattern);
            Out_Pattern(nNewPattern);
            if nEqLociList <> nil then
            begin
               for i := 0 to nEqLociList^.Count - 1 do
                  with LociEqualityPtr(nEqLociList^.Items^[i])^ do
               begin
                  Out_XElStart(XMLElemName[elLociEquality]);
                  Out_PosAsAttrs(nEqPos);
                  Out_XAttrEnd;
                  Out_Locus(nLeftLocus);
                  Out_Locus(nRightLocus);
                  Out_XElEnd(XMLElemName[elLociEquality]);
               end;
            end;
         end;
         itPropertyRegistration:
            case PropertyRegistrationPtr(nContent)^.nPropertySort of
               sySethood:
                  with SethoodRegistrationPtr(nContent)^ do
               begin
                  Out_Type(nSethoodType);
                  Out_Justification(nJustification,nBlock);
               end;
            endcases;
         itReduction:
            with ReduceRegistrationPtr(nContent)^ do
         begin
            Out_Term(nOriginTerm);
            Out_Term(nNewTerm);
         end

@ \node{Emitting an item.}

\medbreak
{\schema
Item = element Item \LB
\quad attribute kind \LB\ text \RB,
\quad Item-contents-attribute?,
\pos{\quad},
\quad attribute posline \LB\ xsd:integer \RB,
\quad attribute poscol \LB\ xsd:integer \RB,
\quad (Block \pipe\ Item-contents)?
\RB
\par}

\label{OutWSMizFileObj.Out_Item}

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure OutWSMizFileObj.Out_Item(aWSItem:WSItemPtr);
var i,j: integer;
begin
   with aWSItem^ do
   begin
      CurPos:=nItemPos;
      Out_XElStart(XMLElemName[elItem]);
      Out_XAttr( XMLAttrName[atKind], ItemName[nItemKind]);
      if nContent <> nil then
         Out_ItemContentsAttr(aWsItem);
      Out_PosAsAttrs(nItemPos);
      Out_XIntAttr( XMLAttrName[atPosLine], nItemEndPos.Line);
      Out_XIntAttr( XMLAttrName[atPosCol], nItemEndPos.Col);
      Out_XAttrEnd;
      if nContent = nil then
      begin
         if nBlock <> nil then
            Out_Block(nBlock);
      end
      else Out_ItemContents(aWsItem);
      Out_XElEnd( XMLElemName[elItem]);
   end;
end;

@ \node{Writing out to an XML file.}

@p
procedure Write_WSMizArticle(aWSTextProper:wsTextProperPtr; aFileName:string);
var lWSMizOutput: OutWSMizFilePtr;
begin
   InitScannerNames;
   lWSMizOutput:=new(OutWSMizFilePtr,OpenFile(aFileName));
   lWSMizOutput^.nMizarAppearance:=true;
   lWSMizOutput^.Out_TextProper(aWSTextProper);
   dispose(lWSMizOutput,Done);
end;

@* [S] Reading WSM files (deferred).
Reading a WSM file amounts to reading an \XML/ file, which means that
the \\{XMLInStream} class (\section\xref{XMLInStreamObj}) is a natural
parent class. Recall, the state of the \\{XMLInStream} contains the
current start tag and a dictionary for the attributes and their
values.

The code is a ``mirror image'' to writing \XML/ files, and the \XML/
schema guides the implementation.

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
   InWSMizFilePtr = ^InWSMizFileObj; @/
   InWSMizFileObj =
      object(XMLInStreamObj) @t\1 @> @/
         nDisplayInformationOnScreen: boolean; @/

         constructor OpenFile(const aFileName:string ); @t\2 @>
         destructor Done; virtual; @t\2 @>

         function GetAttrValue(const aAttrName:string): string; @t\2 @>
         function GetAttrPos: Position; @t\2 @>

         function Read_TextProper: wsTextProperPtr; virtual; @t\2 @>
         function Read_Block: wsBlockPtr; virtual; @t\2 @>
         function Read_Item: wsItemPtr; virtual; @t\2 @>

         procedure Read_ItemContentsAttr(aItem: wsItemPtr; var aShape: string); virtual; @t\2 @>
         procedure Read_ItemContents(aItem: wsItemPtr@+;@+ const aShape: string); virtual; @t\2 @>

         function Read_TermList:PList; virtual; @t\2 @>
         function Read_Adjective:AdjectiveExpressionPtr; virtual; @t\2 @>
         function Read_AdjectiveList: PList; virtual; @t\2 @>
         function Read_Type: TypePtr; virtual; @t\2 @>
         function Read_Variable: VariablePtr; virtual; @t\2 @>
         function Read_ImplicitlyQualifiedSegment: ImplicitlyQualifiedSegmentPtr; virtual; @t\2 @>
         function Read_VariableSegment: QualifiedSegmentPtr; virtual; @t\2 @>
         function Read_PrivatePredicativeFormula:PrivatePredicativeFormulaPtr; virtual; @t\2 @>
         function Read_Formula:FormulaPtr; virtual; @t\2 @>
         function Read_SimpleTerm: SimpleTermPtr; virtual; @t\2 @>
         function Read_PrivateFunctorTerm: PrivateFunctorTermPtr; virtual; @t\2 @>
         function Read_InternalSelectorTerm: InternalSelectorTermPtr; virtual; @t\2 @>
         function Read_Term: TermPtr; virtual; @t\2 @>

         function Read_TypeList: PList; virtual; @t\2 @>

         function Read_Locus: LocusPtr; virtual; @t\2 @>
         function Read_Loci: PList; virtual; @t\2 @>

         function Read_ModePattern: ModePatternPtr; virtual; @t\2 @>
         function Read_AttributePattern: AttributePatternPtr; virtual; @t\2 @>
         function Read_FunctorPattern: FunctorPatternPtr; virtual; @t\2 @>
         function Read_PredicatePattern: PredicatePatternPtr; virtual; @t\2 @>
         function Read_Pattern: PatternPtr; virtual; @t\2 @>

         function Read_Definiens: DefiniensPtr; virtual; @t\2 @>

         function Read_ReservationSegment: ReservationSegmentPtr; virtual; @t\2 @>
         function Read_SchemeNameInSchemeHead: SchemePtr; virtual; @t\2 @>
         function Read_Label: LabelPtr; virtual; @t\2 @>
         function Read_Proposition: PropositionPtr; virtual; @t\2 @>
         function Read_CompactStatement: CompactStatementPtr; virtual; @t\2 @>
         function Read_LocalReference: LocalReferencePtr; virtual; @t\2 @>
         function Read_References: PList; virtual; @t\2 @>
         function Read_StraightforwardJustification: StraightforwardJustificationPtr; virtual; @t\2 @>
         function Read_SchemeJustification: SchemeJustificationPtr; virtual; @t\2 @>
         function Read_Justification: JustificationPtr; virtual; @t\2 @>
         function Read_RegularStatement(const aShape: string): RegularStatementPtr; virtual; @t\2\2\2 @>
      end;

@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor InWSMizFileObj.OpenFile(const aFileName:string );
begin
   inherited OpenFile(aFileName);
   nDisplayInformationOnScreen:=false;
end;

destructor InWSMizFileObj.Done;
begin
   inherited Done;
end;

@ Getting the value for an attribute. Returns |nil| if there is no
attribute with the given name. (Recall (\section\xref{XMLAttrPtr}),
an \\{XMLAttr} is just a wrapper around a string \\{nValue}.)

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.GetAttrValue(const aAttrName:string): string;
var lObj: PObject;
begin
   result:='';
   lObj:=nAttrVals.ObjectOf(aAttrName);
   if lObj <> nil then
      result:=XMLAttrPtr(lObj)^.nValue;
end;

@ We can query for the \emph{position} of the \XML/ attribute.

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.GetAttrPos: Position;
var lLine,lCol: XMLAttrPtr;
lCode: integer;
begin
   result.Line:=1;
   result.Col:=1;
   lLine:=XMLAttrPtr(nAttrVals.ObjectOf(XMLAttrName[atLine]));
   lCol:=XMLAttrPtr(nAttrVals.ObjectOf(XMLAttrName[atCol]));
   if (lLine <> nil) and (lCol <> nil) then
   begin
      Val(lLine^.nValue, result.Line,lCode);
      Val(lCol^.nValue, result.Col,lCode);
   end;
end;

@ The state of the  WSM parser may be described with a handful of
lookup tables.

@<Implementation for \texttt{wsmarticle.pas}@>=
var
   ElemLookupTable,AttrLookupTable,BlockLookUpTable,ItemLookUpTable,
   FormulaKindLookupTable,TermKindLookupTable,
   PatternKindLookupTable,
   CorrectnessKindLookupTable,PropertyKindLookupTable: MSortedStrList; @#

procedure InitWSLookupTables;
var e: XMLElemKind;
a: XMLAttrKind;
b: BlockKind;
i: ItemKind;
f: FormulaSort;
t: TermSort;
p: PropertyKind;
c: CorrectnessKind;
begin
   ElemLookupTable.Init( Ord( High( XMLElemKind)) + 1);
   AttrLookupTable.Init( Ord( High( XMLAttrKind)) + 1);
   BlockLookupTable.Init( Ord( High( BlockKind)) + 1);
   ItemLookupTable.Init( Ord( High( ItemKind)) + 1);
   FormulaKindLookupTable.Init( Ord( High( FormulaSort)) + 1);
   TermKindLookupTable.Init( Ord( High( TermSort)) + 1);
   PatternKindLookupTable.Init( Ord(itDefStruct)- Ord(itDefPred) + 1);
   CorrectnessKindLookupTable.Init(ord( High(CorrectnessKind)) + 1);
   PropertyKindLookupTable.Init( ord( High(PropertyKind)) + 1);

   for e:= Low( XMLElemKind) to High( XMLElemKind) do
      ElemLookupTable.Insert( new( MStrPtr, Init( XMLElemName[ e] )));
   for a:= Low( XMLAttrKind) to High( XMLAttrKind) do
      AttrLookupTable.Insert( new( MStrPtr, Init( XMLAttrName[ a] )));
   for b:= Low( BlockKind) to High( BlockKind) do
      BlockLookupTable.Insert( new( MStrPtr, Init( BlockName[ b] )));
   for i:= Low( ItemKind) to High( ItemKind) do
      ItemLookupTable.Insert( new( MStrPtr, Init( ItemName[ i] )));
   for f:= Low( FormulaSort) to High( FormulaSort) do
      FormulaKindLookupTable.Insert( new( MStrPtr, Init( FormulaName[ f] )));
   for t:= Low( TermSort) to High( TermSort) do
      TermKindLookupTable.Insert( new( MStrPtr, Init( TermName[ t] )));
   for i:= itDefPred to itDefStruct do
      PatternKindLookupTable.Insert( new( MStrPtr, Init( DefPatternName[ i] )));
   for p:= Low( PropertyKind) to High( PropertyKind) do
      PropertyKindLookupTable.Insert( new( MStrPtr, Init( PropertyName[ p] )));
   for c:= Low( CorrectnessKind) to High( CorrectnessKind) do
      CorrectnessKindLookupTable.Insert( new( MStrPtr, Init( CorrectnessName[ c] )));
end;

@ We also need to free the memory consumed by the lookup tables.

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure DisposeWSLookupTables;
begin
   ElemLookupTable.Done;
   AttrLookupTable.Done;
   BlockLookupTable.Done;
   ItemLookupTable.Done;
   FormulaKindLookupTable.Done;
   TermKindLookupTable.Done;
   CorrectnessKindLookupTable.Done;
   PropertyKindLookupTable.Done;
end;

@ We can recall, from the \XML/ dictionary module
(\section\xref{XMLDictionary}), the different kinds of \XML/ elements
as specified by an enumerated constant. This converts the
``\texttt{nr}'' attribute to the human readable equivalents.

@<Implementation for \texttt{wsmarticle.pas}@>=
function Str2XMLElemKind( aStr: string): XMLElemKind;
var lNr:integer;
begin
   lNr:= ElemLookupTable.IndexOfStr( aStr);
   if lNr > -1 then
      Str2XMLElemKind:= XMLElemKind( lNr)
   else Str2XMLElemKind:= elUnknown;
end;

@ Like the previous function, this converts the ``\texttt{nr}''
attribute for a WSM Mizar attribute \XML/ element into a human
readable form.

@<Implementation for \texttt{wsmarticle.pas}@>=
function Str2XMLAttrKind( aStr: string): XMLAttrKind;
var lNr:integer;
begin
   lNr:= AttrLookupTable.IndexOfStr( aStr);
   if lNr > -1 then
      Str2XMLAttrKind:= XMLAttrKind( lNr)
   else Str2XMLAttrKind:= atUnknown;
end;

@ The ``kinds'' of different syntactic classes were introduced earlier
in \texttt{wsmarticle.pas}, now we want to translate them into human
readable form.

@<Implementation for \texttt{wsmarticle.pas}@>=
function Str2BlockKind( aStr: string): BlockKind;
var lNr:integer;
begin
   lNr:= BlockLookupTable.IndexOfStr( aStr);
   if lNr > -1 then
      Str2BlockKind:= BlockKind( lNr)
   else Str2BlockKind:= blMain;
end; @#

function Str2ItemKind( aStr: string): ItemKind;
var lNr:integer;
begin
   lNr:= ItemLookupTable.IndexOfStr( aStr);
   if lNr > -1 then
      Str2ItemKind:= ItemKind( lNr)
   else Str2ItemKind:=itIncorrItem;
end; @#

function Str2PatterenKind( aStr: string): ItemKind;
var lNr:integer;
begin
   lNr:= PatternKindLookupTable.IndexOfStr( aStr);
   if lNr > -1 then
      Str2PatterenKind:= ItemKind(Ord(ItDefPred)+lNr)
   else Str2PatterenKind:=itIncorrItem;
end; @#

function Str2FormulaKind( aStr: string): FormulaSort;
var lNr:integer;
begin
   lNr:= FormulaKindLookupTable.IndexOfStr( aStr);
   if lNr > -1 then
      Str2FormulaKind:= FormulaSort( lNr)
   else Str2FormulaKind:=wsErrorFormula;
end; @#
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function Str2TermKind( aStr: string): TermSort;
var lNr:integer;
begin
   lNr:= TermKindLookupTable.IndexOfStr( aStr);
   if lNr > -1 then
      Str2TermKind:= TermSort( lNr)
   else Str2TermKind:=wsErrorTerm;
end; @#

function Str2PropertyKind( aStr: string): PropertyKind;
var lNr:integer;
begin
   lNr:= PropertyKindLookupTable.IndexOfStr( aStr);
   if lNr > -1 then
      Str2PropertyKind:= PropertyKind( lNr)
end; @#

function Str2CorrectnessKind( aStr: string): CorrectnessKind;
var lNr:integer;
begin
   lNr:= CorrectnessKindLookupTable.IndexOfStr( aStr);
   if lNr > -1 then
      Str2CorrectnessKind:= CorrectnessKind( lNr)
end;

@* [s] Parsing types.
Reading a ``term list'' just iteratively invokes \\{Read\_Term}
(\section\xref{InWSMizFileObj.Read_Term}) until all the children have
been read.

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_TermList:PList;
begin
   result :=new(PList,Init(0));
   while nState <> eEnd do
      result^.Insert(Read_Term);
end;

@ An adjective is either ``positive'' (i.e., not negated) or
``negative'' (i.e., negated). We handle the first case in the ``true''
branch, and the second case in the ``false'' branch.

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Adjective:AdjectiveExpressionPtr;
var lAttrNr: integer;
lPos: Position;
lNoneOcc: Boolean;
begin
   if nElName = AdjectiveSortName[wsAdjective] then
   begin
      lPos:=GetAttrPos;
      lAttrNr:=GetIntAttr(XMLAttrName[atNr]);
      NextElementState;
      result:=new(AdjectivePtr,Init(lPos,lAttrNr,Read_TermList));
      NextElementState;
   end
   else
   begin
      lPos:=GetAttrPos;
      NextElementState;
      result:=new(NegatedAdjectivePtr,Init(lPos,Read_Adjective));
      NextElementState;
   end;
end;

@ Reading a list of adjectives just iterates over the children of an element.

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_AdjectiveList: PList;
begin
   result:=new(Plist,Init(0));
   NextElementState;
   while nState <> eEnd do
      result^.Insert(Read_Adjective);
   NextElementState;
end;

@
There are three valid Mizar types: ``standard'' types, structure
types, and expandable modes (i.e., a cluster of adjectives stacked
atop a type). If the \XML/ element fails to match these three, then we
should produce an ``incorrect type''.

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Type: TypePtr;
var lList: Plist;
lPos: Position;
lModeSymbol:integer;
begin
   if nElName = TypeName[wsStandardType] then
   begin
      lPos:=GetAttrPos;
      lModeSymbol:=GetIntAttr(XMLAttrName[atNr]);
      NextElementState;
      result:=new(StandardTypePtr,Init(lPos,lModeSymbol,Read_TermList));
      NextElementState;
   end
   else if nElName = TypeName[wsStructureType] then
   begin
      lPos:=GetAttrPos;
      lModeSymbol:=GetIntAttr(XMLAttrName[atNr]);
      NextElementState;
      result:=new(StructTypePtr,Init(lPos,lModeSymbol,Read_TermList));
      NextElementState;
   end
   else if nElName = TypeName[wsClusteredType] then
   begin
      lPos:=GetAttrPos;
      NextElementState;
      lList:=Read_AdjectiveList;
      result:=new(ClusteredTypePtr,Init(lPos,lList,Read_Type));
      NextElementState;
   end
   else
   begin
      lPos:=GetAttrPos;
      NextElementState;
      result:=new(IncorrectTypePtr,Init(lPos));
      NextElementState;
   end
end;

@* [s] Parsing formulas.
Parsing a variable from \XML/ just requires reading the attributes,
since it is an empty-element.

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Variable: VariablePtr;
var lPos:Position;
lNr: integer;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atIdNr]); @/
   NextElementState; {closes the variable's tag}
   result:=new(VariablePtr,Init(lPos,lNr)); @/
   NextElementState; {starts the next tag}
end;

@ Implicitly qualified variables are just wrappers around a variable.

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_ImplicitlyQualifiedSegment: ImplicitlyQualifiedSegmentPtr;
var lPos: Position;
begin
   lPos:=GetAttrPos;
   NextElementState;
   result:=new(ImplicitlyQualifiedSegmentPtr,Init(lPos,Read_Variable));
   NextElementState;
end;

@ Recall (\section\xref{OutWSMizFileObj.Out_VariableSegment}) that a
``qualified segment'' is either implicit (i.e., a wrapper around a 
single variable) or explicit (i.e., an element whose children are
variables and a type).

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_VariableSegment: QualifiedSegmentPtr;
var lPos: Position;
lVar: VariablePtr;
lList: PList;
begin
   if nElName = SegmentKindName[ikImplQualifiedSegm] then
   begin
      result:=Read_ImplicitlyQualifiedSegment;
   end
   else if nElName = SegmentKindName[ikExplQualifiedSegm] then
   begin
      lPos:=GetAttrPos;
      NextElementState;
      lList:=new(PList,Init(0)); @/
      NextElementState; {read the variables}
      while (nState = eStart) and (nElName = XMLElemName[elVariable]) do
         lList^.Insert(Read_Variable);
      NextElementState; {read the type}
      result:=new(ExplicitlyQualifiedSegmentPtr,Init(lPos,lList,Read_Type));@/
      NextElementState; {start the next tag}
   end
end;

@ Private predicates are empty elements, so we only need to read their
attributes. 

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_PrivatePredicativeFormula:PrivatePredicativeFormulaPtr;
var lPos:Position;
lNr: integer;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atIdNr]);
   NextElementState;
   result:=new(PrivatePredicativeFormulaPtr,Init(lPos,lNr,Read_TermList));
   NextElementState;
end;

@ 

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Formula:FormulaPtr;
var lPos:Position;
lNr: integer;
lList: PList;
lFrm: FormulaPtr;
lTrm: TermPtr;
lSgm: QualifiedSegmentPtr;
begin
   case Str2FormulaKind(nElName) of
      wsNegatedFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            result:=new(NegativeFormulaPtr,Init(lPos,Read_Formula));
            NextElementState;
         end; @#
 @t\4@>     @<Parse \XML/ for formula with binary connective@>; @#
      wsFlexaryConjunctiveFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lFrm:=Read_Formula;
            result:=new(FlexaryConjunctiveFormulaPtr,Init(lPos,lFrm,Read_Formula));
            NextElementState;
         end;
      wsFlexaryDisjunctiveFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lFrm:=Read_Formula;
            result:=new(FlexaryDisjunctiveFormulaPtr,Init(lPos,lFrm,Read_Formula));
            NextElementState;
         end; @#
 @t\4@>     @<Parse \XML/ for predicate-based formula@>; @#
      wsAttributiveFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lTrm:=Read_Term;
            result:=new(AttributiveFormulaPtr,Init(lPos,lTrm,Read_AdjectiveList));
            NextElementState;
         end;
      wsQualifyingFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lTrm:=Read_Term;
            result:=new(QualifyingFormulaPtr,Init(lPos,lTrm,Read_Type));
            NextElementState;
         end; @#
      wsUniversalFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lSgm:=Read_VariableSegment;
            result:=new(UniversalFormulaPtr,Init(lPos,lSgm,Read_Formula));
            NextElementState;
         end;
      wsExistentialFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lSgm:=Read_VariableSegment;
            result:=new(ExistentialFormulaPtr,Init(lPos,lSgm,Read_Formula));
            NextElementState;
         end; @#
      wsContradiction:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            result:=new(ContradictionFormulaPtr,Init(lPos));
            NextElementState;
         end;
      wsThesis:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            result:=new(ThesisFormulaPtr,Init(lPos));
            NextElementState;
         end;
      wsErrorFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            result:=new(IncorrectFormulaPtr,Init(lPos));
            NextElementState;
         end;
   endcases;
end;

@  For formulas with binary connectives, we read both arguments.

@<Parse \XML/ for formula with binary connective@>=
      wsConjunctiveFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lFrm:=Read_Formula;
            result:=new(ConjunctiveFormulaPtr,Init(lPos,lFrm,Read_Formula));
            NextElementState;
         end;
      wsDisjunctiveFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lFrm:=Read_Formula;
            result:=new(DisjunctiveFormulaPtr,Init(lPos,lFrm,Read_Formula));
            NextElementState;
         end;
      wsConditionalFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lFrm:=Read_Formula;
            result:=new(ConditionalFormulaPtr,Init(lPos,lFrm,Read_Formula));
            NextElementState;
         end;
      wsBiconditionalFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lFrm:=Read_Formula;
            result:=new(BiconditionalFormulaPtr,Init(lPos,lFrm,Read_Formula));
            NextElementState;
         end

@

@<Parse \XML/ for predicate-based formula@>=
      wsPredicativeFormula:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            NextElementState; {Arguments}
            lList:=Read_TermList;
            NextElementState; {Arguments}
            NextElementState; {Arguments}
            result:=new(PredicativeFormulaPtr,Init(lPos,lNr,lList,Read_TermList));
            NextElementState;
            NextElementState;
         end;
      wsRightSideOfPredicativeFormula:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            NextElementState; {Arguments}
            result:=new(RightSideOfPredicativeFormulaPtr,Init(lPos,lNr,Read_TermList));
            NextElementState;
            NextElementState;
         end;
      wsMultiPredicativeFormula:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lList:=new(PList,Init(0));
            while nState <> eEnd do
               lList^.Insert(Read_Formula);
            result:=new(MultiPredicativeFormulaPtr,Init(lPos,lList));
            NextElementState;
         end;
      wsPrivatePredicateFormula:
         begin
            result:=Read_PrivatePredicativeFormula;
         end

@* [s] Parsing terms.

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_SimpleTerm: SimpleTermPtr;
var lPos:Position;
lNr: integer;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atIdNr]);
   NextElementState;
   result:=new(SimpleTermPtr,Init(lPos,lNr));
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_PrivateFunctorTerm: PrivateFunctorTermPtr;
var lPos:Position;
lNr: integer;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atIdNr]);
   NextElementState;
   result:=new(PrivateFunctorTermPtr,Init(lPos,lNr,Read_TermList));
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_InternalSelectorTerm: InternalSelectorTermPtr;
var lPos:Position;
lNr: integer;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atNr]);
   NextElementState;
   result:=new(InternalSelectorTermPtr,Init(lPos,lNr));
   NextElementState;
end;

@ 

\label{InWSMizFileObj.Read_Term}

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Term: TermPtr;
var lPos,lRPos:Position;
lNr,lRNr: integer;
lList: PList;
lTrm: TermPtr;
begin
   case Str2TermKind(nElName) of
      wsPlaceholderTerm:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            result:=new(PlaceholderTermPtr,Init(lPos,lNr));
            NextElementState;
         end;
      wsSimpleTerm:
         begin
            result:=Read_SimpleTerm;
         end;
      wsNumeralTerm:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNumber]);
            NextElementState;
            result:=new(NumeralTermPtr, Init(lPos,lNr));
            NextElementState;
         end;
      wsInfixTerm:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            NextElementState; {Arguments}
            lList:=Read_TermList;
            NextElementState; {Arguments}
            NextElementState; {Arguments}
            result:=new(InfixTermPtr,Init(lPos,lNr,lList,Read_TermList));
            NextElementState;
            NextElementState;
         end;
      wsCircumfixTerm:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            NextElementState;
            lRNr:=GetIntAttr(XMLAttrName[atNr]);
            lRPos:=GetAttrPos;
            NextElementState;
            result:=new(CircumfixTermPtr,Init(lPos,lNr,lRNr,Read_TermList));
            NextElementState;
         end;
      wsPrivateFunctorTerm:
         begin
            result:=Read_PrivateFunctorTerm;
         end;
      wsAggregateTerm:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            result:=new(AggregateTermPtr,Init(lPos,lNr,Read_TermList));
            NextElementState;
         end;
      wsSelectorTerm:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            result:=new(SelectorTermPtr,Init(lPos,lNr,Read_Term));
            NextElementState;
         end;
      wsInternalSelectorTerm:
         result:=Read_InternalSelectorTerm;
      wsForgetfulFunctorTerm:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            result:=new(ForgetfulFunctorTermPtr,Init(lPos,lNr,Read_Term));
            NextElementState;
         end;
      wsInternalForgetfulFunctorTerm:
         begin
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            result:=new(InternalForgetfulFunctorTermPtr,Init(lPos,lNr));
            NextElementState;
         end;
      wsFraenkelTerm:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lList:=new(PList,Init(0));
            while (nState = eStart) and
                     ((nElName = SegmentKindName[ikImplQualifiedSegm]) or
                         (nElName = SegmentKindName[ikExplQualifiedSegm])) do
               lList^.Insert(Read_VariableSegment);
            lTrm:=Read_Term;
            result:=new(FraenkelTermPtr,Init(lPos,lList,lTrm,Read_Formula));
            NextElementState;
         end;
      wsSimpleFraenkelTerm:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lList:=new(PList,Init(0));
            while (nState = eStart) and
                     ((nElName = SegmentKindName[ikImplQualifiedSegm]) or
                         (nElName = SegmentKindName[ikExplQualifiedSegm])) do
               lList^.Insert(Read_VariableSegment);
            lTrm:=Read_Term;
            result:=new(SimpleFraenkelTermPtr,Init(lPos,lList,lTrm));
            NextElementState;
         end;
      wsQualificationTerm:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            lTrm:=Read_Term;
            result:=new(QualifiedTermPtr,Init(lPos,lTrm,Read_Type));
            NextElementState;
         end;
      wsExactlyTerm:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            result:=new(ExactlyTermPtr,Init(lPos,Read_Term));
            NextElementState;
         end;
      wsGlobalChoiceTerm:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            result:=new(ChoiceTermPtr,Init(lPos,Read_Type));
            NextElementState;
         end;
      wsItTerm:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            result:=new(ItTermPtr,Init(lPos));
            NextElementState;
         end;
      wsErrorTerm:
         begin
            lPos:=GetAttrPos;
            NextElementState;
            result:=new(IncorrectTermPtr,Init(lPos));
            NextElementState;
         end;
   endcases;
end;

@* [s] Parsing text items.

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_TypeList: PList;
begin
   NextElementState;
   result :=new(PList,Init(0));
   while nState <> eEnd do
      result^.Insert(Read_Type);
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Locus: LocusPtr;
var lPos:Position;
lNr: integer;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atIdNr]);
   NextElementState;
   result:=new(LocusPtr,Init(lPos,lNr));
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Loci: PList;
begin
   NextElementState;
   result :=new(PList,Init(0));
   while nState <> eEnd do
      result^.Insert(Read_Locus);
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_ModePattern: ModePatternPtr;
var lPos:Position;
lNr: integer;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atNr]);
   NextElementState;
   result:=new(ModePatternPtr,Init(lPos,lNr,Read_Loci));
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_AttributePattern: AttributePatternPtr;
var lPos:Position;
lNr: integer;
lArg: LocusPtr;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atNr]);
   NextElementState;
   lArg:=Read_Locus;
   result:=new(AttributePatternPtr,Init(lPos,lArg,lNr,Read_Loci));
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_FunctorPattern: FunctorPatternPtr;
var lPos,lRPos:Position;
lNr,lRNr: integer;
lArgs: PList;
begin
   if nState= eStart then
      if nElName = FunctorPatternName[InfixFunctor] then
      begin
         lPos:=GetAttrPos;
         lNr:=GetIntAttr(XMLAttrName[atNr]);
         NextElementState;
         lArgs:=Read_Loci;
         result:=new(InfixFunctorPatternPtr,Init(lPos,lArgs,lNr,Read_Loci));
         NextElementState;
      end
      else if nElName = FunctorPatternName[CircumfixFunctor] then
      begin
         lPos:=GetAttrPos;
         lNr:=GetIntAttr(XMLAttrName[atNr]);
         NextElementState;
         lRNr:=GetIntAttr(XMLAttrName[atNr]);
         NextElementState;
         NextElementState;
         result:=new(CircumfixFunctorPatternPtr,Init(lPos,lNr,lRNr,Read_Loci));
         NextElementState;
      end;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_PredicatePattern: PredicatePatternPtr;
var lPos,lRPos:Position;
lNr,lRNr: integer;
lArgs: PList;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atNr]);
   NextElementState;
   lArgs:=Read_Loci;
   result:=new(PredicatePatternPtr,Init(lPos,lArgs,lNr,Read_Loci));
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Pattern: PatternPtr;
begin
   case Str2PatterenKind(nElName) of
      itDefPred: result:=Read_PredicatePattern;
      itDefFunc: result:=Read_FunctorPattern;
      itDefMode: result:=Read_ModePattern;
      itDefAttr: result:=Read_AttributePattern;
   othercases
      if (nElName = FunctorPatternName[InfixFunctor]) or
            (nElName = FunctorPatternName[CircumfixFunctor])
      then result:=Read_FunctorPattern
      else result:=nil;
   endcases;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Definiens: DefiniensPtr;
var lPos: Position;
lKind,lShape: string;
lLab: LabelPtr;
lExpr: PObject;
lExpKind: ExpKind;
lList: PList;
lOtherwise: DefExpressionPtr;
begin
   result:=nil;
   if (nState= eStart) and (nElName = XMLElemName[elDefiniens]) then
   begin
      lPos:=GetAttrPos;
      lKind:=GetAttr(XMLAttrName[atKind]);
      lShape:=GetAttr(XMLAttrName[atShape]);
      NextElementState;
      lLab:=Read_Label;
      if lKind = DefiniensKindName[SimpleDefiniens] then
      begin
         lExpKind:=exFormula;
         if lShape = ExpName[exTerm] then
            lExpKind:=exTerm;
         case lExpKind of
            exTerm: lExpr:=Read_Term;
            exFormula: lExpr:=Read_Formula;
         endcases;
         result:=new(SimpleDefiniensPtr,Init(lPos,lLab,
                                             new(DefExpressionPtr,Init(lExpKind,lExpr))));
      end
      else
      begin
         lList:=new(Plist,Init(0));
         while (nState= eStart) and (nElName = XMLElemName[elPartialDefiniens]) do
         begin
            NextElementState;
            lExpKind:=exFormula;
            if lShape = ExpName[exTerm] then
               lExpKind:=exTerm;
            case lExpKind of
               exTerm: lExpr:=Read_Term;
               exFormula: lExpr:=Read_Formula;
            endcases;
            lList^.Insert(new(PartDefPtr,Init(new(DefExpressionPtr,Init(lExpKind,lExpr)),Read_Formula)));
            NextElementState;
         end;
         lOtherwise:=nil;
         if nState <> eEnd then
         begin
            lExpKind:=exFormula;
            if lShape = ExpName[exTerm] then
               lExpKind:=exTerm;
            case lExpKind of
               exTerm: lExpr:=Read_Term;
               exFormula: lExpr:=Read_Formula;
            endcases;
            lOtherwise:=new(DefExpressionPtr,Init(lExpKind,lExpr));
         end;
         result:=new(ConditionalDefiniensPtr,Init(lPos,lLab,lList,lOtherwise))
      end;
      NextElementState;
   end;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Label: LabelPtr;
var lLabPos: Position;
lLabId: Integer;
begin
   result:=nil;
   if (nState= eStart)  and (nElName = XMLElemName[elLabel]) then
   begin
      lLabId:=GetIntAttr(XMLAttrName[atIdNr]);
      lLabPos:=GetAttrPos;
      NextElementState;
      NextElementState;
      result:=new(LabelPtr,Init(lLabId,lLabPos));
   end;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Proposition: PropositionPtr;
var lPos: Position;
lLab: LabelPtr;
begin
   NextElementState;
   lLab:=Read_label;
   result:=new(PropositionPtr,Init(lLab,Read_Formula,lPos));
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_LocalReference: LocalReferencePtr;
var lPos: Position;
lNr: integer;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atIdNr]);
   NextElementState;
   NextElementState;
   result:=new(LocalReferencePtr, Init(lNr,lPos));
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_References: PList;
var lPos: Position;
lNr,lFileNr: integer;
begin
   result:=new(Plist,Init(0));
   while nState <> eEnd do
      if nElName = ReferenceKindName[LocalReference] then
      begin
         result^.Insert(Read_LocalReference)
      end
      else if nElName = ReferenceKindName[TheoremReference] then
      begin
         lPos:=GetAttrPos;
         lFileNr:=GetIntAttr(XMLAttrName[atNr]);
         lNr:=GetIntAttr(XMLAttrName[atNumber]);
         NextElementState;
         NextElementState;
         result^.Insert(new(TheoremReferencePtr, Init(lFileNr,lNr,lPos)))
      end
      else if nElName = ReferenceKindName[DefinitionReference] then
      begin
         lPos:=GetAttrPos;
         lFileNr:=GetIntAttr(XMLAttrName[atNr]);
         lNr:=GetIntAttr(XMLAttrName[atNumber]);
         NextElementState;
         NextElementState;
         result^.Insert(new(DefinitionReferencePtr, Init(lFileNr,lNr,lPos)))
      end;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_ReservationSegment: ReservationSegmentPtr;
var lList: PList;
begin
   lList:=new(PList,Init(0));
   NextElementState; {elVariables}
   while (nState = eStart) and (nElName = XMLElemName[elVariable]) do
      lList^.Insert(Read_Variable);
   NextElementState;
   result:=new(ReservationSegmentPtr,Init(lList,Read_Type));
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_SchemeNameInSchemeHead: SchemePtr;
var lNr: Integer;
lPos: Position;
begin
   lPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atIdNr]);
   result:=new(SchemePtr,Init(lNr,lPos,nil,nil,nil));
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_CompactStatement: CompactStatementPtr;
var lProp: PropositionPtr;
begin
   lProp:=Read_Proposition;
   result:=new(CompactStatementPtr,Init(lProp,Read_Justification));
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_StraightforwardJustification: StraightforwardJustificationPtr;
var lPos,lLinkPos: Position;
lLinked: boolean;
begin
   lPos:=GetAttrPos;
   NextElementState;
   lLinked:=false;
   lLinkPos:=lPos;
   if nelName = XMLElemName[elLink] then
   begin
      lLinked:=true;
      lLinkPos:=GetAttrPos;
      NextElementState;
      NextElementState;
   end;
   result:=new(StraightforwardJustificationPtr,Init(lPos,lLinked,lLinkPos));
   StraightforwardJustificationPtr(result)^.nReferences:=Read_References;
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_SchemeJustification: SchemeJustificationPtr;
var lInfPos,lPos: Position;
lNr,lIdNr: integer;
begin
   lInfPos:=GetAttrPos;
   lNr:=GetIntAttr(XMLAttrName[atNr]);
   lIdNr:=GetIntAttr(XMLAttrName[atIdNr]);
   lPos.Line:=GetIntAttr( XMLAttrName[atPosLine]);
   lPos.Col:= GetIntAttr( XMLAttrName[atPosCol]);
   NextElementState;
   result:=new(SchemeJustificationPtr,Init(lInfPos,lNr,lIdNr));
   SchemeJustificationPtr(result)^.nSchemeInfPos:=lPos;
   SchemeJustificationPtr(result)^.nReferences:=Read_References;
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Justification: JustificationPtr;
var lPos: Position;
begin
   if nState= eStart then
      if nElName = InferenceName[infStraightforwardJustification] then
         result:=Read_StraightforwardJustification
      else if nElName = InferenceName[infSchemeJustification] then
         result:=Read_SchemeJustification
      else if nElName = InferenceName[infError] then
      begin
         lPos:=GetAttrPos;
         NextElementState;
         result:=new(JustificationPtr,Init(infError,lPos));
         NextElementState;
      end
      else if nElName = InferenceName[infSkippedProof] then
      begin
         lPos:=GetAttrPos;
         NextElementState;
         result:=new(JustificationPtr,Init(infSkippedProof,lPos));
         NextElementState;
      end
      else
         result:=new(JustificationPtr,Init(infProof,CurPos));
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_RegularStatement(const aShape: string): RegularStatementPtr;
var lPos: Position;
lIdNr: integer;
lTrm: TermPtr;
lCStm: CompactStatementPtr;
lLab: LabelPtr;
begin
   if aShape = RegularStatementName[stDiffuseStatement] then
   begin
      lLab:=Read_Label;
      result:=new(DiffuseStatementPtr,Init(lLab,stDiffuseStatement));
   end
   else if aShape = RegularStatementName[stCompactStatement] then
   begin
      result:=Read_CompactStatement;
   end
   else if aShape = RegularStatementName[stIterativeEquality] then
   begin
      lCStm:=Read_CompactStatement;
      result:=new(IterativeEqualityPtr,Init(lCStm^.nProp,lCStm^.nJustification,new(PList,Init(0))));
      while (nState= eStart) and (nElName = XMLElemName[elIterativeStep]) do
      begin
         lPos:=GetAttrPos;
         NextElementState;
         lTrm:=Read_Term;
         IterativeEqualityPtr(result)^.nIterSteps^.Insert(new(IterativeStepPtr,Init(lPos,lTrm,Read_Justification)));
         NextElementState;
      end;
   end;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure InWSMizFileObj.Read_ItemContentsAttr(aItem: wsItemPtr; var aShape: string);
begin
   aShape:='';
   case aItem^.nItemKind of
      itIncorrItem:;
      itDefinition, itSchemeBlock, itSchemeHead, itTheorem, itAxiom,
      itReservation:;
      itSection:;
      itConclusion,
      itRegularStatement:
         aShape:=GetAttr(XMLAttrName[atShape]);
      itChoice, itReconsider,
      itPrivFuncDefinition, itPrivPredDefinition, itConstantDefinition,
      itGeneralization, itLociDeclaration,itExistentialAssumption, itExemplification,
      itPerCases, itCaseBlock:;
      itCaseHead, itSupposeHead,
      itAssumption:;
      itCorrCond:
         aItem^.nContent:=new(CorrectnessConditionPtr,
                              Init(CurPos,Str2CorrectnessKind(GetAttr(XMLAttrName[atCondition])),nil));
      itCorrectness:
         aItem^.nContent:=new(CorrectnessConditionsPtr,Init(CurPos,[],nil));
      itProperty:
         aShape:=GetAttr(XMLAttrName[atProperty]);
      itDefFunc:
         aShape:=GetAttr(XMLAttrName[atShape]);
      itDefPred, itDefMode, itDefAttr,
      itDefStruct,
      itPredSynonym, itPredAntonym, itFuncNotation, itModeNotation,
      itAttrSynonym, itAttrAntonym,
      itCluster,
      itIdentify, itReduction:;
      itPropertyRegistration:
         aShape:=GetAttr(XMLAttrName[atProperty]);
      itPragma:
         aItem^.nContent:=new(PragmaPtr,Init(XMLToStr(GetAttr(XMLAttrName[atSpelling]))));
   endcases;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure InWSMizFileObj.Read_ItemContents(aItem: wsItemPtr; const aShape: string);
var lList,lCons,lConds,lVars,lFields,lTyps,lSels: PList;
lType: TypePtr;
lNr: Integer;
lVar: VariablePtr;
lLocus: LocusPtr;
lTrm: TermPtr;
lPos,lFieldSgmPos: Position;
lRedefinition: boolean;
lPattern: PatternPtr;
lDef: HowToDefine;
lPropertySort: PropertyKind;
begin
   lPos:=CurPos;
   case aItem^.nItemKind of
      itIncorrItem:;
      itDefinition:;
      itSchemeBlock:;
      itSchemeHead:
         begin
            aItem^.nContent:=Read_SchemeNameInSchemeHead;
            NextElementState;
            NextElementState;
            NextElementState;   {elSchematicVariables}
            lList:=new(PList,Init(0));
            while (nState = eStart) and
                     ((nElName = SchemeSegmentName[PredicateSegment]) or
                         (nElName = SchemeSegmentName[FunctorSegment])) do
               if nElName = SchemeSegmentName[PredicateSegment] then
               begin
                  lPos:=GetAttrPos;
                  NextElementState;
                  lVars:=new(PList,Init(0));
                  NextElementState; {elVariables}
                  while (nState = eStart) and (nElName = XMLElemName[elVariable]) do
                     lVars^.Insert(Read_Variable);
                  NextElementState;
                  lList^.Insert(new(PredicateSegmentPtr,Init(lPos,PredicateSegment,lVars,Read_TypeList)));
                  NextElementState;
               end
               else
               begin
                  lPos:=GetAttrPos;
                  NextElementState;
                  lVars:=new(PList,Init(0));
                  NextElementState; {elVariables}
                  while (nState = eStart) and (nElName = XMLElemName[elVariable]) do
                     lVars^.Insert(Read_Variable);
                  NextElementState;
                  lTyps:=Read_TypeList;
                  NextElementState;
                  lList^.Insert(new(FunctorSegmentPtr,Init(lPos,lVars,lTyps,Read_Type)));
                  NextElementState;
                  NextElementState;
               end;
            SchemePtr(aItem^.nContent)^.nSchemeParams:=lList;
            NextElementState; {elSchematicVariables}
            SchemePtr(aItem^.nContent)^.nSchemeConclusion:=Read_Formula;
            lConds:=new(PList,Init(0));
            if (nState = eStart) and (nElName = XMLElemName[elProvisionalFormulas]) then
            begin
               NextElementState;
               while (nState = eStart) and (nElName = XMLElemName[elProposition]) do
                  lConds^.Insert(Read_Proposition);
               NextElementState;
            end;
            SchemePtr(aItem^.nContent)^.nSchemePremises:=lConds;
         end;
      itTheorem:
         aItem^.nContent:=Read_CompactStatement;
      itAxiom:
         begin
         end;
      itReservation:
         aItem^.nContent:=Read_ReservationSegment;
      itSection:;
      itChoice:
         begin
            lList:=new(PList,Init(0));
            while (nState = eStart) and
                     ((nElName = SegmentKindName[ikImplQualifiedSegm]) or
                         (nElName = SegmentKindName[ikExplQualifiedSegm])) do
               lList^.Insert(Read_VariableSegment);
            NextElementState;
            lConds:=nil;
            if nElName = XMLElemName[elProposition] then
            begin
               lConds:=new(PList,Init(0));
               while (nState = eStart) and (nElName = XMLElemName[elProposition]) do
                  lConds^.Insert(Read_Proposition);
            end;
            NextElementState;
            aItem^.nContent:=new(ChoiceStatementPtr,Init(lList,lConds,
                                                         SimpleJustificationPtr(Read_Justification)));
         end;
      itReconsider:
         begin
            lList:=new(PList,Init(0));
            while (nState = eStart) and
                     ((nElName = XMLElemName[elEquality]) or (nElName = XMLElemName[elVariable])) do
               if nElName = XMLElemName[elVariable] then
                  lList^.Insert(new(TypeChangePtr,Init(VariableIdentifier,Read_Variable,nil)))
               else
               begin
                  NextElementState;
                  lVar:=Read_Variable;
                  lList^.Insert(new(TypeChangePtr,Init(Equating,lVar,Read_Term)));
                  NextElementState;
               end;
            lType:=Read_Type;
            aItem^.nContent:=new(TypeChangingStatementPtr,
                                 Init(lList,lType,SimpleJustificationPtr(Read_Justification)));
         end;
      itPrivFuncDefinition:
         begin
            lVar:=Read_Variable;
            lList:=Read_TypeList;
            aItem^.nContent:=new(PrivateFunctorDefinitionPtr,Init(lVar,lList,Read_Term));
         end;
      itPrivPredDefinition:
         begin
            lVar:=Read_Variable;
            lList:=Read_TypeList;
            aItem^.nContent:=new(PrivatePredicateDefinitionPtr,Init(lVar,lList,Read_Formula));
         end;
      itConstantDefinition:
         begin
            lVar:=Read_Variable;
            aItem^.nContent:=new(ConstantDefinitionPtr,Init(lVar,Read_Term));
         end;
      itLociDeclaration,
      itGeneralization:
         aItem^.nContent:=Read_VariableSegment;
      itPerCases:
         aItem^.nContent:=Read_Justification;
      itCaseBlock: ;
      itCorrCond:
         begin
            CorrectnessConditionPtr(aItem^.nContent)^.nJustification:=Read_Justification;
         end;
      itCorrectness:
         begin
            NextElementState;
            while (nState = eStart) and (nElName = ItemName[itCorrectness]) do
            begin
               NextElementState;
               include(CorrectnessConditionsPtr(aItem^.nContent)^.nConditions,
                       Str2CorrectnessKind(GetAttr(XMLAttrName[atCondition])));
               NextElementState;
            end;
            NextElementState;
            CorrectnessConditionPtr(aItem^.nContent)^.nJustification:=Read_Justification;
         end;
      itProperty:
         aItem^.nContent:=new(PropertyPtr,Init(lPos,Str2PropertyKind(aShape),Read_Justification));
      itConclusion,
      itRegularStatement:
         aItem^.nContent:=Read_RegularStatement(aShape);
      itCaseHead,itSupposeHead,
      itAssumption:
         if nState= eStart then
            if nElName = AssumptionKindName[SingleAssumption] then
            begin
               lPos:=GetAttrPos;
               NextElementState;
               aItem^.nContent:=new(SingleAssumptionPtr,Init(lPos,Read_Proposition));
               NextElementState;
            end
            else if nElName = AssumptionKindName[CollectiveAssumption] then
            begin
               lPos:=GetAttrPos;
               NextElementState;
               aItem^.nContent:=new(CollectiveAssumptionPtr,Init(lPos,new(PList,Init(0))));
               NextElementState;
               while (nState = eStart) and (nElName = XMLElemName[elProposition]) do
                  CollectiveAssumptionPtr(aItem^.nContent)^.nConditions^.Insert(Read_Proposition);
               NextElementState;
               NextElementState;
            end;
      itExistentialAssumption:
         begin
            aItem^.nContent:=new(ExistentialAssumptionPtr,Init(lPos,new(PList,Init(0)),new(PList,Init(0))));
            while (nState = eStart) and
                     ((nElName = SegmentKindName[ikImplQualifiedSegm]) or
                         (nElName = SegmentKindName[ikExplQualifiedSegm])) do
               ExistentialAssumptionPtr(aItem^.nContent)^.nQVars^.Insert(Read_VariableSegment);
            NextElementState;
            while (nState = eStart) and (nElName = XMLElemName[elProposition]) do
               ExistentialAssumptionPtr(aItem^.nContent)^.nConditions^.Insert(Read_Proposition);
            NextElementState;
         end;
      itExemplification:
         begin
            lVar:=nil;
            if (nState = eStart) and (nElName = XMLElemName[elVariable]) then
               lVar:=Read_Variable;
            lTrm:=nil;
            if nState <> eEnd then
               lTrm:=Read_Term;
            aItem^.nContent:=new(ExamplePtr,Init(lVar,lTrm));
         end;
      itDefPred:
         begin
            lRedefinition:=false;
            if (nState= eStart) and (nElName = XMLElemName[elRedefine]) then
            begin
               NextElementState;
               NextElementState;
               lRedefinition:=true;
            end;
            lPattern:=Read_PredicatePattern;
            aItem^.nContent:=new(PredicateDefinitionPtr,
                                 Init(lPos,lRedefinition,PredicatePatternPtr(lPattern),
                                      Read_Definiens));
         end;
      itDefFunc:
         begin
            lRedefinition:=false;
            if (nState= eStart) and (nElName = XMLElemName[elRedefine]) then
            begin
               NextElementState;
               NextElementState;
               lRedefinition:=true;
            end;
            lPattern:=Read_FunctorPattern;
            lType:=nil;
            if (nState= eStart) and (nElName = XMLElemName[elTypeSpecification]) then
            begin
               NextElementState;
               lType:=Read_Type;
               NextElementState;
            end;
            if aShape = DefiningWayName[dfMeans] then
               lDef:=dfMeans
            else if aShape = DefiningWayName[dfEquals] then
               lDef:=dfEquals
            else lDef:=dfEmpty;
            case lDef of
               dfEquals:
                  aItem^.nContent:=new(FunctorDefinitionPtr,
                                       Init(lPos,lRedefinition,FunctorPatternPtr(lPattern),
                                            lType,lDef,Read_Definiens));
               dfMeans:
                  aItem^.nContent:=new(FunctorDefinitionPtr,
                                       Init(lPos,lRedefinition,FunctorPatternPtr(lPattern),
                                            lType,lDef,Read_Definiens));
               dfEmpty:
                  aItem^.nContent:=new(FunctorDefinitionPtr,
                                       Init(lPos,lRedefinition,FunctorPatternPtr(lPattern),
                                            lType,lDef,nil));

            endcases;
         end;
      itDefMode:
         begin
            lRedefinition:=false;
            if (nState= eStart) and (nElName = XMLElemName[elRedefine]) then
            begin
               NextElementState;
               NextElementState;
               lRedefinition:=true;
            end;
            lPattern:=Read_ModePattern;
            if (nState= eStart) and (nElName = ModeDefinitionSortName[defExpandableMode]) then
            begin
               NextElementState;
               aItem^.nContent:=new(ExpandableModeDefinitionPtr,Init(CurPos,ModePatternPtr(lPattern),Read_Type));
               NextElementState;
            end
            else if (nState= eStart) and (nElName = ModeDefinitionSortName[defStandardMode]) then
            begin
               NextElementState;
               lType:=nil;
               if (nState= eStart) and (nElName = XMLElemName[elTypeSpecification]) then
               begin
                  NextElementState;
                  lType:=Read_Type;
                  NextElementState;
               end;
               aItem^.nContent:=new(StandardModeDefinitionPtr,Init(CurPos,lRedefinition,ModePatternPtr(lPattern),
                                                                   lType,Read_Definiens));
               NextElementState;
            end;
         end;
      itDefAttr:
         begin
            lRedefinition:=false;
            if (nState= eStart) and (nElName = XMLElemName[elRedefine]) then
            begin
               NextElementState;
               NextElementState;
               lRedefinition:=true;
            end;
            lPattern:=Read_AttributePattern;
            aItem^.nContent:=new(AttributeDefinitionPtr,Init(CurPos,lRedefinition,AttributePatternPtr(lPattern),
                                                             Read_Definiens));
         end;
      itDefStruct:
         begin
            NextElementState;
            lTyps:=new(PList,Init(0));
            while nState <> eEnd do
               lTyps^.Insert(Read_Type);
            NextElementState;
            lPos:=GetAttrPos;
            lNr:=GetIntAttr(XMLAttrName[atNr]);
            NextElementState;
            lList:=nil;
            if (nState = eStart) and (nElName = XMLElemName[elLoci]) then
               lList:=Read_Loci;
            lFields:=new(PList,Init(0));
            while (nState = eStart) and (nElName = XMLElemName[elFieldSegment]) do
            begin
               lFieldSgmPos:=GetAttrPos;
               NextElementState;
               lSels:=new(PList,Init(0));
               while (nState = eStart) and (nElName = XMLElemName[elSelector]) do
               begin
                  lSels^.Insert(new(FieldSymbolPtr,Init(GetAttrPos,GetIntAttr(XMLAttrName[atNr]))));
                  NextElementState;
                  NextElementState;
               end;
               lFields^.Insert(new(FieldSegmentPtr,Init(lFieldSgmPos,lSels,Read_Type)));
               NextElementState;
            end;
            NextElementState;
            aItem^.nContent:=new(StructureDefinitionPtr,Init(lPos,lTyps,lNr,lList,lFields));
         end;
      itPredSynonym, itPredAntonym, itFuncNotation, itModeNotation,
      itAttrSynonym, itAttrAntonym:
         begin
            lPattern:=Read_Pattern;
            aItem^.nContent:= new(NotationDeclarationPtr,
                                  Init(lPos,aItem^.nItemKind,Read_Pattern,lPattern));
         end;
      itCluster:
         if nState= eStart then
            if nElName = ClusterRegistrationName[ExistentialRegistration] then
            begin
               lPos:=GetAttrPos;
               NextElementState;
               lList:=Read_AdjectiveList;
               aItem^.nContent:=new(EClusterPtr,Init(lPos,lList,Read_Type));
               NextElementState;
            end
            else if nElName = ClusterRegistrationName[ConditionalRegistration] then
            begin
               lPos:=GetAttrPos;
               NextElementState;
               lList:=Read_AdjectiveList;
               lCons:=Read_AdjectiveList;
               aItem^.nContent:=new(CClusterPtr,Init(lPos,lList,lCons,Read_Type));
               NextElementState;
            end
            else if nElName = ClusterRegistrationName[FunctorialRegistration] then
            begin
               lPos:=GetAttrPos;
               NextElementState;
               lTrm:=Read_Term;
               lCons:=Read_AdjectiveList;
               lType:=nil;
               if nState <> eEnd then
                  lType:=Read_Type;
               aItem^.nContent:=new(FClusterPtr,Init(lPos,lTrm,lCons,lType));
               NextElementState;
            end;
      itIdentify:
         begin
            lPattern:=Read_Pattern;
            aItem^.nContent:=new(IdentifyRegistrationPtr,Init(lPos,Read_Pattern,lPattern,
                                                              new(PList,Init(0))));
            while (nState = eStart) and (nElName = XMLElemName[elLociEquality]) do
            begin
               lPos:=GetAttrPos;
               NextElementState;
               lLocus:=Read_Locus;
               IdentifyRegistrationPtr(aItem^.nContent)^.nEqLociList^.Insert(new(LociEqualityPtr,Init(lPos,lLocus,Read_Locus)));
               NextElementState;
            end;
         end;
      itPropertyRegistration:
         begin
            lPropertySort:=Str2PropertyKind(aShape);
            case lPropertySort of
               sySethood:
                  begin
                     aItem^.nContent:=new(SethoodRegistrationPtr,Init(lPos,lPropertySort,Read_Type));
                     SethoodRegistrationPtr(aItem^.nContent)^.nJustification:=Read_Justification;
                  end;
            endcases;
         end;
      itReduction:
         begin
            lTrm:=Read_Term;
            aItem^.nContent:=new(ReduceRegistrationPtr,Init(lPos,Read_Term,lTrm));
         end;
      itPragma: ;
   endcases;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_TextProper: wsTextProperPtr;
var lPos: Position;
begin
   NextElementState;
   lPos.Line:=GetIntAttr( XMLAttrName[atLine]);
   lPos.Col:= GetIntAttr( XMLAttrName[atCol]);
   result:=new(wsTextProperPtr,Init(GetAttr(XMLAttrName[atArticleID]),
                                    GetAttr(XMLAttrName[atArticleExt]),lPos));
   if nDisplayInformationOnScreen then
      DisplayLine(result^.nBlockPos.Line,0);
   CurPos:=result^.nBlockPos;
   if (nState= eStart) and (nElName = BlockName[blMain]) then
   begin
      NextElementState;
      while (nState= eStart) and (nElName = XMLElemName[elItem]) do
         result^.nItems^.Insert(Read_Item);
   end;
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Block: wsBlockPtr;
var lPos: Position;
begin
   lPos.Line:=GetIntAttr( XMLAttrName[atLine]);
   lPos.Col:= GetIntAttr( XMLAttrName[atCol]);
   result:=new(WSBlockPtr,Init(Str2BlockKind(GetAttr(XMLAttrName[atKind])),lPos));
   if nDisplayInformationOnScreen then
      DisplayLine(result^.nBlockPos.Line,0);
   lPos.Line:=GetIntAttr( XMLAttrName[atPosLine]);
   lPos.Col:= GetIntAttr( XMLAttrName[atPosCol]);
   result^.nBlockEndPos:=lPos;
   CurPos:=result^.nBlockPos;
   NextElementState;
   while (nState= eStart) and (nElName = XMLElemName[elItem]) do
      result^.nItems^.Insert(Read_Item);
   CurPos:=result^.nBlockEndPos;
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function InWSMizFileObj.Read_Item: wsItemPtr;
var lStartTagNbr: integer;
lItemKind: ItemKind;
lShape: string;
lPos: Position;
begin
   lItemKind:=Str2ItemKind(GetAttr(XMLAttrName[atKind]));
   lPos.Line:=GetIntAttr( XMLAttrName[atLine]);
   lPos.Col:= GetIntAttr( XMLAttrName[atCol]);
   CurPos:=lPos;
   if nDisplayInformationOnScreen then
      DisplayLine(lPos.Line,0);
   result:=new(WSItemPtr,Init(lItemKind,lPos));
   lPos.Line:=GetIntAttr( XMLAttrName[atPosLine]);
   lPos.Col:= GetIntAttr( XMLAttrName[atPosCol]);
   result^.nItemEndPos:=lPos;
   result^.nContent:=nil;
   Read_ItemContentsAttr(result,lShape);
   NextElementState;
   lStartTagNbr := 0;
   if nState <> eEnd then
   begin
      Read_ItemContents(result,lShape);
      if (nState= eStart) and (nElName = XMLElemName[elBlock]) then
         result^.nBlock:=Read_Block
      else if result^.nContent = nil then
      begin
         repeat
            if nState = eStart then
               inc(lStartTagNbr)
            else dec(lStartTagNbr);
            NextElementState;
         until ((nState = eEnd) and (lStartTagNbr = 0)) or
            ((nState = eStart) and (nElName = XMLElemName[elBlock]));
         if (nState= eStart) and (nElName = XMLElemName[elBlock]) then
            result^.nBlock:=Read_Block;
      end;
   end;
   CurPos:=lPos;
   NextElementState;
end;
@

@<Implementation for \texttt{wsmarticle.pas}@>=
function Read_WSMizArticle(aFileName:string): wsTextProperPtr;
var lInFile: InWSMizFilePtr;
begin
   InitWSLookupTables;
   lInFile:=new(InWSMizFilePtr,OpenFile(aFileName));
   result:=lInFile^.Read_TextProper;
   dispose(lInFile,Done);
   DisposeWSLookupTables;
end;



@* [S] Prettyprinting WSM files (deferred).

@<Publicly declared types in \texttt{wsmarticle.pas}@>=
WSMizarPrinterPtr =  ^WSMizarPrinterObj; @/
WSMizarPrinterObj =
   object(TXTStreamObj) @t\1 @> @/
      nDisplayInformationOnScreen: boolean; @/
      nIndent:	integer;  {indenting}
      constructor OpenFile(const aFileName:string ); @t\2 @>
      destructor Done; virtual; @t\2 @>

      procedure Print_Char( AChar: char ); @t\2 @>
      procedure Print_NewLine; @t\2 @>
      procedure Print_Number( const aNumber: integer); @t\2 @>
      procedure Print_String( const aString: string); @t\2 @>
      procedure Print_Indent; @t\2 @>

      procedure Print_TextProper(aWSTextProper:WSTextProperPtr); virtual; @t\2 @>
      procedure Print_Item(aWSItem:WSItemPtr); virtual; @t\2 @>
      procedure Print_SchemeNameInSchemeHead(aSch: SchemePtr); virtual; @t\2 @>
      procedure Print_Block(aWSBlock:WSBlockPtr); virtual; @t\2 @>

      procedure Print_Adjective(aAttr:AdjectiveExpressionPtr ); virtual; @t\2 @>
      procedure Print_AdjectiveList( aCluster: PList ); virtual; @t\2 @>
      procedure Print_Variable( aVar: VariablePtr); virtual; @t\2 @>
      procedure Print_ImplicitlyQualifiedVariable( aSegm: ImplicitlyQualifiedSegmentPtr); virtual; @t\2 @>
      procedure Print_VariableSegment( aSegm: QualifiedSegmentPtr); virtual; @t\2 @>
      procedure Print_Type ( aTyp: TypePtr ); virtual; @t\2 @>
      procedure Print_BinaryFormula ( aFrm:BinaryFormulaPtr ); virtual; @t\2 @>
      procedure Print_PrivatePredicativeFormula ( aFrm: PrivatePredicativeFormulaPtr ); virtual; @t\2 @>
      procedure Print_Formula ( aFrm:FormulaPtr ); virtual; @t\2 @>
      procedure Print_OpenTermList ( aTrmList:PList ); virtual; @t\2 @>
      procedure Print_TermList ( aTrmList:PList ); virtual; @t\2 @>
      procedure Print_SimpleTermTerm ( aTrm: SimpleTermPtr ); virtual; @t\2 @>
      procedure Print_PrivateFunctorTerm ( aTrm: PrivateFunctorTermPtr ); virtual; @t\2 @>
      procedure Print_Term ( aTrm: TermPtr ); virtual; @t\2 @>

      procedure Print_TypeList ( aTypeList: PList ); virtual; @t\2 @>

      procedure Print_Label(aLab:LabelPtr); virtual; @t\2 @>

      procedure Print_Reference(aRef: LocalReferencePtr); virtual; @t\2 @>
      procedure Print_References(aRefs: PList); virtual; @t\2 @>
      procedure Print_StraightforwardJustification(aInf: StraightforwardJustificationPtr); virtual; @t\2 @>
      procedure Print_SchemeNameInJustification(aInf: SchemeJustificationPtr); virtual; @t\2 @>
      procedure Print_SchemeJustification(aInf: SchemeJustificationPtr); virtual; @t\2 @>
      procedure Print_Justification(aInf: JustificationPtr; aBlock:wsBlockPtr); virtual; @t\2 @>
      procedure Print_Linkage; virtual; @t\2 @>
      procedure Print_RegularStatement(aRStm:RegularStatementPtr; aBlock:wsBlockPtr); virtual; @t\2 @>
      procedure Print_CompactStatement(aCStm:CompactStatementPtr; aBlock:wsBlockPtr); virtual; @t\2 @>
      procedure Print_Proposition(aProp:PropositionPtr); virtual; @t\2 @>

      procedure Print_Conditions(aCond: PList); @t\2 @>
      procedure Print_AssumptionConditions(aCond: AssumptionPtr); virtual; @t\2 @>

      procedure Print_Pattern(aPattern: PatternPtr); virtual; @t\2 @>
      procedure Print_Locus( aLocus: LocusPtr); virtual; @t\2 @>
      procedure Print_Loci( aLoci: PList); virtual; @t\2 @>
      procedure Print_Definiens(aDef:DefiniensPtr); virtual; @t\2 @>

      procedure Print_ReservedType(aResType: TypePtr); virtual; @t\2\2\2 @>
   end;


@ \node{Constructor.}

@<Implementation for \texttt{wsmarticle.pas}@>=
constructor WSMizarPrinterObj.OpenFile(const aFileName:string);
begin
   inherited InitFile(AFileName);
   rewrite(nFile);
   nIndent := 0;
   nDisplayInformationOnScreen:=false;
end;

destructor WSMizarPrinterObj.Done;
begin
   close(nFile);
   inherited Done;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Char ( aChar: char );
begin
   write(nFile,aChar);
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_NewLine;
begin
   writeln(nFile);
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Number( const aNumber: integer);
begin
   write(nFile,aNumber);
   Print_Char(' ');
end;

@ The comment is translated from the Polish comment ``{?? czy na pewno
trzeba robic konwersje}'', so I may be mistranslating.

@<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_String ( const aString: string );
var i: integer;
begin
   write(nFile,XMLToStr(aString)); {Do you really need to do conversions?}
   Print_Char(' ');
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Indent;
var i:integer;
begin
   for i:=1 to nIndent do Print_Char(' ');
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Adjective(aAttr:AdjectiveExpressionPtr);
begin
   case aAttr^.nAdjectiveSort of
      wsAdjective:
         with AdjectivePtr(aAttr)^ do
      begin
         if  nArgs^.Count <> 0 then
            Print_TermList( nArgs );
         Print_String(AttributeName[nAdjectiveSymbol]);
      end;
      wsNegatedAdjective:
         begin
            Print_String(TokenName[sy_Non]);
            Print_Adjective(NegatedAdjectivePtr(aAttr)^.nArg);
         end;
   endcases;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_AdjectiveList(aCluster: PList);
var i: integer;
begin
   with aCluster^ do
      for i:=0 to Count-1 do
      begin
         Print_Adjective( Items^[i]);
      end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Variable( aVar: VariablePtr);
begin
   with aVar ^ do
   begin
      Print_String(IdentRepr(nIdent));
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_ImplicitlyQualifiedVariable( aSegm: ImplicitlyQualifiedSegmentPtr);
begin
   Print_Variable( aSegm^.nIdentifier);
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_VariableSegment( aSegm: QualifiedSegmentPtr);
var i: integer;
begin
   case aSegm^.nSegmentSort of
      ikImplQualifiedSegm:
         Print_ImplicitlyQualifiedVariable( ImplicitlyQualifiedSegmentPtr(aSegm));
      ikExplQualifiedSegm:
         with ExplicitlyQualifiedSegmentPtr(aSegm)^ do
      begin
         Print_Variable( nIdentifiers.Items^[0]);
         for i:=1 to nIdentifiers^.Count-1 do
         begin
            Print_String(',');
            Print_Variable( nIdentifiers^.Items^[i]);
         end;
         Print_String(TokenName[sy_Be]);
         Print_Type(nType);
      end;
   endcases;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_OpenTermList ( aTrmList:PList );
var i: integer;
begin
   if aTrmList^.Count > 0 then
   begin
      Print_Term(aTrmList^.Items^[0]);
      for i:=1 to aTrmList^.Count-1 do
      begin
         Print_String(',');
         Print_Term(aTrmList^.Items^[i]);
      end;
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_TermList ( aTrmList:PList );
var i: integer;
begin
   if aTrmList^.Count > 0 then
   begin
      Print_String('(');
      Print_Term(aTrmList^.Items^[0]);
      for i:=1 to aTrmList^.Count-1 do
      begin
         Print_String(',');
         Print_Term(aTrmList^.Items^[i]);
      end;
      Print_String(')');
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Type ( aTyp: TypePtr);
begin
   with aTyp^ do
   begin
      case aTyp^.nTypeSort of
         wsStandardType:
            with StandardTypePtr(aTyp)^ do
         begin
            if  nArgs^.Count = 0 then
               Print_String(ModeName[nModeSymbol])
            else
            begin
               Print_String('(');
               Print_String(ModeName[nModeSymbol]);
               Print_String(TokenName[sy_Of]);
               Print_OpenTermList(nArgs);
               Print_String(')');
            end;
         end;
         wsStructureType:
            with StructTypePtr(aTyp)^ do
         begin
            if  nArgs^.Count = 0 then
               Print_String(StructureName[nStructSymbol])
            else
            begin
               Print_String('(');
               Print_String(StructureName[nStructSymbol]);
               Print_String(TokenName[sy_Over]);
               Print_OpenTermList(nArgs);
               Print_String(')');
            end;
         end;
         wsClusteredType:
            with ClusteredTypePtr(aTyp)^ do
         begin
            Print_AdjectiveList(nAdjectiveCluster);
            Print_Type(nType);
         end;
         wsErrorType:
            begin
            end;
      endcases;
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_BinaryFormula ( aFrm:BinaryFormulaPtr );
begin
   Print_String('(');
   Print_Formula(aFrm^.nLeftArg);
   case aFrm^.nFormulaSort of
      wsConjunctiveFormula: Print_String(TokenName[sy_Ampersand]);
      wsDisjunctiveFormula: Print_String(TokenName[sy_Or]);
      wsConditionalFormula: Print_String(TokenName[sy_Implies]);
      wsBiconditionalFormula: Print_String(TokenName[sy_Iff]);
      wsFlexaryConjunctiveFormula:
         begin
            Print_String(TokenName[sy_Ampersand]);
            Print_String(TokenName[sy_Ellipsis]);
            Print_String(TokenName[sy_Ampersand]);
         end;
      wsFlexaryDisjunctiveFormula:
         begin
            Print_String(TokenName[sy_Or]);
            Print_String(TokenName[sy_Ellipsis]);
            Print_String(TokenName[sy_Or]);
         end;
   endcases;
   Print_Formula(aFrm^.nRightArg);
   Print_String(')');
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_PrivatePredicativeFormula ( aFrm: PrivatePredicativeFormulaPtr );
begin
   with PrivatePredicativeFormulaPtr(aFrm)^ do
   begin
      Print_String(IdentRepr(nPredIdNr));
      Print_String('[');
      Print_OpenTermList( nArgs);
      Print_String(']');
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Formula ( aFrm: FormulaPtr );
var i: Integer;
lNeg: boolean;
lFrm: FormulaPtr;
begin
   case aFrm^.nFormulaSort of
      wsNegatedFormula:
         begin
            Print_String(TokenName[sy_Not]);
            Print_Formula(NegativeFormulaPtr(aFrm)^.nArg);
         end;
      wsConjunctiveFormula,wsDisjunctiveFormula,
      wsConditionalFormula,wsBiconditionalFormula,
      wsFlexaryConjunctiveFormula,wsFlexaryDisjunctiveFormula:
         Print_BinaryFormula(BinaryFormulaPtr(aFrm));
      wsPredicativeFormula:
         with PredicativeFormulaPtr(aFrm)^ do
      begin
         Print_String('(');
         if nLeftArgs^.Count <> 0 then
         begin
            Print_OpenTermList( nLeftArgs);
         end;
         Print_String(PredicateName[nPredNr]);
         if nRightArgs^.Count <> 0 then
         begin
            Print_OpenTermList( nRightArgs);
         end;
         Print_String(')');
      end;
      wsMultiPredicativeFormula:
         with MultiPredicativeFormulaPtr(aFrm)^ do
      begin
         Print_String('(');
         lFrm:=nScraps.Items^[0];
         lNeg:=lFrm^.nFormulaSort = wsNegatedFormula;
         if lNeg then
            lFrm:=NegativeFormulaPtr(lFrm)^.nArg;
         with PredicativeFormulaPtr(lFrm)^ do
         begin
            if nLeftArgs^.Count <> 0 then
               Print_OpenTermList( nLeftArgs);
            if lNeg then
            begin
               Print_String(TokenName[sy_Does]);
               Print_String(TokenName[sy_Not]);
            end;
            Print_String(PredicateName[nPredNr]);
            if nRightArgs^.Count <> 0 then
               Print_OpenTermList( nRightArgs);
         end;
         for i:=1 to nScraps.Count - 1 do
         begin
            lFrm:=nScraps.Items^[i];
            lNeg:=lFrm^.nFormulaSort = wsNegatedFormula;
            if lNeg then
               lFrm:=NegativeFormulaPtr(lFrm)^.nArg;
            with RightSideOfPredicativeFormulaPtr(lFrm)^ do
            begin
               if lNeg then
               begin
                  Print_String(TokenName[sy_Does]);
                  Print_String(TokenName[sy_Not]);
               end;
               Print_String(PredicateName[nPredNr]);
               if nRightArgs^.Count <> 0 then
                  Print_OpenTermList( nRightArgs);
            end;
         end;
         Print_String(')');
      end;
      wsPrivatePredicateFormula:
         Print_PrivatePredicativeFormula ( PrivatePredicativeFormulaPtr(aFrm));
      wsAttributiveFormula:
         with AttributiveFormulaPtr(aFrm)^ do
      begin
         Print_String('(');
         Print_Term(nSubject);
         Print_String(TokenName[sy_Is]);
         Print_AdjectiveList(nAdjectives);
         Print_String(')');
      end;
      wsQualifyingFormula:
         with QualifyingFormulaPtr(aFrm)^ do
      begin
         Print_String('(');
         Print_Term(nSubject);
         Print_String(TokenName[sy_Is]);
         Print_Type(nType);
         Print_String(')');
      end;
      wsUniversalFormula:
         with QuantifiedFormulaPtr( aFrm)^ do
      begin
         Print_String('(');
         Print_String(TokenName[sy_For]);
         Print_VariableSegment(QuantifiedFormulaPtr(aFrm)^.nSegment);
         Print_String(TokenName[sy_Holds]);
         Print_Formula(QuantifiedFormulaPtr(aFrm)^.nScope);
         Print_String(')');
      end;
      wsExistentialFormula:
         with QuantifiedFormulaPtr( aFrm)^ do
      begin
         Print_String('(');
         Print_String(TokenName[sy_Ex]);
         Print_VariableSegment(QuantifiedFormulaPtr(aFrm)^.nSegment);
         Print_String(TokenName[sy_St]);
         Print_Formula(QuantifiedFormulaPtr(aFrm)^.nScope);
         Print_String(')');
      end;
      wsContradiction:
         begin
            Print_String(TokenName[sy_Contradiction]);
         end;
      wsThesis:
         begin
            Print_String(TokenName[sy_Thesis]);
         end;
      wsErrorFormula:
         begin
         end;
   endcases;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_SimpleTermTerm ( aTrm: SimpleTermPtr );
begin
   Print_String(IdentRepr(SimpleTermPtr(aTrm)^.nIdent));
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_PrivateFunctorTerm ( aTrm: PrivateFunctorTermPtr );
begin
   Print_String(IdentRepr(aTrm^.nFunctorIdent));
   Print_String('(');
   Print_OpenTermList(aTrm^.nArgs);
   Print_String(')');
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Term ( aTrm: TermPtr );
var i,j: integer;
lPrintWhere: boolean;
begin
   case aTrm^.nTermSort of
      wsPlaceholderTerm:
         begin
            Print_Char('$');
            Print_Number(PlaceholderTermPtr(aTrm)^.nLocusNr);
         end;
      wsSimpleTerm:
         begin
            Print_SimpleTermTerm(SimpleTermPtr(aTrm));
         end;
      wsNumeralTerm:
         begin
            Print_Number(NumeralTermPtr(aTrm)^.nValue);
         end;
      wsInfixTerm:
         with InfixTermPtr(aTrm)^ do
      begin
         Print_String('(');
         if nLeftArgs^.Count <> 0 then
         begin
            Print_TermList( nLeftArgs);
         end;
         Print_String(FunctorName[nFunctorSymbol]);
         if nRightArgs^.Count <> 0 then
         begin
            Print_TermList( nRightArgs);
         end;
         Print_String(')');
      end;
      wsCircumfixTerm:
         with CircumfixTermPtr(aTrm)^ do
      begin
         Print_String(LeftBracketName[nLeftBracketSymbol]);
         Print_OpenTermList(nArgs);
         Print_String(RightBracketName[nRightBracketSymbol]);
      end;
      wsPrivateFunctorTerm:
         Print_PrivateFunctorTerm(PrivateFunctorTermPtr(aTrm));
      wsAggregateTerm:
         with AggregateTermPtr(aTrm)^ do
      begin
         Print_String(StructureName[nStructSymbol]);
         Print_String(TokenName[sy_StructLeftBracket]);
         Print_OpenTermList( nArgs);
         Print_String(TokenName[sy_StructRightBracket]);
      end;
      wsSelectorTerm:
         with SelectorTermPtr(aTrm)^ do
      begin
         Print_String('(');
         Print_String(TokenName[sy_The]);
         Print_String(SelectorName[nSelectorSymbol]);
         Print_String(TokenName[sy_Of]);
         Print_Term( nArg);
         Print_String(')');
      end;
      wsInternalSelectorTerm:
         with InternalSelectorTermPtr(aTrm)^ do
      begin
         Print_String(TokenName[sy_The]);
         Print_String(SelectorName[nSelectorSymbol]);
      end;
      wsForgetfulFunctorTerm:
         with ForgetfulFunctorTermPtr(aTrm)^ do
      begin
         Print_String('(');
         Print_String(TokenName[sy_The]);
         Print_String(StructureName[nStructSymbol]);
         Print_String(TokenName[sy_Of]);
         Print_Term( nArg);
         Print_String(')');
      end;
      wsInternalForgetfulFunctorTerm:
         with InternalForgetfulFunctorTermPtr(aTrm)^ do
      begin
         Print_String('(');
         Print_String(TokenName[sy_The]);
         Print_String(StructureName[nStructSymbol]);
         Print_String(')');
      end;
      wsFraenkelTerm:
         with FraenkelTermPtr(aTrm)^ do
      begin
         Print_String('{');
         Print_Term(nSample);
         if nPostqualification^.Count > 0 then
         begin
            lPrintWhere:=true;
            for i := 0 to nPostqualification^.Count - 1 do
               case QualifiedSegmentPtr(nPostqualification^.Items^[i])^.nSegmentSort of
                  ikImplQualifiedSegm:
                     with ImplicitlyQualifiedSegmentPtr(nPostqualification^.Items^[i])^ do
                  begin
                     Print_String(TokenName[sy_Where]);
                     Print_Variable( nIdentifier);
                  end;
                  ikExplQualifiedSegm:
                     with ExplicitlyQualifiedSegmentPtr(nPostqualification^.Items^[i])^ do
                  begin
                     if lPrintWhere then
                     begin
                        Print_String(TokenName[sy_Where]);
                        lPrintWhere:=false;
                     end;
                     Print_Variable( nIdentifiers.Items^[0]);
                     for j:=1 to nIdentifiers^.Count-1 do
                     begin
                        Print_String(',');
                        Print_Variable( nIdentifiers^.Items^[j]);
                     end;
                     Print_String(TokenName[sy_Is]);
                     Print_Type(nType);
                     if i < nPostqualification^.Count - 1 then Print_String(',');
                  end;
               endcases;
         end;
         Print_String(':');
         Print_Formula(nFormula);
         Print_String('}');
      end;
      wsSimpleFraenkelTerm:
         with SimpleFraenkelTermPtr(aTrm)^ do
      begin
         Print_String('(');
         Print_String(TokenName[sy_The]);
         Print_String(TokenName[sy_Set]);
         Print_String(TokenName[sy_Of]);
         Print_String(TokenName[sy_All]);
         Print_Term(nSample);
         if nPostqualification^.Count > 0 then
         begin
            lPrintWhere:=true;
            for i := 0 to nPostqualification^.Count - 1 do
               case QualifiedSegmentPtr(nPostqualification^.Items^[i])^.nSegmentSort of
                  ikImplQualifiedSegm:
                     with ImplicitlyQualifiedSegmentPtr(nPostqualification^.Items^[i])^ do
                  begin
                     Print_String(TokenName[sy_Where]);
                     Print_Variable( nIdentifier);
                  end;
                  ikExplQualifiedSegm:
                     with ExplicitlyQualifiedSegmentPtr(nPostqualification^.Items^[i])^ do
                  begin
                     if lPrintWhere then
                     begin
                        Print_String(TokenName[sy_Where]);
                        lPrintWhere:=false;
                     end;
                     Print_Variable( nIdentifiers.Items^[0]);
                     for j:=1 to nIdentifiers^.Count-1 do
                     begin
                        Print_String(',');
                        Print_Variable( nIdentifiers^.Items^[j]);
                     end;
                     Print_String(TokenName[sy_Is]);
                     Print_Type(nType);
                     if i < nPostqualification^.Count - 1 then Print_String(',');
                  end;
               endcases;
         end;
         Print_String(')');
      end;
      wsQualificationTerm:
         with QualifiedTermPtr(aTrm)^ do
      begin
         Print_String('(');
         Print_Term(nSubject);
         Print_String(TokenName[sy_Qua]);
         Print_Type(nQualification);
         Print_String(')');
      end;
      wsExactlyTerm:
         with ExactlyTermPtr(aTrm)^ do
      begin
         Print_Term(nSubject);
         Print_String(TokenName[sy_Exactly]);
      end;
      wsGlobalChoiceTerm:
         begin
            Print_String('(');
            Print_String(TokenName[sy_The]);
            Print_Type(ChoiceTermPtr(aTrm)^.nChoiceType);
            Print_String(')');
         end;
      wsItTerm:
         begin
            Print_String(TokenName[sy_It]);
         end;
      wsErrorTerm:
   endcases;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_TypeList ( aTypeList:PList );
var i: integer;
begin
   if aTypeList^.Count > 0 then
   begin
      Print_Type(aTypeList^.Items^[0]);
      for i:=1 to aTypeList^.Count-1 do
      begin
         Print_String(',');
         Print_Type(aTypeList^.Items^[i]);
      end;
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Label(aLab:LabelPtr);
begin
   if (aLab <> nil) and (aLab.nLabelIdNr > 0) then
   begin
      Print_String(IdentRepr(aLab^.nLabelIdNr));
      Print_String(':');
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Proposition(aProp:PropositionPtr);
begin
   Print_Label(aProp^.nLab);
   Print_Formula(aProp^.nSentence);
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_CompactStatement(aCStm:CompactStatementPtr; aBlock:wsBlockPtr);
begin
   with aCStm^ do
   begin
      Print_Proposition(nProp);
      Print_Justification(nJustification,aBlock);
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Linkage;
begin
   Print_String(TokenName[sy_Then]);
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_RegularStatement(aRStm:RegularStatementPtr; aBlock:wsBlockPtr);
var i: integer;
begin
   case aRStm^.nStatementSort of
      stDiffuseStatement:
         begin
            Print_Label(DiffuseStatementPtr(aRStm)^.nLab);
            Print_Block(aBlock);
         end;
      stCompactStatement:
         begin
            if (CompactStatementPtr(aRStm)^.nJustification^.nInfSort = infStraightforwardJustification) and
                  StraightforwardJustificationPtr(CompactStatementPtr(aRStm)^.nJustification)^.nLinked then
            begin
               Print_Linkage;
            end;
            Print_CompactStatement(CompactStatementPtr(aRStm),aBlock);
         end;
      stIterativeEquality:
         begin
            if (CompactStatementPtr(aRStm)^.nJustification^.nInfSort = infStraightforwardJustification) and
                  StraightforwardJustificationPtr(CompactStatementPtr(aRStm)^.nJustification)^.nLinked then
            begin
               Print_Linkage;
            end;
            Print_CompactStatement(CompactStatementPtr(aRStm),nil);
            with IterativeEqualityPtr(aRStm)^ do
               for i := 0 to nIterSteps^.Count - 1 do
                  with IterativeStepPtr(nIterSteps^.Items^[i])^ do
               begin
                  Print_NewLine;
                  Print_String(TokenName[sy_DotEquals]);
                  Print_Term(nTerm);
                  Print_Justification(nJustification,nil);
               end;
         end;
   endcases;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Reference(aRef: LocalReferencePtr);
begin
   Print_String(IdentRepr(aRef^.nLabId));
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_References(aRefs: PList);
var i: integer;
begin
   for i:= 0 to aRefs^.Count-1 do
      with ReferencePtr(aRefs^.Items^[i])^ do
   begin
      case nRefSort of
         LocalReference:
            begin
               Print_Reference(aRefs^.Items^[i]);
            end;
         TheoremReference:
            begin
               Print_String(MMLIdentifierName[TheoremReferencePtr(aRefs^.Items^[i])^.nArticleNr]);
               Print_String(':');
               Print_Number(TheoremReferencePtr(aRefs^.Items^[i])^.nTheoNr);
            end;
         DefinitionReference:
            begin
               Print_String(MMLIdentifierName[DefinitionReferencePtr(aRefs^.Items^[i])^.nArticleNr]);
               Print_String(':');
               Print_String('def');
               Print_Number(DefinitionReferencePtr(aRefs^.Items^[i])^.nDEfNr);
            end;
      endcases;
      if i < aRefs^.Count-1 then
         Print_String(',');
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_StraightforwardJustification(aInf: StraightforwardJustificationPtr);
begin
   with aInf^ do
   begin
      if nReferences^.Count <> 0 then
      begin
         Print_String(TokenName[sy_By]);
         Print_References(nReferences);
      end;
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_SchemeNameInJustification(aInf: SchemeJustificationPtr);
begin
   Print_String(IdentRepr(aInf^.nSchemeIdNr));
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_SchemeJustification(aInf: SchemeJustificationPtr);
begin
   with aInf^ do
   begin
      Print_String(TokenName[sy_From]);
      if nSchFileNr > 0 then
      begin
         Print_String(MMLIdentifierName[nSchFileNr]);
         Print_String(':');
         Print_String('sch');
         Print_Number(nSchemeIdNr);
      end
      else if nSchemeIdNr > 0 then
         Print_SchemeNameInJustification(aInf);
      if nReferences^.Count > 0 then
      begin
         Print_String('(');
         Print_References(nReferences);
         Print_String(')');
      end;
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Justification(aInf: JustificationPtr; aBlock:wsBlockPtr);
begin
   case aInf^.nInfSort of
      infStraightforwardJustification:
         Print_StraightforwardJustification(StraightforwardJustificationPtr(aInf));
      infSchemeJustification:
         Print_SchemeJustification(SchemeJustificationPtr(aInf));
      infError,infSkippedProof:
         begin
         end;
      infProof:
         Print_Block(aBlock);
   endcases;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Conditions(aCond: PList);
var i: integer;
begin
   Print_String(TokenName[sy_That]);
   Print_NewLine;
   Print_Proposition(aCond^.Items^[0]);
   for i:=1 to aCond^.Count-1 do
   begin
      Print_String(TokenName[sy_And]);
      Print_NewLine;
      Print_Proposition(aCond^.Items^[i]);
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_AssumptionConditions(aCond: AssumptionPtr);
begin
   case aCond^.nAssumptionSort of
      SingleAssumption:
         begin
            Print_Proposition(SingleAssumptionPtr(aCond)^.nProp);
         end;
      CollectiveAssumption:
         begin
            Print_Conditions(CollectiveAssumptionPtr(aCond)^.nConditions);
         end;
   endcases;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Locus( aLocus: LocusPtr);
begin
   with aLocus ^ do
   begin
      Print_String(IdentRepr(nVarId));
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Loci( aLoci: PList);
var i: integer;
begin
   if (aLoci = nil) or (aLoci^.Count = 0) then
   else
   begin
      Print_Locus(aLoci^.Items^[0]);
      for i:=1 to aLoci^.Count-1 do
      begin
         Print_String(',');
         Print_Locus(aLoci^.Items^[i]);
      end;
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Pattern(aPattern: PatternPtr);
begin
   case aPattern^.nPatternSort of
      itDefPred:
         with PredicatePatternPtr(aPattern)^ do
      begin
         Print_Loci(nLeftArgs);
         Print_String(PredicateName[nPredSymbol]);
         Print_Loci(nRightArgs);
      end;
      itDefFunc:
         begin
            case FunctorPatternPtr(aPattern)^.nFunctKind of
               InfixFunctor:
                  with InfixFunctorPatternPtr(aPattern)^ do
               begin
                  if (nLeftArgs <> nil) and (nLeftArgs^.Count >1) then
                     Print_String('(');
                  Print_Loci(nLeftArgs);
                  if (nLeftArgs <> nil) and (nLeftArgs^.Count >1) then
                     Print_String(')');
                  Print_String(FunctorName[nOperSymb]);
                  if (nRightArgs <> nil) and (nRightArgs^.Count >1) then
                     Print_String('(');
                  Print_Loci(nRightArgs);
                  if (nRightArgs <> nil) and (nRightArgs^.Count >1) then
                     Print_String(')');
               end;
               CircumfixFunctor:
                  with CircumfixFunctorPatternPtr(aPattern)^ do
               begin
                  Print_String(LeftBracketName[nLeftBracketSymb]);
                  Print_Loci(nArgs);
                  Print_String(RightBracketName[nRightBracketSymb]);
               end;
            endcases;
         end;
      itDefMode:
         with ModePatternPtr(aPattern)^ do
      begin
         Print_String(ModeName[nModeSymbol]);
         if (nArgs <> nil) and (nArgs^.Count > 0) then
         begin
            Print_String(TokenName[sy_Of]);
            Print_Loci(nArgs);
         end;
      end;
      itDefAttr:
         with AttributePatternPtr(aPattern)^ do
      begin
         Print_Locus(nArg);
         Print_String(TokenName[sy_Is]);
         Print_Loci(nArgs);
         Print_String(AttributeName[nAttrSymbol]);
      end;
   endcases;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Definiens(aDef:DefiniensPtr);
var i: integer;
begin
   if aDef <> nil then
      with DefiniensPtr(aDef)^ do
   begin
      case nDefSort of
         SimpleDefiniens:
            begin
               if (nDefLabel <> nil) and (nDefLabel^.nLabelIdNr > 0) then
               begin
                  Print_String(':');
                  Print_Label(nDefLabel);
               end;
               with SimpleDefiniensPtr(aDef)^,nExpression^ do
               case nExprKind of
                  exTerm: Print_Term(TermPtr(nExpr));
                  exFormula: Print_Formula(FormulaPtr(nExpr));
               endcases;
            end;
         ConditionalDefiniens:
            begin
               if (nDefLabel <> nil) and (nDefLabel^.nLabelIdNr > 0) then
               begin
                  Print_String(':');
                  Print_Label(nDefLabel);
               end;
               with ConditionalDefiniensPtr(aDef)^ do
               begin
                  for i:=0 to nConditionalDefiniensList^.Count-1 do
                  begin
                     with PartDefPtr(nConditionalDefiniensList^.Items^[I])^ do
                     begin
                        with nPartDefiniens^ do
                           case nExprKind of
                              exTerm: Print_Term(TermPtr(nExpr));
                              exFormula: Print_Formula(FormulaPtr(nExpr));
                           endcases;
                        Print_String(TokenName[sy_If]);
                        Print_Formula(nGuard);
                     end;
                     if (i>=0) and (i<nConditionalDefiniensList^.Count-1) then
                     begin
                        Print_String(',');
                        Print_NewLine;
                     end;
                  end;
                  if nOtherwise <> nil then
                     with nOtherwise^ do
                  begin
                     Print_String(TokenName[sy_Otherwise]);
                     case nExprKind of
                        exTerm: Print_Term(TermPtr(nExpr));
                        exFormula: Print_Formula(FormulaPtr(nExpr));
                     endcases;
                  end;
               end;
            end;
      end;
   endcases;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Block(aWSBlock:WSBlockPtr);
var i,lIndent: integer;
begin
   with aWSBlock^ do
   begin
      lIndent:=nIndent;
      Print_NewLine;
      Print_Indent;
      case nBlockKind of
         blDiffuse:
            begin
               Print_String(TokenName[sy_Now]);
               Print_NewLine;
            end;
         blHereby:
            begin
               Print_String(TokenName[sy_Now]);
               Print_NewLine;
            end;
         blProof:
            begin
               Print_String(TokenName[sy_Proof]);
               Print_NewLine;
            end;
         blDefinition:
            begin
               Print_String(TokenName[sy_Definition]);
               Print_NewLine;
            end;
         blNotation:
            begin
               Print_String(TokenName[sy_Notation]);
               Print_NewLine;
            end;
         blRegistration:
            begin
               Print_String(TokenName[sy_Registration]);
               Print_NewLine;
            end;
         blCase:
            Print_String(TokenName[sy_Case]);
         blSuppose:
            Print_String(TokenName[sy_Suppose]);
         blPublicScheme:
            ;
      endcases;
      for i := 0 to nItems^.Count - 1 do
      begin
         Print_Item(nItems^.Items^[i]);
      end;
      nIndent:=lIndent;
      Print_Indent;
      Print_String(TokenName[sy_End]);
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_TextProper(aWSTextProper:WSTextProperPtr);
var i: integer;
begin
   with aWSTextProper^ do
   begin
      for i := 0 to nItems^.Count - 1 do
         Print_Item(nItems^.Items^[i]);
   end;
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_ReservedType(aResType: TypePtr);
begin
   Print_Type(aResType);
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_SchemeNameInSchemeHead(aSch: SchemePtr);
begin
   Print_String(IdentRepr(aSch^.nSchemeIdNr));
end;

@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure WSMizarPrinterObj.Print_Item(aWSItem:WSItemPtr);
var i,j,lIndent: integer;
begin
   with aWSItem^ do
   begin
      CurPos:=nItemPos;
      if nDisplayInformationOnScreen then
         DisplayLine(CurPos.Line,ErrorNbr);
      case nItemKind of
         itDefinition:
            begin
               Print_Block(nBlock);
               Print_String(';');
               Print_NewLine;
            end;
         itSchemeBlock:
            begin
               Print_Block(nBlock);
               Print_String(';');
               Print_NewLine;
            end;
         itSchemeHead:
            with SchemePtr(nContent)^ do
         begin
            Print_String(TokenName[sy_Scheme]);
            Print_SchemeNameInSchemeHead(SchemePtr(nContent));
            Print_String('{');
            for j:=0 to nSchemeParams^.Count-1 do
            begin
               case SchemeSegmentPtr(nSchemeParams^.Items^[j])^.nSegmSort of
                  PredicateSegment:
                     with PredicateSegmentPtr(nSchemeParams^.Items^[j])^ do
                  begin
                     Print_Variable( nVars^.Items^[0]);
                     for i:=1 to nVars^.Count-1 do
                     begin
                        Print_String(',');
                        Print_Variable( nVars^.Items^[i]);
                     end;
                     Print_String('[');
                     Print_TypeList(nTypeExpList);
                     Print_String(']');
                  end;
                  FunctorSegment:
                     with FunctorSegmentPtr(nSchemeParams^.Items^[j])^ do
                  begin
                     Print_Variable( nVars^.Items^[0]);
                     for i:=1 to nVars.Count-1 do
                     begin
                        Print_String(',');
                        Print_Variable( nVars^.Items^[i]);
                     end;
                     Print_String('(');
                     Print_TypeList(nTypeExpList);
                     Print_String(')');
                     Print_String(TokenName[sy_Arrow]);
                     Print_Type(nSpecification);
                  end;
               endcases;
               if (j >= 0) and (j < nSchemeParams^.Count-1) then
                  Print_String(',');
            end;
            Print_String('}');
            Print_String(':');
            Print_Newline;
            Print_Formula(nSchemeConclusion);
            Print_NewLine;
            if (nSchemePremises <> nil) and (nSchemePremises^.Count > 0) then
            begin
               Print_String(TokenName[sy_Provided]);
               Print_Proposition(nSchemePremises^.Items^[0]);
               for i:=1 to nSchemePremises^.Count-1 do
               begin
                  Print_String(TokenName[sy_And]);
                  Print_NewLine;
                  Print_Proposition(nSchemePremises^.Items^[i]);
               end;
            end;
            Print_String(TokenName[sy_Proof]);
            Print_NewLine;
         end;
         itTheorem:
            with CompactStatementPtr(nContent)^ do
         begin
            Print_NewLine;
            nIndent:=0;
            Print_String(TokenName[sy_Theorem]);
            Print_Label(nProp^.nLab);
            Print_NewLine;
            nIndent:=2;
            Print_Indent;
            Print_Formula(nProp^.nSentence);
            nIndent:=0;
            Print_Justification(nJustification,nBlock);
            Print_String(';');
            Print_NewLine;
         end;
         itAxiom:
            begin
               
            end;
         itReservation:
            with ReservationSegmentPtr(nContent)^ do
         begin
            Print_NewLine;
            Print_String(TokenName[sy_reserve]);
            Print_Variable( nIdentifiers.Items^[0]);
            for i:=1 to nIdentifiers^.Count-1 do
            begin
               Print_String(',');
               Print_Variable( nIdentifiers^.Items^[i]);
            end;
            Print_String(TokenName[sy_For]);
            Print_ReservedType(nResType);
            Print_String(';');
            Print_NewLine;
         end;
         itSection:
            begin
               Print_NewLine;
               Print_String(TokenName[sy_Begin]);
               Print_NewLine;
            end;
         itRegularStatement:
            begin
               Print_RegularStatement(RegularStatementPtr(nContent),nBlock);
               Print_String(';');
               Print_NewLine;
            end;
         itChoice:
            with ChoiceStatementPtr(nContent)^ do
         begin
            if (nJustification^.nInfSort = infStraightforwardJustification) and
                  StraightforwardJustificationPtr(nJustification)^.nLinked then
            begin
               Print_Linkage;
            end;
            Print_String(TokenName[sy_Consider]);
            Print_VariableSegment( nQualVars^.Items^[0]);
            for i:= 1 to  nQualVars^.Count-1 do
            begin
               Print_String(',');
               Print_VariableSegment( nQualVars^.Items^[i]);
            end;
            if (nConditions <> nil) and (nConditions^.Count > 0) then
            begin
               Print_String(TokenName[sy_Such]);
               Print_Conditions(nConditions);
            end;
            Print_Justification(nJustification,nil);
            Print_String(';');
            Print_NewLine;
         end;
         itReconsider:
            with TypeChangingStatementPtr(nContent)^ do
         begin
            if (nJustification^.nInfSort = infStraightforwardJustification) and
                  StraightforwardJustificationPtr(nJustification)^.nLinked then
            begin
               Print_Linkage;
            end;
            Print_String(TokenName[sy_Reconsider]);
            for i:=0 to nTypeChangeList^.Count-1 do
            begin
               case TypeChangePtr(nTypeChangeList^.Items^[i])^.nTypeChangeKind of
                  Equating:
                     begin
                        Print_Variable(TypeChangePtr(nTypeChangeList^.Items^[i])^.nVar);
                        Print_String('=');
                        Print_Term(TypeChangePtr(nTypeChangeList^.Items^[i])^.nTermExpr);
                     end;
                  VariableIdentifier:
                     begin
                        Print_Variable(TypeChangePtr(nTypeChangeList.Items^[i])^.nVar);
                     end;
               endcases;
               if (i >= 0) and (i < nTypeChangeList^.Count-1) then
                  Print_String(',');
            end;
            Print_String(TokenName[sy_As]);
            Print_Type(nTypeExpr);
            Print_Justification(nJustification,nil);
            Print_String(';');
            Print_NewLine;
         end;
         itPrivFuncDefinition:
            with PrivateFunctorDefinitionPtr(nContent)^ do
         begin
            Print_String(TokenName[sy_DefFunc]);
            Print_Variable(nFuncId);
            Print_String('(');
            Print_TypeList(nTypeExpList);
            Print_String(')');
            Print_String('=');
            Print_Term(nTermExpr);
            Print_String(';');
            Print_NewLine;
         end;
         itPrivPredDefinition:
            with PrivatePredicateDefinitionPtr(nContent)^ do
         begin
            Print_String(TokenName[sy_DefPred]);
            Print_Variable(nPredId);
            Print_String('[');
            Print_TypeList(nTypeExpList);
            Print_String(']');
            Print_String(TokenName[sy_Means]);
            Print_Formula(nSentence);
            Print_String(';');
            Print_NewLine;
         end;
         itConstantDefinition:
            with ConstantDefinitionPtr(nContent)^ do
         begin
            Print_String(TokenName[sy_Set]);
            Print_Variable(nVarId);
            Print_String('=');
            Print_Term(nTermExpr);
            Print_String(';');
            Print_NewLine;
         end;
         itLociDeclaration,
         itGeneralization:
            begin
               Print_String(TokenName[sy_Let]);
               Print_VariableSegment( QualifiedSegmentPtr(nContent));
               Print_String(';');
               Print_NewLine;
            end;
         itAssumption:
            begin
               Print_String(TokenName[sy_Assume]);
               Print_AssumptionConditions(AssumptionPtr(nContent));
               Print_String(';');
               Print_NewLine;
            end;
         itExistentialAssumption:
            with ExistentialAssumptionPtr(nContent)^ do
         begin
            Print_String(TokenName[sy_Given]);
            Print_VariableSegment( nQVars^.Items^[0]);
            for i := 1 to  nQVars^.Count-1 do
            begin
               Print_String(',');
               Print_VariableSegment( nQVars^.Items^[i]);
            end;
            Print_String(TokenName[sy_Such]);
            Print_String(TokenName[sy_That]);
            Print_NewLine;
            Print_Proposition(nConditions^.Items^[0]);
            for i:=1 to nConditions^.Count-1 do
            begin
               Print_String(TokenName[sy_And]);
               Print_NewLine;
               Print_Proposition(nConditions^.Items^[i]);
            end;
            Print_String(';');
            Print_NewLine;
         end;
         itExemplification:
            with ExamplePtr(nContent)^ do
         begin
            Print_String(TokenName[sy_Take]);
            if nVarId <> nil then
            begin
               Print_Variable(nVarId);
               if nTermExpr <> nil then
               begin
                  Print_String('=');
               end;
            end;
            if nTermExpr <> nil then
               Print_Term(nTermExpr);
            Print_String(';');
            Print_NewLine;
         end;
         itPerCases:
            begin
               if (JustificationPtr(nContent)^.nInfSort = infStraightforwardJustification) and
                     StraightforwardJustificationPtr(nContent)^.nLinked then
               begin
                  Print_Linkage;
               end;
               Print_String(TokenName[sy_Per]);
               Print_String(TokenName[sy_Cases]);
               Print_Justification(JustificationPtr(nContent),nil);
               Print_String(';');
               Print_NewLine;
            end;
         itConclusion:
            begin
               Print_String(TokenName[sy_Thus]);
               Print_RegularStatement(RegularStatementPtr(nContent),nBlock);
               Print_String(';');
               Print_NewLine;
            end;
         itCaseBlock:
            begin
               Print_Block(nBlock);
               Print_String(';');
               Print_NewLine;
            end;
         itCaseHead,
         itSupposeHead:
            begin
               Print_AssumptionConditions(AssumptionPtr(nContent));
               Print_String(';');
               Print_NewLine;
            end;
         itCorrCond:
            begin
               Print_String(CorrectnessName[CorrectnessConditionPtr(nContent)^.nCorrCondSort]);
               Print_Justification(CorrectnessConditionPtr(nContent)^.nJustification,nBlock);
               Print_String(';');
               Print_NewLine;
            end;
         itCorrectness:
            begin
               Print_String(TokenName[sy_Correctness]);
               Print_Justification(CorrectnessPtr(nContent)^.nJustification,nBlock);
               Print_String(';');
               Print_NewLine;
            end;
         itProperty:
            begin
               Print_String(PropertyName[PropertyPtr(nContent)^.nPropertySort]);
               Print_Justification(PropertyPtr(nContent)^.nJustification,nBlock);
               Print_String(';');
               Print_NewLine;
            end;
         itDefMode:
            with ModeDefinitionPtr(nContent)^ do
         begin
            if nRedefinition then
            begin
               Print_String(TokenName[sy_Redefine]);
            end;
            Print_String(TokenName[sy_Mode]);
            Print_Pattern(nDefModePattern);
            case nDefKind of
               defExpandableMode:
                  begin
                     Print_String(TokenName[sy_Is]);
                     Print_Type(ExpandableModeDefinitionPtr(nContent)^.nExpansion);
                  end;
               defStandardMode:
                  with StandardModeDefinitionPtr(nContent)^ do
               begin
                  if nSpecification <> nil then
                  begin
                     Print_String(TokenName[sy_Arrow]);
                     Print_Type(nSpecification);
                  end;
                  if nDefiniens <> nil then
                  begin
                     Print_String(TokenName[sy_Means]);
                     Print_NewLine;
                     Print_Definiens(nDefiniens);
                  end;
               end;
            endcases;
            Print_String(';');
            Print_NewLine;
         end;
         itDefAttr:
            with AttributeDefinitionPtr(nContent)^ do
         begin
            if nRedefinition then
            begin
               Print_String(TokenName[sy_Redefine]);
            end;
            Print_String(TokenName[sy_Attr]);
            Print_Pattern(nDefAttrPattern);
            Print_String(TokenName[sy_Means]);
            Print_NewLine;
            Print_Definiens(nDefiniens);
            Print_String(';');
            Print_NewLine;
         end;
         itDefPred:
            with PredicateDefinitionPtr(nContent)^ do
         begin
            if nRedefinition then
            begin
               Print_String(TokenName[sy_Redefine]);
            end;
            Print_String(TokenName[sy_Pred]);
            Print_Pattern(nDefPredPattern);
            if nDefiniens <> nil then
            begin
               Print_String(TokenName[sy_Means]);
               Print_NewLine;
               Print_Definiens(nDefiniens);
            end;
            Print_String(';');
            Print_NewLine;
         end;
         itDefFunc:
            with FunctorDefinitionPtr(nContent)^ do
         begin
            if nRedefinition then
            begin
               Print_String(TokenName[sy_Redefine]);
            end;
            Print_String(TokenName[sy_Func]);
            Print_Pattern(nDefFuncPattern);
            if nSpecification <> nil then
            begin
               Print_String(TokenName[sy_Arrow]);
               Print_Type(nSpecification);
            end;
            case nDefiningWay of
               dfEmpty:;
               dfMeans:
                  begin
                     Print_String(TokenName[sy_Means]);
                     Print_NewLine;
                  end;
               dfEquals:
                  begin
                     Print_String(TokenName[sy_Equals]);
                  end;
            endcases;
            Print_Definiens(nDefiniens);
            Print_String(';');
            Print_NewLine;
         end;
         itDefStruct:
            with StructureDefinitionPtr(nContent)^ do
         begin
            Print_String(TokenName[sy_Struct]);
            if nAncestors^.Count > 0 then
            begin
               Print_String('(');
               Print_Type(nAncestors^.Items^[0]);
               for i := 1 to nAncestors^.Count - 1 do
               begin
                  Print_String(',');
                  Print_Type(nAncestors^.Items^[i]);
               end;
               Print_String(')');
            end;
            Print_String(StructureName[nDefStructPattern^.nModeSymbol]);
            if (nDefStructPattern^.nArgs <> nil) and (nDefStructPattern^.nArgs^.Count > 0) then
            begin
               Print_String(TokenName[sy_Over]);
               Print_Loci(nDefStructPattern^.nArgs);
            end;
            Print_String(TokenName[sy_StructLeftBracket]);
            for i := 0 to nSgmFields^.Count - 1 do
               with FieldSegmentPtr(nSgmFields^.Items^[i])^ do
            begin
               Print_String(SelectorName[FieldSymbolPtr(nFields^.Items^[0])^.nFieldSymbol]);
               for j := 1 to nFields^.Count - 1 do
                  with FieldSymbolPtr(nFields^.Items^[j])^ do
               begin
                  Print_String(',');
                  Print_String(SelectorName[nFieldSymbol]);
               end;
               Print_String(TokenName[sy_Arrow]);
               Print_Type(nSpecification);
               if (i >= 0) and (i < nSgmFields^.Count-1) then
                  Print_String(',');
            end;
            Print_String(TokenName[sy_StructRightBracket]);
            Print_String(';');
            Print_NewLine;
         end;
         itPredSynonym,
         itFuncNotation, itModeNotation,
         itAttrSynonym:
            with NotationDeclarationPtr(nContent)^ do
         begin
            Print_String(TokenName[sy_Synonym]);
            Print_Pattern(nNewPattern);
            Print_String(TokenName[sy_For]);
            Print_Pattern(nOriginPattern);
            Print_String(';');
            Print_NewLine;
         end;
         itPredAntonym,itAttrAntonym:
            with NotationDeclarationPtr(nContent)^ do
         begin
            Print_String(TokenName[sy_Antonym]);
            Print_Pattern(nNewPattern);
            Print_String(TokenName[sy_For]);
            Print_Pattern(nOriginPattern);
            Print_String(';');
            Print_NewLine;
         end;
         itCluster:
            begin
               Print_String(TokenName[sy_Cluster]);
               case ClusterPtr(nContent)^.nClusterKind of
                  ExistentialRegistration:
                     with EClusterPtr(nContent)^ do
                  begin
                     Print_AdjectiveList(nConsequent);
                     Print_String(TokenName[sy_For]);
                     Print_Type(nClusterType);
                  end;
                  ConditionalRegistration:
                     with CClusterPtr(nContent)^ do
                  begin
                     Print_AdjectiveList(nAntecedent);
                     Print_String(TokenName[sy_Arrow]);
                     Print_AdjectiveList(nConsequent);
                     Print_String(TokenName[sy_For]);
                     Print_Type(nClusterType);
                  end;
                  FunctorialRegistration:
                     with FClusterPtr(nContent)^ do
                  begin
                     Print_Term(nClusterTerm);
                     Print_String(TokenName[sy_Arrow]);
                     Print_AdjectiveList(nConsequent);
                     if nClusterType <> nil then
                     begin
                        Print_String(TokenName[sy_For]);
                        Print_Type(nClusterType);
                     end;
                  end;
               endcases;
               Print_String(';');
               Print_NewLine;
            end;
         itIdentify:
            with IdentifyRegistrationPtr(nContent)^ do
         begin
            Print_String(TokenName[sy_Identify]);
            Print_Pattern(nNewPattern);
            Print_String(TokenName[sy_With]);
            Print_Pattern(nOriginPattern);
            if (nEqLociList <> nil) and (nEqLociList^.Count > 0) then
            begin
               Print_String(TokenName[sy_When]);
               for i := 0 to nEqLociList^.Count - 1 do
                  with LociEqualityPtr(nEqLociList^.Items^[i])^ do
               begin
                  Print_Locus(nLeftLocus);
                  Print_String('=');
                  Print_Locus(nRightLocus);
                  if (i >= 0) and (i < nEqLociList^.Count-1) then
                     Print_String(',');
               end;
            end;
            Print_String(';');
            Print_NewLine;
         end;
         itPropertyRegistration:
            case PropertyRegistrationPtr(nContent)^.nPropertySort of
               sySethood:
                  with SethoodRegistrationPtr(nContent)^ do
               begin
                  Print_String(PropertyName[nPropertySort]);
                  Print_String(TokenName[sy_Of]);
                  Print_Type(nSethoodType);
                  Print_Justification(nJustification,nBlock);
                  Print_String(';');
                  Print_NewLine;
               end;
            endcases;
         itReduction:
            begin
               with ReduceRegistrationPtr(nContent)^ do
               begin
                  Print_String(TokenName[sy_Reduce]);
                  Print_Term(nOriginTerm);
                  Print_String(TokenName[sy_To]);
                  Print_Term(nNewTerm);
               end;
               Print_String(';');
               Print_NewLine;
            end;
         itPragma:
            begin
               Print_NewLine;
               Print_String('::'+PragmaPtr(nContent)^.nPragmaStr);
               Print_NewLine;
            end;
         itIncorrItem:;
      end;
   endcases;
end;


@ @<Implementation for \texttt{wsmarticle.pas}@>=
procedure Print_WSMizArticle(aWSTextProper:wsTextProperPtr; aFileName:string);
var lWSMizOutput: WSMizarPrinterPtr;
begin
   InitScannerNames;
   lWSMizOutput:=new(WSMizarPrinterPtr,OpenFile(aFileName));
   lWSMizOutput^.Print_TextProper(aWSTextProper);
   dispose(lWSMizOutput,Done);
end;

