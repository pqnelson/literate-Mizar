
@* [F] Mizar environment.
We want to abstract away all the system dependent code, and provide a
set of common functions Mizar will use to interact with the file
system. This will include some helper functions for trimming
whitespace from a String.

@<mizenv.pas@>=
@<GNU License@>

unit mizenv;

interface @| @/

@<interface for mizenv.pas@> @; @#

implementation @|@/

@<Modules used by \texttt{mizenv.pas}@> @; @/

@<implementation of mizenv.pas@> @t\2@> 

end.

@ There are a few common ``global variables'' used by the rest of
Mizar. Specifically, Mizar will be processing a file (``article'').
The file may be an absolute path
(e.g., \texttt{/path/to/article.miz}), a relative path (\texttt{../article.miz}), or just the
filename (\texttt{article.miz}). In any event, we will want to refer
to the filename (\texttt{article.miz}) as well as what Mizar calls the
``article ID'' (in this case, ``\texttt{ARTICLE}'' --- the filename
without the file extension, transformed to all capital letters).

Modern programmers may find discomfort working with global variables
(and for good reason!). We remind such readers that it was common
practice, until very recently, for compilers and interpreters to use
global variables to describe the state of the compiler (or
interpreter). We will freely refer to these global variables as
``state variables'', since that captures the role they play more accurately.

@^State variable@>
@^Variable, global@>
@^Variable, state@>
@^Global variable@>

\label{mizenv-global-vars}

@<interface for mizenv.pas@>=
var MizFileName : string; { the article ``\texttt{article.miz}'' }
  ArticleName : string; { the ``\texttt{article}'' without the ``\texttt{.miz}''}
  ArticleID : string; { ``\texttt{ARTICLE}'' in screaming snake case}
  ArticleExt : string; { ``\texttt{.miz}'' from the |MizFileName| }
  EnvFileName : string; { the file name given to Mizar as a command-line argument } @#

procedure @? SetStringLength(var aString: string; aLength: integer);

@ The implementation begins with various ``uses''. Depending on
the \PASCAL/ compiler and operating system, different libraries need
to be loaded.

@<Modules used by \texttt{mizenv.pas}@>=
uses {compiler dependent imports}@/
if_def(DELPHI)
  IOUtils,SysUtils,windows, @+
endif
if_def(FPC)
  dos,SysUtils, @+
endif @/
  mconsole; {the only Mizar module \texttt{mizenv.pas} uses}

@ As far as setting the String length, this is a straightforward
implementation. When the desired \\{aLength} is less than the actual
length of \\{aString}, simply delete all characters after \\{aLength}.

Otherwise, \\{aString} has \textit{fewer} characters than desired, so we
pad it on the right with however many spaces until the String is as
long as \\{aLength}.

@<implementation of mizenv.pas@>=
procedure SetStringLength(var aString: string; aLength: integer);
var I, L: integer;
begin
  L := length(aString);
  if aLength <= L then
    Delete(aString, aLength + 1, L - aLength)
  else
    for I := 1 to aLength - L do aString := aString + ' ';
end;

@ \node{Trimming whitespace.}
Trimming the left String will repeatedly delete any leading
whitespace, until the String is empty or has no leading whitespace.

Similarly, trimming the right String will repeatedly delete the \textit{last}
character until it is no longer whitespace (or until the String becomes empty).

Remember, \PASCAL/ is call-by-value, so the string arguments are
copied when these functions are invoked. We are mutating the copy of
the argument, and returning them to the user.

@<interface for mizenv.pas@>=
function @? TrimStringLeft(aString: string): string; @t\2@>
function @? TrimStringRight(aString: string): string;

@ @<implementation of mizenv.pas@>=
function TrimStringLeft(aString: string): string;
begin
  while (length(aString) > 0) and (aString[1] = ' ') do Delete(aString, 1, 1);
  TrimStringLeft := aString;
end;
@#
function TrimStringRight(aString: string): string;
begin
  while (length(aString) > 0) and (aString[length(aString)] = ' ') do Delete(aString, length(aString), 1);
  TrimStringRight := aString;
end;

@ Trimming a String amounts to trimming it on the left and right.

@<interface for mizenv.pas@>=
function @? TrimString(const aString: string): string;

@ @<implementation of mizenv.pas@>=
function TrimString(const aString: string): string;
begin
  TrimString := TrimStringRight(TrimStringLeft(aString));
end;

@ \node{Uppercase and lowercase strings.}
We have a few more String manipulation functions for changing case,
and turning an integer into a String.

@<interface for mizenv.pas@>=
function @? UpperCase(const aStr:string): string; @t\2@>
function @? MizLoCase(aChar: char): char; @t\2@>
function @? LowerCase(const aStr: string): string; @t\2@>
function @? IntToStr(aInt: integer): string;

@ Now, uppercase strings are obtained by uppercasing each character.

@<implementation of mizenv.pas@>=
function UpperCase(const aStr:string): string;
 var k: integer; {index ranging over |aStr|}
  lStr: string;  {the uppercased String being built and returned}
begin
 lStr:=aStr;
 for k:=1 to length(aStr) do lStr[k]:=UpCase(aStr[k]);
 UpperCase:=lStr;
end;

@ Lowercasing a String can be done by iteratively replacing each
character with its lowercase version. This ``lowercase a single
character'' function is precisely |MizLoCase|.

If the reader wished for a \UTF8 version of Mizar, then this function
would require thinking very hard about how to generalize.

@p
function MizLoCase(aChar: char): char;
begin
 if aChar in ['A'..'Z'] then
   MizLoCase := Chr(Ord('a') + Ord(aChar) - Ord('A'))
 else
   MizLoCase := aChar;
end;
@#

function LowerCase(const aStr: string): string;
 var i: integer;  {index ranging over |aStr|'s length}
     lStr: String; {result being built up}
begin
  lStr:=aStr;
  for i:=1 to length(aStr) do lStr[i]:=MizLoCase(aStr[i]);
  LowerCase:=lStr;
end;

@ We also want a \emph{funtion} to convert an integer to a
String. \PASCAL/ provides us with a \emph{procedure}.

@p
function IntToStr(aInt: integer): string;
 var lStr: string;
begin
 Str(aInt,lStr);
 IntToStr:=lStr;
end;

@ {\bf File name manipulation.} We will want to test if a file exists,
or split a path (represented as a String) into a directory and a filename.

Testing if a file exists uses the Free Pascal's primitive |FileExists|
function.

Similarly, |EraseFile| is just relying on Free Pascal's |SysUtils.DeleteFile|
function.

\label{MFileExists}

@<interface for mizenv.pas@>=
function @? MFileExists(const aFileName : string) : Boolean; @t\2@>
procedure @? EraseFile(const aFileName:string);

@ @<implementation of mizenv.pas@>=
function MFileExists(const aFileName : String) : Boolean;
begin
 MFileExists:=FileExists(aFileName); @+
end;
@#
procedure EraseFile(const aFileName:String);
begin
 SysUtils.DeleteFile(aFileName); @+
end;

@ We will destructively rename a file. If a file with the name already
exists, we delete it. \CAUTION/: This function is not used anywhere,
and it appears to be buggy (the file is deleted and then renamed,
which begs the question---why is it deleted?).

@<interface for mizenv.pas@>=
procedure @? RenameFile(const aName1,aName2:string);

@ @<implementation of mizenv.pas@>=
procedure RenameFile(const aName1,aName2:String); {unused}
begin
 if MFileExists(aName1) then
   EraseFile(aName2);
 SysUtils.RenameFile(aName1,aName2);
end;

@ Again, relying on Free Pascal's |FileAge| function, which returns
the modification time of the file. \CAUTION/: this will return a
signed 32-bit integer, which will run into problems after 03:14:07~UTC on 19 January 2038
because that's $2^{31}-1$ seconds since the \UNIX/ epoch.

\label{GetFileTime}

@<interface for mizenv.pas@>=
function @? GetFileTime(aFileName: string): Longint;

@ @<implementation of mizenv.pas@>=
function GetFileTime(aFileName: String): Longint;
begin
 GetFileTime := FileAge(aFileName); @+
end;

@ Split a file name into components, namely (1) the directory, (2) the
file name, (3) its extension.
For example, \texttt{/path/to/my/file.exe} will be split
into \texttt{/path/to/my/}, \texttt{file}, and \texttt{exe}.

This implementation depends on the compiler used (Delphi or Free Pascal).

@<interface for mizenv.pas@>=
procedure @? SplitFileName(@t\hskip-0.5em@>@+const aFileName: string; @/
@t\hskip8.75pc@>@+ var aDir, aName, aExt: string);

@ @<implementation of mizenv.pas@>=
procedure SplitFileName(@t\hskip-0.5em@>@+const aFileName: string; {input} @/
@t\hskip8.75pc@>@+  var aDir, aName, aExt: string) @t\2@>; {output}
begin@|@/
if_def(FPC) @/
 aDir := SysUtils.ExtractFilePath(aFileName); @/
 aName := SysUtils.ExtractFileName(aFileName); @/
 aExt := SysUtils.ExtractFileExt(aFileName);
endif@;
if_def(DELPHI) @/
 aDir := TPath.GetDirectoryName(aFileName); @/
 aName := TPath.GetFileName(aFileName); @/
 aExt := TPath.GetExtension(aFileName);
endif@;
end;

@ ``Truncating a directory'' means ``throw away the directory part of
the  path'' so we end up with just a filename and the file extension.

@<interface for mizenv.pas@>=
function @? TruncDir(const aFileName: string): string;

@ @<implementation of mizenv.pas@>=
function TruncDir(const aFileName: string): string;
var
  Dir, lName, Ext: string;
begin
  SplitFileName(aFileName, Dir, lName, Ext);
  TruncDir := lName + Ext;
end;

@ ``Truncating the extension'' means throwing away the extension part
of a path.

@<interface for mizenv.pas@>=
function @? TruncExt(const aFileName: string): string;
@ @<implementation of mizenv.pas@>=
function TruncExt(const aFileName: string): string;
var
  Dir, lName, Ext: string;
begin
  SplitFileName(aFileName, Dir, lName, Ext);
  TruncExt := Dir + lName;
end;

@ Extracting the file directory will return \textit{just} the directory
part of a path.

@<interface for mizenv.pas@>=
function @? ExtractFileDir(const aFileName: string): string;

@ @<implementation of mizenv.pas@>=
function ExtractFileDir(const aFileName: string): string;
 var
   Dir, lName, Ext: string;
begin
  SplitFileName(aFileName, Dir, lName, Ext);
  ExtractFileDir := Dir;
end;

@ Extracting the file name will throw away both the directory and
extension. For example, extracting the file name from the path
``\texttt{/path/to/file.ext}'' gives us ``\texttt{file}''. Extracting
the file extension from the same path gives us ``\texttt{.ext}''.

@<interface for mizenv.pas@>=
function @? ExtractFileName(const aFileName: string): string; @t\2@>
function @? ExtractFileExt(const aFileName: string): string;

@ @<implementation of mizenv.pas@>=
function ExtractFileName(const aFileName: string): string;
var
  Dir, lName, Ext: string;
begin
  SplitFileName(aFileName, Dir, lName, Ext);
  ExtractFileName := lName;
end;
@#
function ExtractFileExt(const aFileName: string): string;
var
  Dir, lName, Ext: string;
begin
  SplitFileName(aFileName, Dir, lName, Ext);
  ExtractFileExt := Ext;
end;

@ Changing a file name's extension. See:

\href{https://www.freepascal.org/docs-html/rtl/sysutils/changefileext.html}{{\tt freepascal.org/docs-html/rtl/sysutils/changefileext.html}}

\noindent Note this does not actually change the filename in the file
system, it just changes it \emph{as a string}.

@<interface for mizenv.pas@>=
function @? ChangeFileExt(const aFileName,aFileExt: string): string;

@ @<implementation of mizenv.pas@>=
function ChangeFileExt(const aFileName,aFileExt: string): string;
begin
 ChangeFileExt:=SysUtils.ChangeFileExt(aFileName,aFileExt); @+
end;

@ \node{Environment variables.}
Getting an environment variable. The reader wishing to learn more
about what \POSIX/ says about environmental variables may consult
the \POSIX/ standard, Volume~1 Chapter~8:

\smallbreak
\href{https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap08.html}{{\tt pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap08.html}}
\smallbreak\noindent%
The Free \PASCAL/ compiler handles this situation far friendlier than
Delphi. 

@^Environment variable@>
@^Variable, Environment@>
@:Posix}{\POSIX/@>

\label{GetEnvStr}

@<interface for mizenv.pas@>=
function GetEnvStr(aEnvName: string): string;

@ @<implementation of mizenv.pas@>=
function GetEnvStr(aEnvName: string): string; @/
if_def(FPC) 
begin
 GetEnvStr:=GetEnv(aEnvname); @+
end; @/
endif 
if_def(DELPHI) 
@<Get environment variable, Delphi-compatible mode@>
endif 

@ The Delphi-compatible version of obtaining an environment variable
is rather involved: copy the string, make it null terminated, look up
the value.

@<Get environment variable, Delphi-compatible mode@>=
const cchBuffer=255;
var lName,lpszTempPath: array[0..cchBuffer] of char;
     i: integer;
     lStr: string; @t\2@>
begin
 @<Copy the variable name as a null-terminated string@>;

 if GetEnvironmentVariable(lName,lpszTempPath,cchBuffer) > 0 then
  begin
   @<Copy environment variable's value into |lStr| until we find null character@>;
  end;
 GetEnvStr:=lStr;
end;

@ @<Copy the variable name as a null-terminated string@>=
 lStr:='';
 for i:=1 to length(aEnvname) do
  lName[i-1]:=aEnvname[i];
 lName[length(aEnvname)]:=#0

@ @<Copy environment variable's value into |lStr| until we find null character@>=
   for i:=0 to cchBuffer do
    begin
     if lpszTempPath[i]=#0 then break;
     lStr:=lStr+lpszTempPath[i];
    end

@ \node{Common printing routines.}
Examining a file amounts to testing if we can open the file. We close
the file after opening it (because we don't want to actually want to
do anything with it).

We should tweak how \WEB/ formats a file to make it resemble the other
types, rather than leave it as a ``type opertor'' like \&{array}
(which is the default due to Knuth).

@f file==integer;

@<implementation of mizenv.pas@>=
procedure FileExam(const aFileName: string);
var Source: file; {the file named |aFileName|}
I: byte; {|IOResult| from trying to open the file}
begin
  if aFileName = '' then @<Halt: we can't open the file@>;
  FileMode:=0;
  Assign(Source,aFileName); without_io_checking(Reset(Source));
  I:=IOResult;
  if I<>0 then DrawIOResult(aFileName,I); {(\section\xref{mconsole:drawioresult})}
  close(Source);
  FileMode:=2;
end;

@ @<Halt: we can't open the file@>=
    begin DrawMessage('Can''t open '' .miz ''',''); @t\hskip-1em@> {(\section\xref{mconsole:drawmessage})}@+
     halt(1);
    end

@ The user provides a file to Mizar as the command line argument. This
typically looks like a relative path ``\texttt{tex/article}'' without
any file extension. Before even trying to open ``\texttt{tex/article.miz}'', or any of the
related autogenerated intermediate files, we should test the file exists.

This procedure will notify the user if the file does not exist,
otherwise it is silent.

Again, |DrawMessage| comes from \texttt{mconsole.pas} (\section\xref{mconsole:drawmessage}).

@<implementation of mizenv.pas@>=
procedure EnvFileExam(const aFileExt: string);
begin
  if not MFileExists(EnvFileName+aFileExt) then
   begin
     DrawMessage('Can''t open '' '+EnvFileName+aFileExt+' ''','');
     Halt(1);
   end;
end; 

@ This function isn't used anywhere in Mizar. It's also misnamed: we
are not ``getting'' the file name, we are \emph{updating} the file
extension if the file lacks one. A better name might be ``populate
missing file extension''. Further, this does not test if the |Nr|
command line argument is actually a file name or not, which is a
possible source of bugs.

Remember, the \\{ParamCount} is \PASCAL/'s way of counting the command-line
parameters passed to the program.

@<implementation of mizenv.pas@>=
procedure GetFileName(ParamNr:byte; DefaultExt:string; var aFileName:string);
 var  lFileExt: string;
begin
 if ParamNr <= ParamCount then
  begin aFileName:=ParamStr(ParamNr);
    lFileExt:=ExtractFileExt(aFileName);
    if lFileExt='' then aFileName:=ChangeFileExt(aFileName,DefaultExt);
    exit
  end;
 aFileName:='';
end;

@ This procedure will take the |Nr| command line argument. If it lacks
a file extension, then it will append the |DefaultExt| to it. At the
end, this will populate |aFileName| and |aFileExt| based on the
command line. It's only used in the |GetMizFileName| procedure, and
nowhere else in Mizar.

The |ParamStr(Nr)| returns the ${\it Nr}^{th}$ parameter as a String (it's
a \PASCAL/ primitive).

@<implementation of mizenv.pas@>=
procedure GetFileExtName(Nr:byte; DefaultExt: string;
                      var aFileName: string; var aFileExt:s tring);
begin
 if Nr <= ParamCount then
  begin aFileName:=ParamStr(Nr);
    aFileExt:=ExtractFileExt(aFileName);
    if aFileExt='' then aFileExt:=DefaultExt
    else aFileName:=ChangeFileExt(aFileName,'');
    exit
  end;
 aFileName:=''; aFileExt:='';
end;

@ \node{Populate the state variables using the command-line arguments.}
We need to find the first command-line argument which resembles a
Mizar article name. Note that Mizar articles have several files
associated with it (the article's contents in a \texttt{.miz} file,
the vocabulary in a \texttt{.voc} file, and \XML/ related intermediate
representation in \texttt{.xml} files, as well as \texttt{.evl} files).

Command line flags prefixed with a dash (``\texttt{-}'') will not be
interpreted as the name of a Mizar article.

If there are multiple articles passed to Mizar as command-line
arguments, then this function finds the first one (and uses it to
populate the state variables).

A possible bug: if there are multiple files passed to Mizar and the
first file passed is not a ``\texttt{.miz}'' file, then Mizar will
halt as a failure instead of continuing looking for the needle in the
haystack. 

@<implementation of mizenv.pas@>=
procedure GetMizFileName(aFileExt:String);
var i:integer;
begin
 MizFileName:=''; ArticleName:=''; ArticleExt:=''; EnvFileName:='';
 for i:=1 to ParamCount do
  if ParamStr(i)[1]<>'-' then
   begin
    MizFileName:=ParamStr(i);
    GetFileExtName(i,aFileExt,MizFileName,ArticleExt);
    ArticleName:=ExtractFileName(MizFileName);
    ArticleID:=UpperCase(ArticleName);
    if not IsMMLIdentifier(ArticleName) then
    @<Halt: invalid article name@>;
    EnvFileName:=MizFileName;
    exit;
   end;
end;

@ @<Halt: invalid article name@>=
     begin
      DrawMessage('Only letters, numbers and _ allowed in Mizar file names','');
      halt(1);
     end

@ We will provide a standard way to populate the global variables.

@<implementation of mizenv.pas@>=
procedure GetArticleName;
begin
 GetMizFileName('.miz');
end;

@ The second file provided to Mizar is treated as the |EnvFileName|.
We need to populate the global variables if they have not been
extracted from the command-line arguments already.

@<implementation of mizenv.pas@>=
procedure GetEnvironName;
var i,c:integer;
begin
 if MizFileName = '' then GetArticleName;
 EnvFileName:=MizFileName;
 c:=0;
 for i:=1 to ParamCount do
  if (ParamStr(i)[1]<>'-') then
   begin
    inc(c);
    if c=2 then EnvFileName:=ParamStr(i);
   end;
end;

@ The valid characters which can appear in a Mizar article name (an
``MML Identifier'') are uppercase Latin letters (\texttt{A-Z}), lowercase Latin
letters (\texttt{a-z}), decimal digits (\texttt{0-9}), and underscores
(\texttt{\_}). 

@p
function IsMMLIdentifier(const aID: String): Boolean;
 const Allowed: array[chr(0)..chr(255)] of byte =
   (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, @/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0, {\texttt{0}--\texttt{9}}
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1, {\texttt{A}--\texttt{Z}, ``\texttt{\_}''}
    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0, {\texttt{a}--\texttt{z}}
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, @/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, @/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, @/
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
 var i: integer;
begin
  for i:=1 to length(aID) do
   if Allowed[aID[i]] = 0 then
    begin
     IsMMLIdentifier:=false;
     exit; @+
    end;
 @t\quad @>  IsMMLIdentifier:=true;
end;

