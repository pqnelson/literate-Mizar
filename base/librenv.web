
@* [F] Environment library.
We have a library to handle accessing the Mizar mathematical library
files. This is used in \texttt{makeenv.dpr} and using
local \texttt{prel/} directories.

This will execute |InitLibrEnv| (\section\xref{InitLibrEnv}) and
|CheckCompatibility| (\section\xref{CheckCompatibility}).

@<librenv.pas@>=
  @<GNU License@>

unit librenv;

interface @|@#

uses mobjects; @|@#

@<Interface for \.{MIZFILES} library@>@; @#

implementation @|@#

uses @|@/
   @{@&$IFDEF WIN32@}
   windows, @/
   @{@&$ENDIF@}
   mizenv,pcmizver,mconsole; @#

@<Implementation for \texttt{librenv.pas}@>@; @#

begin
   InitLibrEnv;
   CheckCompatibility; @t\2@>
end.

@ @<Interface for \.{MIZFILES} library@>=
const
   MML = 'mml';
   EnvMizFiles = 'MIZFILES';

var MizPath, MizFiles: string;

function LibraryPath(fName,fExt: string): string; @t\2@>@#

procedure GetSortedNames(fParam:byte; var fList:MStringCollection); @t\2@>
procedure GetNames(fParam:byte; var fList: StringColl); @t\2@>@#

procedure ReadSortedNames(fName:string; var fList:MStringCollection); @t\2@>
procedure ReadNames(fName:string; var fList: StringColl); @t\2@>

@ There are two public-facing classes.

@<Interface for \.{MIZFILES} library@>=
type
   @<Declare \\{FileDescr} data type@>@;
   @<Declare \\{FileDescrCollection} data type@>@;@#

var LocFilesCollection: FileDescrCollection;

@ \node{File descriptors.} We use file descriptors for things. These
are just ``a file name'' and ``a timestamp''.

@<Declare \\{FileDescr} data type@>=
   PFileDescr = ^FileDescr; @/
   FileDescr = object(MObject) @t\1@> @/
      nName: PString;
      Time: LongInt;
      constructor Init(fIdent:string; fTime:LongInt); @t\2@>
      destructor Done; virtual; @t\2\2\2@>
   end;

@ \node{Constructor.}

@<Implementation for \texttt{librenv.pas}@>=
constructor FileDescr.Init(fIdent:string; fTime:LongInt);
begin
   nName:=NewStr(fIdent); Time:=fTime;
end;

@ \node{Destructor.}

@p
destructor FileDescr.Done;
begin
   DisposeStr(nName);
end;

@ \node{Collection of file descriptions.}

@<Declare \\{FileDescrCollection} data type@>=
   PFileDescrCollection = ^FileDescrCollection; @/
   FileDescrCollection = object(MSortedCollection) @t\1@>
      function Compare(Key1, Key2: Pointer): integer; virtual; @t\2@>
      procedure StoreFIL(fName:string); @t\2@>
      constructor LoadFIL(fName:string); @t\2@>
      procedure InsertTimes; @t\2\2\2@>
   end;

@ Comparing two entries in a file descriptor collection amounts to
comparing the names for the file descriptors.

@<Implementation for \texttt{librenv.pas}@>=
function FileDescrCollection.Compare(Key1, Key2: Pointer): integer;
begin
   if PFileDescr(Key1)^.nName^ < PFileDescr(Key2)^.nName^ then Compare:=-1
   else if PFileDescr(Key1)^.nName^ = PFileDescr(Key2)^.nName^ then Compare:=0
   else Compare:=1;
end;

@ Inserting file times into the file descriptors relies
upon \texttt{mizenv.pas}'s |GetFileTime| (\section\xref{GetFileTime})
function.

@p
procedure FileDescrCollection.InsertTimes;
var z: integer;
begin
   for z:=0 to Count-1 do
      with PFileDescr(Items^[z])^ do Time:=GetFileTime(nName^);
end;

@ \node{Constructor.} This leverages a few primitive \PASCAL/
functions: \\{assign}(\\{file},\\{name}) assigns \\{name} to a file
but does not open the file (it is still considered closed).
Then \\{reset}(\\{file}) opens the file for reading.

Specifically, this will load a \texttt{.fil} file produced by Mizar.
These contain $2N$ lines: a file path on line $2n-1$, then a timestamp
on line $2n$ for $n=1,\dots,N$. This appears to be used for
local \texttt{prel/} files.
@:File, .fil}{File, \texttt{.fil}@>
@^Prel directory@>

@p
constructor FileDescrCollection.LoadFIL(fName:string);
var FIL: text; lName: string; lTime: longint;
begin
   Assign(FIL,fName); Reset(FIL);
   Init(0,10);
   while not eof(FIL) do
   begin
      ReadLn(FIL,lName);
      ReadLn(FIL,lTime);
      Insert(new(PFileDescr,Init(lName,lTime)));
   end;
   close(FIL);
end;

@ \node{Repopulate .fil file.}
This will erase the file named \\{fName}, then assign to \\{FIL} that
file, and $\\{rewrite}(\\{FIL})$ will open it for writing.

This will loop through every item in the caller's underlying
collection, writing the file names and times to the \texttt{.fil} file.

@p
procedure FileDescrCollection.StoreFIL(fName:string);
var FIL: text; i: integer;
begin
   EraseFile(fName);
   Assign(FIL,fName); Rewrite(FIL);
   InsertTimes;
   for i:=0 to Count-1 do
      with PFileDescr(Items^[i])^ do
         begin WriteLn(FIL,nName^); WriteLn(FIL,Time) end;
   Close(FIL);
end;

@ The library path tries to use the local version of a file, if it
exists as tested with |MFileExists| (\section\xref{MFileExists}).
Otherwise it looks at the Mizar MML version of a file, if it exists.

This returns the path to the file, as a string.
If the file cannot be found either in the local prel directory or the
MML prel directory, then it returns the empty string.

@p
function LibraryPath(fName,fExt: string): string;
begin
   LibraryPath:='';
   if MFileExists('prel'+DirSeparator+fName+fExt) then
   begin
      LocFilesCollection.Insert(New(PFileDescr,Init('prel'+DirSeparator+fName+fExt,0)));
      LibraryPath:='prel'+DirSeparator+fName+fExt; exit
   end;
   if MFileExists(MizFiles+'prel'+DirSeparator+fName[1]+DirSeparator+fName+fExt) then
      LibraryPath:=MizFiles+'prel'+DirSeparator+fName[1]+DirSeparator+fName+fExt;
end;

@ This function actually is not used anywhere, so I am not sure why we
have it.

@p
procedure ReadSortedNames(fName:string; var fList:MStringCollection);
var NamesFile: text;
begin
   if fName[1]='@@' then
   begin
      Delete(fName,1,1);
      FileExam(fName);
      Assign(NamesFile,fName);
      Reset(NamesFile);
      fList.Init(100,100);
      while not seekEof(NamesFile) do
      begin
         ReadLn(NamesFile,fName);
         fList.Insert(NewStr(fName));
      end;
      exit;
   end;
   fList.Init(2,10);
   fList.Insert(NewStr(fName));
end;

@ Again, this function is not used anywhere, so I am not sure why we
have it.

@p
procedure ReadNames(fName:string; var fList: StringColl);
var NamesFile: text;
begin
   if fName[1]='@@' then
   begin
      Delete(fName,1,1);
      FileExam(fName);
      Assign(NamesFile,fName);
      Reset(NamesFile);
      fList.Init(10,10);
      while not seekEof(NamesFile) do
      begin
         ReadLn(NamesFile,fName);
         fList.Insert(NewStr(fName));
      end;
      exit;
   end;
   fList.Init(2,10);
   fList.Insert(NewStr(fName));
end;

@ This function is used in \texttt{lisvoc.dpr}

@p
procedure GetSortedNames(fParam:byte; var fList:MStringCollection);
var FileName:string;
NamesFile: text;
i: integer;
begin
   if ParamCount < fParam then  begin fList.Init(0,0); exit end;
   FileName:=ParamStr(fParam);
   if FileName[1]='@@' then
   begin
      Delete(FileName,1,1);
      FileExam(FileName);
      Assign(NamesFile,FileName);
      Reset(NamesFile);
      fList.Init(10,10);
      while not seekEof(NamesFile) do
      begin
         ReadLn(NamesFile,FileName);
         fList.Insert(NewStr(TrimString(FileName)));
      end;
      exit;
   end;
   fList.Init(2,8);
   fList.Insert(NewStr(FileName));
   for i:=fParam+1 to ParamCount do
   begin
      FileName:=ParamStr(i);
      fList.Insert(NewStr(FileName));
   end;
end;

@ Continuing with the ``this is not used anywhere'' theme, this
function is not used anywhere.

@p
procedure GetNames(fParam:byte; var fList: StringColl);
var FileName:string;
NamesFile: text;
i: integer;
begin
   if ParamCount < fParam then  begin fList.Init(0,0); exit end;
   FileName:=ParamStr(fParam);
   if FileName[1]='@@' then
   begin
      Delete(FileName,1,1);
      FileExam(FileName);
      Assign(NamesFile,FileName);
      Reset(NamesFile);
      fList.Init(10,10);
      while not seekEof(NamesFile) do
      begin
         ReadLn(NamesFile,FileName);
         fList.Insert(NewStr(TrimString(FileName)));
      end;
      exit;
   end;
   fList.Init(2,8);
   fList.Insert(NewStr(FileName));
   for i:=fParam+1 to ParamCount do
   begin
      FileName:=ParamStr(i);
      fList.Insert(NewStr(FileName));
   end;
end;

@ \node{Check compatibility of Mizar with MML.}
We will load the \texttt{mml.ini} file for the MML version number, and
we check it against the Mizar version. If they are not compatible,
print a message to the screen, and halt as an error has occurred.

\label{CheckCompatibility}
The \texttt{mml.ini} file looks something like:

\medbreak
{\obeylines\tt
[Mizar verifier]
MizarReleaseNbr=8
MizarVersionNbr=1
MizarVariantNbr=15
[MML]
NumberOfArticles=1493
MMLVersion=5.94
\par}

\medbreak\noindent%
We will read line-by-line the \texttt{mml.ini} file to initialize
several variables. This motivates the \\{Try\_read\_ini\_var} macro.

@d init_val_and_end(#)==val(lLine,#,lCode);
    end
@d Try_read_ini_var(#)==@+
  lPos:=Pos(#,lLine);
  if lPos > 0 then
    begin delete(lLine,1,lPos+15);
    init_val_and_end

@<Implementation for \texttt{librenv.pas}@>=
procedure CheckCompatibility;
var lFile: text;
lLine,lVer1,lVer2,l: string;
lPos,lCode: integer;
lMizarReleaseNbr,lMizarVersionNbr,lMizarVariantNbr: integer;
begin
   @<Open \texttt{mml.ini} file@>@;
   lMizarReleaseNbr:=-1;
   lMizarVersionNbr:=-1;
   lMizarVariantNbr:=-1;
   while not seekEof(lFile) do
   begin
      ReadLn(lFile,lLine);
      Try_read_ini_var('MizarReleaseNbr=')(lMizarReleaseNbr);
      Try_read_ini_var('MizarVersionNbr=')(lMizarVersionNbr);
      Try_read_ini_var('MizarVariantNbr=')(lMizarVariantNbr);
   end;
   close(lFile); @/
   @<Assert MML version is compatible with Mizar version@>@;
end;

@ We open the \texttt{\$MIZFILES/mml.ini} file for reading.

@<Open \texttt{mml.ini} file@>=
   FileExam(MizFiles+MML+'.ini');
   Assign(lFile,MizFiles+MML+'.ini');
   Reset(lFile);

@ We need to check the MML version is compatible with the Mizar
version. If they are not compatible, raise an error, print a warning
to the user, and halt here.

@<Assert MML version is compatible with Mizar version@>=
   if not ((lMizarReleaseNbr=PCMizarReleaseNbr) and
         (lMizarVersionNbr=PCMizarVersionNbr)) then
   begin
      Str(PCMizarReleaseNbr,l); lVer1:=l;
      Str(PCMizarVersionNbr,l); lVer1:=lVer1+'.'+l;
      Str(PCMizarVariantNbr,l); lVer1:=lVer1+'.'+l;
      Str(lMizarReleaseNbr,l); lVer2:=l;
      Str(lMizarVersionNbr,l); lVer2:=lVer2+'.'+l;
      Str(lMizarVariantNbr,l); lVer2:=lVer2+'.'+l;
      DrawMessage('Mizar System ver. '+lVer1+' is incompatible with the MML version imported ('+lVer2+')','Please check '+MizFiles+'mml.ini');
      halt(1);
   end;

@ \node{Initialize library environment.}
This will try to initialize the |MizFiles| variable to be equal to
the \texttt{\$MIZFILES} environment variable (if that environment
variable exists) or the directory of the program being executed. This
|MizFiles| will always end in a directory separator.

We also initalize |MizFileName|, |EnvFileName|, |ArticleName|,
|ArticleExt| to be empty strings.

\label{InitLibrEnv}

@d append_dir_separator(#)==@+if #[length(#)]<>DirSeparator then
  #:=#+DirSeparator;

@<Implementation for \texttt{librenv.pas}@>=
procedure InitLibrEnv;
begin
   LocFilesCollection.Init(0,20);
   MizPath:=ExtractFileDir(ParamStr(0));
   @<Initialize |Mizfiles|@>@;
   MizFileName:=''; EnvFileName:=''; ArticleName:=''; ArticleExt:='';
end;

@ Initalizing |Mizfiles| requires a bit of work. We first guess it
based on environment variables. Then we need to ensure it is a
directory path.

@<Initialize |Mizfiles|@>=
   @<Guess |MizFiles| from environment variables or executable path@>@;
   if MizFiles<>'' then append_dir_separator(MizFiles);
   if MizFiles='' then Mizfiles:=DirSeparator;

@ When the \texttt{\$MIZFILES} environment variable is set, we just
use it. When it is empty or missing, then we guess the path of the
executable invoked.

@<Guess |MizFiles| from environment variables or executable path@>=
   MizFiles:=GetEnvStr(EnvMizFiles);
   if MizFiles='' then MizFiles:=MizPath;
