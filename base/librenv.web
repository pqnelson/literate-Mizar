
@* [F] Environment library.
We have a library to handle accessing the Mizar mathematical library
files. This is used in \texttt{makeenv.dpr} and using
local \texttt{./prel/} directories.

This will execute |InitLibrEnv| (\section\xref{InitLibrEnv}) and
|CheckCompatibility| (\section\xref{CheckCompatibility}).

Here the assumption that there's an environment variable
``\texttt{\$MIZFILES}'' set to the directory containing the Mizar
Mathematical library. We discussed environment variables earlier
(\section\xref{GetEnvStr}). 

@! @:MIZFILES}{\texttt{\$MIZFILES}@>
@^Environment variable@>
@^Variable, Environment@>

@<\texttt{base/librenv.pas}@>=
  @<GNU License@>

unit librenv;

interface @|@#

uses mobjects; @|@#

const
   MML = 'mml';
   EnvMizFiles = 'MIZFILES'; @#

@t\4@> @<Public function declarations for \texttt{librenv.pas}@>@;  @#

type
   @<Declare \\{FileDescr} data type@>@;
   @<Declare \\{FileDescrCollection} data type@>@;@#

var @<Global variables declared in \texttt{librenv.pas}@>@; @#

implementation @|@#

uses @|@/
   if_def(WIN32) @t\enspace @> windows, @+ end_if @/
   mizenv,pcmizver,mconsole; @#

@<Implementation for \texttt{librenv.pas}@>@t\2@>@; @#

begin
   InitLibrEnv;
   CheckCompatibility;
end.

@ @<Global variables declared in \texttt{librenv.pas}@>=
  MizPath: string; {path to where Mizar binaries are located}
  MizFiles: string; {the ``\texttt{\$MIZFILES}'' environment variable}
  LocFilesCollection: FileDescrCollection;

@* [S] File descriptors.
We use file descriptors for things. These
are just ``a file name'' and ``a timestamp''. The ``file name'' is
either an absolute path to a file in the Mizar mathematical library,
or a relative path to a file in the user's local ``\texttt{./prel/}''
subdirectory.

Historically, the notion of ``file descriptors'' pre-dates \UNIX/. For
example, R.F. Clippinger's ``FACT---A Business Compiler: Description
and Comparison with COBOL and Commercial Translator'' (\textit{Int.\ Tracts Comput.\ Sci.\ Technol.\ Their Appl.}
\textbf{2} (1961) 231--292, \doi{10.1016/B978-1-4831-9779-1.50014-8})
seems to be among the earliest use of the term.

\CAUTION/: \PASCAL/'s \\{LongInt} is a 32-bit signed integer, which
means that Mizar will experience the 2038 ``Y2k'' bug on 03:14:07 {\mc UTC}
on 19 January 2038. Switching to \\{Int64} would solve this problem
(well, delay it for a time longer than the lifetime of the universe).

@<Declare \\{FileDescr} data type@>=
   PFileDescr = ^FileDescr; @/
   FileDescr = object(MObject) @t\1@> @/
      nName: PString;
      Time: LongInt;
      constructor Init(fIdent:string; fTime:LongInt); @t\2@>
      destructor Done; virtual; @t\2\2\2@>
   end;

@ \node{Constructor.} When creating a new \\{FileDescr} object, we
should allocate enough space for a copy of the file name. The object
then ``owns'' this copy of the file name string, and must free it when
the object is freed from memory.

@<Implementation for \texttt{librenv.pas}@>=
constructor FileDescr.Init(fIdent:string; fTime:LongInt);
begin
   nName:=NewStr(fIdent); Time:=fTime;
end;

@ \node{Destructor.} We need to free the string ``owned'' by the file
descriptor object.

@p
destructor FileDescr.Done;
begin
   DisposeStr(nName);
end;

@* [S] Collection of file descriptions.
This is just \\{MSortedCollection} (\section\xref{MSortedCollection})
of \\{FileDescr} objects.

@<Declare \\{FileDescrCollection} data type@>=
   PFileDescrCollection = ^FileDescrCollection; @/
   FileDescrCollection = object(MSortedCollection) @t\1@>
      function Compare(Key1, Key2: Pointer): integer; virtual; @t\2@>
      procedure StoreFIL(fName:string); @t\2@>
      constructor LoadFIL(fName:string); @t\2@>
      procedure InsertTimes; @t\2\2\2@>
   end;

@ \node{Ordering file descriptors.}
Comparing two entries in a file descriptor collection amounts to
comparing the names for the file descriptors. \Ithink{This should be
the \\{CompareStringPtr} (\section\xref{CompareStringPtr}) function,
just to keep the code {\mc DRY}.}

@<Implementation for \texttt{librenv.pas}@>=
function FileDescrCollection.Compare(Key1, Key2: Pointer): integer;
begin
   if PFileDescr(Key1)^.nName^ < PFileDescr(Key2)^.nName^ then Compare:=-1
   else if PFileDescr(Key1)^.nName^ = PFileDescr(Key2)^.nName^ then Compare:=0
   else Compare:=1;
end;

@ \node{Populate time field.}
Inserting file's ``last modified'' timestamp into the file descriptors relies
upon \texttt{mizenv.pas}'s |GetFileTime| (\section\xref{GetFileTime})
function.

@p
procedure FileDescrCollection.InsertTimes;
var z: integer;
begin
   for z:=0 to Count-1 do
      with PFileDescr(Items^[z])^ do Time:=GetFileTime(nName^);
end;

@ \node{Constructor.} This leverages a few primitive \PASCAL/
functions: \\{assign}(\\{file},\\{name}) assigns \\{name} to a file
but does not open the file (it is still considered closed).
Then \\{reset}(\\{file}) opens the file for reading.

Specifically, this will load a \texttt{.fil} file produced by Mizar.
These contain $2N$ lines: a file path on line $2n-1$, then a timestamp
on line $2n$ for $n=1,\dots,N$. This appears to be used for
local \texttt{prel/} files.
@:File, .fil}{File, \texttt{.fil}@>
@^Prel directory@>

@p
constructor FileDescrCollection.LoadFIL(fName:string);
var FIL: text; lName: string; lTime: longint;
begin
   Assign(FIL,fName); Reset(FIL);
   Init(0,10);
   while not eof(FIL) do
   begin
      ReadLn(FIL,lName);
      ReadLn(FIL,lTime);
      Insert(new(PFileDescr,Init(lName,lTime)));
   end;
   close(FIL);
end;

@ \node{Repopulate .fil file.}
This will erase the file named \\{fName}, then assign to \\{FIL} that
file, and $\\{rewrite}(\\{FIL})$ will open it for writing.

This will loop through every item in the caller's underlying
collection, writing the file names and times to the \texttt{.fil} file.

@p
procedure FileDescrCollection.StoreFIL(fName:string);
var FIL: text; i: integer;
begin
   EraseFile(fName);
   Assign(FIL,fName); Rewrite(FIL);
   InsertTimes;
   for i:=0 to Count-1 do
      with PFileDescr(Items^[i])^ do
         begin WriteLn(FIL,nName^); WriteLn(FIL,Time) end;
   Close(FIL);
end;

@ The library path tries to use the local version of a file, if it
exists as tested with |MFileExists| (\section\xref{MFileExists}).
Otherwise it looks at the Mizar MML version of a file, if it exists.

This returns the path to the file, as a string.
If the file cannot be found either in the local prel directory or the
MML prel directory, then it returns the empty string.

@<Public function declarations for \texttt{librenv.pas}@>=
function LibraryPath(fName,fExt: string): string;

@ @<Implementation for \texttt{librenv.pas}@>=
function LibraryPath(fName,fExt: string): string;
begin
   LibraryPath:='';
   if MFileExists('prel'+DirSeparator+fName+fExt) then {populate with local file}
   begin
      LocFilesCollection.Insert(New(PFileDescr,Init('prel'+DirSeparator+fName+fExt,0)));
      LibraryPath:='prel'+DirSeparator+fName+fExt; exit
   end;
   if MFileExists(MizFiles+'prel'+DirSeparator+fName[1]+DirSeparator+fName+fExt) then
      LibraryPath:=MizFiles+'prel'+DirSeparator+fName[1]+DirSeparator+fName+fExt;
end;

@ This function actually is not used anywhere, so I am not sure why we
have it.

@^Unused code@>

@<Public function declarations for \texttt{librenv.pas}@>=
procedure ReadSortedNames(fName:string; var fList:MStringCollection);
{UNUSED!}

@ @<Implementation for \texttt{librenv.pas}@>=
procedure ReadSortedNames(fName:string; var fList:MStringCollection);
{UNUSED!}
var NamesFile: text;
begin
   if fName[1]='@@' then
   begin
      Delete(fName,1,1);
      FileExam(fName);
      Assign(NamesFile,fName);
      Reset(NamesFile);
      fList.Init(100,100);
      while not seekEof(NamesFile) do
      begin
         ReadLn(NamesFile,fName);
         fList.Insert(NewStr(fName));
      end;
      exit;
   end;
   fList.Init(2,10);
   fList.Insert(NewStr(fName));
end;

@ Again, this function is not used anywhere, so I am not sure why we
have it.

@^Unused code@>

@<Public function declarations for \texttt{librenv.pas}@>=
procedure ReadNames(fName: string; var fList: StringColl);
{UNUSED!}

@ @<Implementation for \texttt{librenv.pas}@>=
procedure ReadNames(fName: string; var fList: StringColl);
{UNUSED!}
var NamesFile: text;
begin
   if fName[1]='@@' then
   begin
      Delete(fName,1,1);
      FileExam(fName);
      Assign(NamesFile,fName);
      Reset(NamesFile);
      fList.Init(10,10);
      while not seekEof(NamesFile) do
      begin
         ReadLn(NamesFile,fName);
         fList.Insert(NewStr(fName));
      end;
      exit;
   end;
   fList.Init(2,10);
   fList.Insert(NewStr(fName));
end;

@ This function is used in \texttt{usrtools/lisvoc.dpr}. The \\{fList}
is the \\{VocList} which consists of all the entries in
``\texttt{\$MIZFILES/mml.vct}''. The \\{fParam} is either 1 or 2.

If the user writes in a file ``\texttt{foobar}'' one vocabulary on a
line (e.g., ``\texttt{GROUP\_1}'' on one line, ``\texttt{CAT\_1}'' on
another), then |fName:='@@foobar'| will lookup the contents
``\texttt{foobar}'' and load them into the \\{fList} parameter.

@:MIZFILES}{\texttt{\$MIZFILES}@>

@<Public function declarations for \texttt{librenv.pas}@>=
procedure GetSortedNames(fParam: byte; var fList: MStringCollection);

@ @<Implementation for \texttt{librenv.pas}@>=
procedure GetSortedNames(fParam: byte; var fList: MStringCollection);
var FileName: string;
NamesFile: text;
i: integer;
begin
   if ParamCount < fParam then  begin fList.Init(0,0); exit end;
   FileName:=ParamStr(fParam);
   if FileName[1]='@@' then
   @<Populate |fList| with the contents of |FileName| and exit@>;
   @<Populate |fList| with the command-line arguments@>;
end;

@ @<Populate |fList| with the contents of |FileName| and exit@>=
   begin
      Delete(FileName,1,1);
      FileExam(FileName);
      Assign(NamesFile,FileName);
      Reset(NamesFile);
      fList.Init(10,10);
      while not seekEof(NamesFile) do
      begin
         ReadLn(NamesFile,FileName);
         fList.Insert(NewStr(TrimString(FileName)));
      end;
      exit;
   end

@ @<Populate |fList| with the command-line arguments@>=
   fList.Init(2,8);
   fList.Insert(NewStr(FileName));
   for i:=fParam+1 to ParamCount do
   begin
      FileName:=ParamStr(i);
      fList.Insert(NewStr(FileName));
   end

@ Continuing with the ``this is not used anywhere'' theme, this
function is not used anywhere. The \\{GetNames} procedure turns out to
be the same as \\{GetSortedNames}.

@<Public function declarations for \texttt{librenv.pas}@>=
procedure GetNames(fParam:byte; var fList: StringColl); {DUPLICATE CODE}

@ @<Implementation for \texttt{librenv.pas}@>=
procedure GetNames(fParam:byte; var fList: StringColl); {DUPLICATE CODE}
var FileName:string;
NamesFile: text;
i: integer;
begin
   if ParamCount < fParam then  begin fList.Init(0,0); exit end;
   FileName:=ParamStr(fParam);
   if FileName[1]='@@' then
   @<Populate |fList| with the contents of |FileName| and exit@>;
   @<Populate |fList| with the command-line arguments@>;
end;

@* [S] Check compatibility of Mizar with MML.
We will load the \texttt{mml.ini} file for the MML version number, and
we check it against the Mizar version. If they are not compatible,
print a message to the screen, and halt as an error has occurred.

\label{CheckCompatibility}
The \texttt{mml.ini} file looks something like:

\medbreak
{\obeylines\tt
[Mizar verifier]
MizarReleaseNbr=8
MizarVersionNbr=1
MizarVariantNbr=15
[MML]
NumberOfArticles=1493
MMLVersion=5.94
\par}

\medbreak\noindent%
We will read line-by-line the \texttt{mml.ini} file to initialize
several variables. This motivates the \\{Try\_read\_ini\_var} macro.

\Ithink{We should probably move towards {\mc TOML} rather than {\mc INI}
as the format for storing information, since {\mc INI} has no standard
or specification but {\mc TOML} has one.}

@:mml.ini}{\texttt{mml.ini}@>
@:ini file}{\texttt{.ini} File@>
@:file, ini}{File, \texttt{.ini}@>

@d init_val_and_end(#)==val(lLine,#,lCode);
    end
@d Try_read_ini_var(#)==@+
  lPos:=Pos(#,lLine);
  if lPos > 0 then
    begin delete(lLine,1,lPos+15);
    init_val_and_end

@<Implementation for \texttt{librenv.pas}@>=
procedure CheckCompatibility;
var lFile: text;
lLine,lVer1,lVer2,l: string;
lPos,lCode: integer;
lMizarReleaseNbr,lMizarVersionNbr,lMizarVariantNbr: integer;
begin
   @<Open \texttt{mml.ini} file@>@;
   lMizarReleaseNbr:=-1;
   lMizarVersionNbr:=-1;
   lMizarVariantNbr:=-1;
   @<Try to read the Mizar version from \texttt{mml.ini}@>;
   close(lFile); @/
   @<Assert MML version is compatible with Mizar version@>@;
end;

@ We open the \texttt{\$MIZFILES/mml.ini} file for reading.

@:MIZFILES}{\texttt{\$MIZFILES}@>

@<Open \texttt{mml.ini} file@>=
   FileExam(MizFiles+MML+'.ini');
   Assign(lFile,MizFiles+MML+'.ini');
   Reset(lFile);

@ @<Try to read the Mizar version from \texttt{mml.ini}@>=
   while not seekEof(lFile) do
   begin
      ReadLn(lFile,lLine);
      Try_read_ini_var('MizarReleaseNbr=')(lMizarReleaseNbr);
      Try_read_ini_var('MizarVersionNbr=')(lMizarVersionNbr);
      Try_read_ini_var('MizarVariantNbr=')(lMizarVariantNbr);
   end

@ We need to check the MML version is compatible with the Mizar
version. If they are not compatible, raise an error, print a warning
to the user, and halt here.

@<Assert MML version is compatible with Mizar version@>=
   if not ((lMizarReleaseNbr=PCMizarReleaseNbr) and
         (lMizarVersionNbr=PCMizarVersionNbr)) then
   begin
      Str(PCMizarReleaseNbr,l); lVer1:=l;
      Str(PCMizarVersionNbr,l); lVer1:=lVer1+'.'+l;
      Str(PCMizarVariantNbr,l); lVer1:=lVer1+'.'+l;
      Str(lMizarReleaseNbr,l); lVer2:=l;
      Str(lMizarVersionNbr,l); lVer2:=lVer2+'.'+l;
      Str(lMizarVariantNbr,l); lVer2:=lVer2+'.'+l;
      DrawMessage('Mizar System ver. '+lVer1+' is incompatible with the MML version imported ('+lVer2+')','Please check '+MizFiles+'mml.ini');
      halt(1);
   end;

@ \node{Initialize library environment.}
This will try to initialize the |MizFiles| variable to be equal to
the \texttt{\$MIZFILES} environment variable (if that environment
variable exists) or the directory of the program being executed. This
|MizFiles| will always end in a directory separator.

We also initalize |MizFileName|, |EnvFileName|, |ArticleName|,
|ArticleExt| to be empty strings.

@:MIZFILES}{\texttt{\$MIZFILES}@>
\label{InitLibrEnv}

@d append_dir_separator(#)==@+if #[length(#)]<>DirSeparator then
  #:=#+DirSeparator;

@<Implementation for \texttt{librenv.pas}@>=
procedure InitLibrEnv;
begin
   LocFilesCollection.Init(0,20);
   MizPath:=ExtractFileDir(ParamStr(0));
   @<Initialize |MizFiles|@>@;
   MizFileName:=''; EnvFileName:=''; ArticleName:=''; ArticleExt:='';
end;

@ Initalizing |MizFiles| requires a bit of work. We first guess it
based on environment variables. Then we need to ensure it is a
directory path.

@<Initialize |MizFiles|@>=
   @<Guess |MizFiles| from environment variables or executable path@>@;
   if MizFiles<>'' then append_dir_separator(MizFiles);
   if MizFiles='' then MizFiles:=DirSeparator;

@ When the \texttt{\$MIZFILES} environment variable is set, we just
use it. When it is empty or missing, then we guess the path of the
executable invoked.

@:MIZFILES}{\texttt{\$MIZFILES}@>

@<Guess |MizFiles| from environment variables or executable path@>=
   MizFiles:=GetEnvStr(EnvMizFiles);
   if MizFiles='' then MizFiles:=MizPath;
